/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/@packages/server/node_modules/@cypress/webpack-batteries-included-preprocessor/empty.js":
/*!************************************************************************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/@packages/server/node_modules/@cypress/webpack-batteries-included-preprocessor/empty.js ***!
  \************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/base64-js/index.js":
/*!***************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/base64-js/index.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/core-util-is/lib/util.js":
/*!*********************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/core-util-is/lib/util.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/events/events.js":
/*!*************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/events/events.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/ieee754/index.js":
/*!*************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/ieee754/index.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/inherits/inherits_browser.js":
/*!*************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/inherits/inherits_browser.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/isarray/index.js":
/*!*************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/isarray/index.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/node-libs-browser/node_modules/buffer/index.js":
/*!*******************************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/node-libs-browser/node_modules/buffer/index.js ***!
  \*******************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process-nextick-args/index.js":
/*!**************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process-nextick-args/index.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js":
/*!***************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/duplex-browser.js":
/*!******************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/duplex-browser.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_duplex.js");


/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_duplex.js":
/*!**********************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_duplex.js ***!
  \**********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process-nextick-args/index.js");
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(__webpack_require__(/*! core-util-is */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__(/*! inherits */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/inherits/inherits_browser.js");
/*</replacement>*/

var Readable = __webpack_require__(/*! ./_stream_readable */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_readable.js");
var Writable = __webpack_require__(/*! ./_stream_writable */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_writable.js");

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_passthrough.js":
/*!***************************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \***************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_transform.js");

/*<replacement>*/
var util = Object.create(__webpack_require__(/*! core-util-is */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__(/*! inherits */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_readable.js":
/*!************************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_readable.js ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(/*! isarray */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/isarray/index.js");
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(/*! events */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/events/events.js").EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/node_modules/safe-buffer/index.js").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(__webpack_require__(/*! core-util-is */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__(/*! inherits */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(/*! util */ 1);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/internal/streams/BufferList.js");
var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/internal/streams/destroy.js");
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_duplex.js");

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_transform.js":
/*!*************************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_transform.js ***!
  \*************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_duplex.js");

/*<replacement>*/
var util = Object.create(__webpack_require__(/*! core-util-is */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__(/*! inherits */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_writable.js":
/*!************************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_writable.js ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(__webpack_require__(/*! core-util-is */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__(/*! inherits */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/util-deprecate/browser.js")
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/node_modules/safe-buffer/index.js").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/internal/streams/destroy.js");

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_duplex.js");

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!***********************************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \***********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = __webpack_require__(/*! safe-buffer */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/node_modules/safe-buffer/index.js").Buffer;
var util = __webpack_require__(/*! util */ 2);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!********************************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process-nextick-args/index.js");
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!***************************************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \***************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! events */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/events/events.js").EventEmitter;


/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/node_modules/safe-buffer/index.js":
/*!**********************************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/node_modules/safe-buffer/index.js ***!
  \**********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/node-libs-browser/node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/passthrough.js":
/*!***************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/passthrough.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./readable */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/readable-browser.js").PassThrough


/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/readable-browser.js":
/*!********************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/readable-browser.js ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_readable.js");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_writable.js");
exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_duplex.js");
exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_transform.js");
exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_passthrough.js");


/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/transform.js":
/*!*************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/transform.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./readable */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/readable-browser.js").Transform


/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/writable-browser.js":
/*!********************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/writable-browser.js ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/lib/_stream_writable.js");


/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/safe-buffer/index.js":
/*!*****************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/safe-buffer/index.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/node-libs-browser/node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/setimmediate/setImmediate.js":
/*!*************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/setimmediate/setImmediate.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/stream-browserify/index.js":
/*!***********************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/stream-browserify/index.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = __webpack_require__(/*! events */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/events/events.js").EventEmitter;
var inherits = __webpack_require__(/*! inherits */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/inherits/inherits_browser.js");

inherits(Stream, EE);
Stream.Readable = __webpack_require__(/*! readable-stream/readable.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/readable-browser.js");
Stream.Writable = __webpack_require__(/*! readable-stream/writable.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/writable-browser.js");
Stream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/duplex-browser.js");
Stream.Transform = __webpack_require__(/*! readable-stream/transform.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/transform.js");
Stream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/readable-stream/passthrough.js");

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/string_decoder/lib/string_decoder.js":
/*!*********************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/string_decoder/lib/string_decoder.js ***!
  \*********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/safe-buffer/index.js").Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/timers-browserify/main.js":
/*!**********************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/timers-browserify/main.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/util-deprecate/browser.js":
/*!**********************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/util-deprecate/browser.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/util/node_modules/inherits/inherits_browser.js":
/*!*******************************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/util/node_modules/inherits/inherits_browser.js ***!
  \*******************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/util/support/isBufferBrowser.js":
/*!****************************************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/util/support/isBufferBrowser.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/util/util.js":
/*!*********************************************************************************************************!*\
  !*** C:/Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/util/util.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/util/node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb, null, ret) },
            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./cypress/e2e/baseClass/BaseClass.js":
/*!********************************************!*\
  !*** ./cypress/e2e/baseClass/BaseClass.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseClass = void 0;

class BaseClass {
  //In cypress code blocks to be executed before all can also be given
  //under support->e2e.js file.  Just need to write beforeEach(function()){....code to run first....}
  browserInitialization() {
    cy.visit('http://localhost:4200/#/login');
    Cypress.on('uncaught:exception', (err, runnable) => {
      return false;
    }); //Turning uncought exception off for localhost
  }

}

exports.BaseClass = BaseClass;

/***/ }),

/***/ "./cypress/e2e/pages/login_page.js":
/*!*****************************************!*\
  !*** ./cypress/e2e/pages/login_page.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LoginPage = void 0;

class LoginPage {
  //export keyword to make the class importable
  enterUsername(username) {
    cy.get(':nth-child(1) > .form-control').type(username);
  }

  enterPassword(password) {
    cy.get('#loginDatapwd').type(password);
  }

  clickLogin() {
    cy.get('.btn').click();
  }

  profileName() {
    cy.wait(4000);
    cy.get('.menu-profile > .rounded-circle').click();
  }

}

exports.LoginPage = LoginPage;

/***/ }),

/***/ "./cypress/e2e/tests/login.cy.js":
/*!***************************************!*\
  !*** ./cypress/e2e/tests/login.cy.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _mocha = __webpack_require__(/*! mocha */ "./node_modules/mocha/browser-entry.js");

var _login_page = __webpack_require__(/*! ../pages/login_page */ "./cypress/e2e/pages/login_page.js");

var _BaseClass = __webpack_require__(/*! ../baseClass/BaseClass */ "./cypress/e2e/baseClass/BaseClass.js");

//pages folder is two levels up from the current class, so need to give two dots after the slash to access it.
const loginpage = new _login_page.LoginPage();
const baseclass = new _BaseClass.BaseClass();
(0, _mocha.beforeEach)(function () {
  baseclass.browserInitialization(); //This can be given here so that browser is initialized for each it block.
});
describe('All the login it blocks Here!!', function () {
  //All the login blocks... message will come at the top of the test results
  it('Login with correct credentials', () => {
    //Use "it.only" to run only this it block.  ".skip" will skip the it block.
    loginpage.enterUsername('swaroop_uat@doqfy.in');
    loginpage.enterPassword('Swaroop@2022');
    loginpage.clickLogin();
    loginpage.profileName();
  });
  it('Login with invalid password', () => {
    loginpage.enterUsername('swaroop_uat@doqfy.in');
    loginpage.enterPassword('Swaroop@2023'); //invalid passwod

    loginpage.clickLogin();
    loginpage.profileName();
  });
});

/***/ }),

/***/ "./node_modules/browser-stdout/index.js":
/*!**********************************************!*\
  !*** ./node_modules/browser-stdout/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var WritableStream = __webpack_require__(/*! stream */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/stream-browserify/index.js").Writable
var inherits = __webpack_require__(/*! util */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/util/util.js").inherits

module.exports = BrowserStdout


inherits(BrowserStdout, WritableStream)

function BrowserStdout(opts) {
  if (!(this instanceof BrowserStdout)) return new BrowserStdout(opts)

  opts = opts || {}
  WritableStream.call(this, opts)
  this.label = (opts.label !== undefined) ? opts.label : 'stdout'
}

BrowserStdout.prototype._write = function(chunks, encoding, cb) {
  var output = chunks.toString ? chunks.toString() : chunks
  if (this.label === false) {
    console.log(output)
  } else {
    console.log(this.label+':', output)
  }
  process.nextTick(cb)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/diff/dist/diff.js":
/*!****************************************!*\
  !*** ./node_modules/diff/dist/diff.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
   true ? factory(exports) :
  undefined;
}(this, (function (exports) { 'use strict';

  function Diff() {}
  Diff.prototype = {
    diff: function diff(oldString, newString) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var callback = options.callback;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      this.options = options;
      var self = this;

      function done(value) {
        if (callback) {
          setTimeout(function () {
            callback(undefined, value);
          }, 0);
          return true;
        } else {
          return value;
        }
      } // Allow subclasses to massage the input prior to running


      oldString = this.castInput(oldString);
      newString = this.castInput(newString);
      oldString = this.removeEmpty(this.tokenize(oldString));
      newString = this.removeEmpty(this.tokenize(newString));
      var newLen = newString.length,
          oldLen = oldString.length;
      var editLength = 1;
      var maxEditLength = newLen + oldLen;
      var bestPath = [{
        newPos: -1,
        components: []
      }]; // Seed editLength = 0, i.e. the content starts with the same values

      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);

      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
        // Identity per the equality and tokenizer
        return done([{
          value: this.join(newString),
          count: newString.length
        }]);
      } // Main worker method. checks all permutations of a given edit length for acceptance.


      function execEditLength() {
        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
          var basePath = void 0;

          var addPath = bestPath[diagonalPath - 1],
              removePath = bestPath[diagonalPath + 1],
              _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;

          if (addPath) {
            // No one else is going to attempt to use this value, clear it
            bestPath[diagonalPath - 1] = undefined;
          }

          var canAdd = addPath && addPath.newPos + 1 < newLen,
              canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;

          if (!canAdd && !canRemove) {
            // If this path is a terminal then prune
            bestPath[diagonalPath] = undefined;
            continue;
          } // Select the diagonal that we want to branch from. We select the prior
          // path whose position in the new string is the farthest from the origin
          // and does not pass the bounds of the diff graph


          if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
            basePath = clonePath(removePath);
            self.pushComponent(basePath.components, undefined, true);
          } else {
            basePath = addPath; // No need to clone, we've pulled it from the list

            basePath.newPos++;
            self.pushComponent(basePath.components, true, undefined);
          }

          _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done

          if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
            return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
          } else {
            // Otherwise track this path as a potential candidate and continue.
            bestPath[diagonalPath] = basePath;
          }
        }

        editLength++;
      } // Performs the length of edit iteration. Is a bit fugly as this has to support the
      // sync and async mode which is never fun. Loops over execEditLength until a value
      // is produced.


      if (callback) {
        (function exec() {
          setTimeout(function () {
            // This should not happen, but we want to be safe.

            /* istanbul ignore next */
            if (editLength > maxEditLength) {
              return callback();
            }

            if (!execEditLength()) {
              exec();
            }
          }, 0);
        })();
      } else {
        while (editLength <= maxEditLength) {
          var ret = execEditLength();

          if (ret) {
            return ret;
          }
        }
      }
    },
    pushComponent: function pushComponent(components, added, removed) {
      var last = components[components.length - 1];

      if (last && last.added === added && last.removed === removed) {
        // We need to clone here as the component clone operation is just
        // as shallow array clone
        components[components.length - 1] = {
          count: last.count + 1,
          added: added,
          removed: removed
        };
      } else {
        components.push({
          count: 1,
          added: added,
          removed: removed
        });
      }
    },
    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
      var newLen = newString.length,
          oldLen = oldString.length,
          newPos = basePath.newPos,
          oldPos = newPos - diagonalPath,
          commonCount = 0;

      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
        newPos++;
        oldPos++;
        commonCount++;
      }

      if (commonCount) {
        basePath.components.push({
          count: commonCount
        });
      }

      basePath.newPos = newPos;
      return oldPos;
    },
    equals: function equals(left, right) {
      if (this.options.comparator) {
        return this.options.comparator(left, right);
      } else {
        return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
      }
    },
    removeEmpty: function removeEmpty(array) {
      var ret = [];

      for (var i = 0; i < array.length; i++) {
        if (array[i]) {
          ret.push(array[i]);
        }
      }

      return ret;
    },
    castInput: function castInput(value) {
      return value;
    },
    tokenize: function tokenize(value) {
      return value.split('');
    },
    join: function join(chars) {
      return chars.join('');
    }
  };

  function buildValues(diff, components, newString, oldString, useLongestToken) {
    var componentPos = 0,
        componentLen = components.length,
        newPos = 0,
        oldPos = 0;

    for (; componentPos < componentLen; componentPos++) {
      var component = components[componentPos];

      if (!component.removed) {
        if (!component.added && useLongestToken) {
          var value = newString.slice(newPos, newPos + component.count);
          value = value.map(function (value, i) {
            var oldValue = oldString[oldPos + i];
            return oldValue.length > value.length ? oldValue : value;
          });
          component.value = diff.join(value);
        } else {
          component.value = diff.join(newString.slice(newPos, newPos + component.count));
        }

        newPos += component.count; // Common case

        if (!component.added) {
          oldPos += component.count;
        }
      } else {
        component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
        oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
        // The diffing algorithm is tied to add then remove output and this is the simplest
        // route to get the desired output with minimal overhead.

        if (componentPos && components[componentPos - 1].added) {
          var tmp = components[componentPos - 1];
          components[componentPos - 1] = components[componentPos];
          components[componentPos] = tmp;
        }
      }
    } // Special case handle for when one terminal is ignored (i.e. whitespace).
    // For this case we merge the terminal into the prior string and drop the change.
    // This is only available for string mode.


    var lastComponent = components[componentLen - 1];

    if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
      components[componentLen - 2].value += lastComponent.value;
      components.pop();
    }

    return components;
  }

  function clonePath(path) {
    return {
      newPos: path.newPos,
      components: path.components.slice(0)
    };
  }

  var characterDiff = new Diff();
  function diffChars(oldStr, newStr, options) {
    return characterDiff.diff(oldStr, newStr, options);
  }

  function generateOptions(options, defaults) {
    if (typeof options === 'function') {
      defaults.callback = options;
    } else if (options) {
      for (var name in options) {
        /* istanbul ignore else */
        if (options.hasOwnProperty(name)) {
          defaults[name] = options[name];
        }
      }
    }

    return defaults;
  }

  //
  // Ranges and exceptions:
  // Latin-1 Supplement, 008000FF
  //  - U+00D7   Multiplication sign
  //  - U+00F7   Division sign
  // Latin Extended-A, 0100017F
  // Latin Extended-B, 0180024F
  // IPA Extensions, 025002AF
  // Spacing Modifier Letters, 02B002FF
  //  - U+02C7   &#711;  Caron
  //  - U+02D8   &#728;  Breve
  //  - U+02D9   &#729;  Dot Above
  //  - U+02DA   &#730;  Ring Above
  //  - U+02DB   &#731;  Ogonek
  //  - U+02DC   &#732;  Small Tilde
  //  - U+02DD   &#733;  Double Acute Accent
  // Latin Extended Additional, 1E001EFF

  var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
  var reWhitespace = /\S/;
  var wordDiff = new Diff();

  wordDiff.equals = function (left, right) {
    if (this.options.ignoreCase) {
      left = left.toLowerCase();
      right = right.toLowerCase();
    }

    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
  };

  wordDiff.tokenize = function (value) {
    // All whitespace symbols except newline group into one token, each newline - in separate token
    var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.

    for (var i = 0; i < tokens.length - 1; i++) {
      // If we have an empty string in the next field and we have only word chars before and after, merge
      if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
        tokens[i] += tokens[i + 2];
        tokens.splice(i + 1, 2);
        i--;
      }
    }

    return tokens;
  };

  function diffWords(oldStr, newStr, options) {
    options = generateOptions(options, {
      ignoreWhitespace: true
    });
    return wordDiff.diff(oldStr, newStr, options);
  }
  function diffWordsWithSpace(oldStr, newStr, options) {
    return wordDiff.diff(oldStr, newStr, options);
  }

  var lineDiff = new Diff();

  lineDiff.tokenize = function (value) {
    var retLines = [],
        linesAndNewlines = value.split(/(\n|\r\n)/); // Ignore the final empty token that occurs if the string ends with a new line

    if (!linesAndNewlines[linesAndNewlines.length - 1]) {
      linesAndNewlines.pop();
    } // Merge the content and line separators into single tokens


    for (var i = 0; i < linesAndNewlines.length; i++) {
      var line = linesAndNewlines[i];

      if (i % 2 && !this.options.newlineIsToken) {
        retLines[retLines.length - 1] += line;
      } else {
        if (this.options.ignoreWhitespace) {
          line = line.trim();
        }

        retLines.push(line);
      }
    }

    return retLines;
  };

  function diffLines(oldStr, newStr, callback) {
    return lineDiff.diff(oldStr, newStr, callback);
  }
  function diffTrimmedLines(oldStr, newStr, callback) {
    var options = generateOptions(callback, {
      ignoreWhitespace: true
    });
    return lineDiff.diff(oldStr, newStr, options);
  }

  var sentenceDiff = new Diff();

  sentenceDiff.tokenize = function (value) {
    return value.split(/(\S.+?[.!?])(?=\s+|$)/);
  };

  function diffSentences(oldStr, newStr, callback) {
    return sentenceDiff.diff(oldStr, newStr, callback);
  }

  var cssDiff = new Diff();

  cssDiff.tokenize = function (value) {
    return value.split(/([{}:;,]|\s+)/);
  };

  function diffCss(oldStr, newStr, callback) {
    return cssDiff.diff(oldStr, newStr, callback);
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var objectPrototypeToString = Object.prototype.toString;
  var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:

  jsonDiff.useLongestToken = true;
  jsonDiff.tokenize = lineDiff.tokenize;

  jsonDiff.castInput = function (value) {
    var _this$options = this.options,
        undefinedReplacement = _this$options.undefinedReplacement,
        _this$options$stringi = _this$options.stringifyReplacer,
        stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {
      return typeof v === 'undefined' ? undefinedReplacement : v;
    } : _this$options$stringi;
    return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
  };

  jsonDiff.equals = function (left, right) {
    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
  };

  function diffJson(oldObj, newObj, options) {
    return jsonDiff.diff(oldObj, newObj, options);
  } // This function handles the presence of circular references by bailing out when encountering an
  // object that is already on the "stack" of items being processed. Accepts an optional replacer

  function canonicalize(obj, stack, replacementStack, replacer, key) {
    stack = stack || [];
    replacementStack = replacementStack || [];

    if (replacer) {
      obj = replacer(key, obj);
    }

    var i;

    for (i = 0; i < stack.length; i += 1) {
      if (stack[i] === obj) {
        return replacementStack[i];
      }
    }

    var canonicalizedObj;

    if ('[object Array]' === objectPrototypeToString.call(obj)) {
      stack.push(obj);
      canonicalizedObj = new Array(obj.length);
      replacementStack.push(canonicalizedObj);

      for (i = 0; i < obj.length; i += 1) {
        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
      }

      stack.pop();
      replacementStack.pop();
      return canonicalizedObj;
    }

    if (obj && obj.toJSON) {
      obj = obj.toJSON();
    }

    if (_typeof(obj) === 'object' && obj !== null) {
      stack.push(obj);
      canonicalizedObj = {};
      replacementStack.push(canonicalizedObj);

      var sortedKeys = [],
          _key;

      for (_key in obj) {
        /* istanbul ignore else */
        if (obj.hasOwnProperty(_key)) {
          sortedKeys.push(_key);
        }
      }

      sortedKeys.sort();

      for (i = 0; i < sortedKeys.length; i += 1) {
        _key = sortedKeys[i];
        canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
      }

      stack.pop();
      replacementStack.pop();
    } else {
      canonicalizedObj = obj;
    }

    return canonicalizedObj;
  }

  var arrayDiff = new Diff();

  arrayDiff.tokenize = function (value) {
    return value.slice();
  };

  arrayDiff.join = arrayDiff.removeEmpty = function (value) {
    return value;
  };

  function diffArrays(oldArr, newArr, callback) {
    return arrayDiff.diff(oldArr, newArr, callback);
  }

  function parsePatch(uniDiff) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
        delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
        list = [],
        i = 0;

    function parseIndex() {
      var index = {};
      list.push(index); // Parse diff metadata

      while (i < diffstr.length) {
        var line = diffstr[i]; // File header found, end parsing diff metadata

        if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
          break;
        } // Diff index


        var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);

        if (header) {
          index.index = header[1];
        }

        i++;
      } // Parse file headers if they are defined. Unified diff requires them, but
      // there's no technical issues to have an isolated hunk without file header


      parseFileHeader(index);
      parseFileHeader(index); // Parse hunks

      index.hunks = [];

      while (i < diffstr.length) {
        var _line = diffstr[i];

        if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
          break;
        } else if (/^@@/.test(_line)) {
          index.hunks.push(parseHunk());
        } else if (_line && options.strict) {
          // Ignore unexpected content unless in strict mode
          throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
        } else {
          i++;
        }
      }
    } // Parses the --- and +++ headers, if none are found, no lines
    // are consumed.


    function parseFileHeader(index) {
      var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);

      if (fileHeader) {
        var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
        var data = fileHeader[2].split('\t', 2);
        var fileName = data[0].replace(/\\\\/g, '\\');

        if (/^".*"$/.test(fileName)) {
          fileName = fileName.substr(1, fileName.length - 2);
        }

        index[keyPrefix + 'FileName'] = fileName;
        index[keyPrefix + 'Header'] = (data[1] || '').trim();
        i++;
      }
    } // Parses a hunk
    // This assumes that we are at the start of a hunk.


    function parseHunk() {
      var chunkHeaderIndex = i,
          chunkHeaderLine = diffstr[i++],
          chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
      var hunk = {
        oldStart: +chunkHeader[1],
        oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],
        newStart: +chunkHeader[3],
        newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],
        lines: [],
        linedelimiters: []
      }; // Unified Diff Format quirk: If the chunk size is 0,
      // the first number is one lower than one would expect.
      // https://www.artima.com/weblogs/viewpost.jsp?thread=164293

      if (hunk.oldLines === 0) {
        hunk.oldStart += 1;
      }

      if (hunk.newLines === 0) {
        hunk.newStart += 1;
      }

      var addCount = 0,
          removeCount = 0;

      for (; i < diffstr.length; i++) {
        // Lines starting with '---' could be mistaken for the "remove line" operation
        // But they could be the header for the next file. Therefore prune such cases out.
        if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
          break;
        }

        var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];

        if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
          hunk.lines.push(diffstr[i]);
          hunk.linedelimiters.push(delimiters[i] || '\n');

          if (operation === '+') {
            addCount++;
          } else if (operation === '-') {
            removeCount++;
          } else if (operation === ' ') {
            addCount++;
            removeCount++;
          }
        } else {
          break;
        }
      } // Handle the empty block count case


      if (!addCount && hunk.newLines === 1) {
        hunk.newLines = 0;
      }

      if (!removeCount && hunk.oldLines === 1) {
        hunk.oldLines = 0;
      } // Perform optional sanity checking


      if (options.strict) {
        if (addCount !== hunk.newLines) {
          throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
        }

        if (removeCount !== hunk.oldLines) {
          throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
        }
      }

      return hunk;
    }

    while (i < diffstr.length) {
      parseIndex();
    }

    return list;
  }

  // Iterator that traverses in the range of [min, max], stepping
  // by distance from a given start position. I.e. for [0, 4], with
  // start of 2, this will iterate 2, 3, 1, 4, 0.
  function distanceIterator (start, minLine, maxLine) {
    var wantForward = true,
        backwardExhausted = false,
        forwardExhausted = false,
        localOffset = 1;
    return function iterator() {
      if (wantForward && !forwardExhausted) {
        if (backwardExhausted) {
          localOffset++;
        } else {
          wantForward = false;
        } // Check if trying to fit beyond text length, and if not, check it fits
        // after offset location (or desired location on first iteration)


        if (start + localOffset <= maxLine) {
          return localOffset;
        }

        forwardExhausted = true;
      }

      if (!backwardExhausted) {
        if (!forwardExhausted) {
          wantForward = true;
        } // Check if trying to fit before text beginning, and if not, check it fits
        // before offset location


        if (minLine <= start - localOffset) {
          return -localOffset++;
        }

        backwardExhausted = true;
        return iterator();
      } // We tried to fit hunk before text beginning and beyond text length, then
      // hunk can't fit on the text. Return undefined

    };
  }

  function applyPatch(source, uniDiff) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (typeof uniDiff === 'string') {
      uniDiff = parsePatch(uniDiff);
    }

    if (Array.isArray(uniDiff)) {
      if (uniDiff.length > 1) {
        throw new Error('applyPatch only works with a single input.');
      }

      uniDiff = uniDiff[0];
    } // Apply the diff to the input


    var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
        delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
        hunks = uniDiff.hunks,
        compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {
      return line === patchContent;
    },
        errorCount = 0,
        fuzzFactor = options.fuzzFactor || 0,
        minLine = 0,
        offset = 0,
        removeEOFNL,
        addEOFNL;
    /**
     * Checks if the hunk exactly fits on the provided location
     */


    function hunkFits(hunk, toPos) {
      for (var j = 0; j < hunk.lines.length; j++) {
        var line = hunk.lines[j],
            operation = line.length > 0 ? line[0] : ' ',
            content = line.length > 0 ? line.substr(1) : line;

        if (operation === ' ' || operation === '-') {
          // Context sanity check
          if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
            errorCount++;

            if (errorCount > fuzzFactor) {
              return false;
            }
          }

          toPos++;
        }
      }

      return true;
    } // Search best fit offsets for each hunk based on the previous ones


    for (var i = 0; i < hunks.length; i++) {
      var hunk = hunks[i],
          maxLine = lines.length - hunk.oldLines,
          localOffset = 0,
          toPos = offset + hunk.oldStart - 1;
      var iterator = distanceIterator(toPos, minLine, maxLine);

      for (; localOffset !== undefined; localOffset = iterator()) {
        if (hunkFits(hunk, toPos + localOffset)) {
          hunk.offset = offset += localOffset;
          break;
        }
      }

      if (localOffset === undefined) {
        return false;
      } // Set lower text limit to end of the current hunk, so next ones don't try
      // to fit over already patched text


      minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
    } // Apply patch hunks


    var diffOffset = 0;

    for (var _i = 0; _i < hunks.length; _i++) {
      var _hunk = hunks[_i],
          _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;

      diffOffset += _hunk.newLines - _hunk.oldLines;

      for (var j = 0; j < _hunk.lines.length; j++) {
        var line = _hunk.lines[j],
            operation = line.length > 0 ? line[0] : ' ',
            content = line.length > 0 ? line.substr(1) : line,
            delimiter = _hunk.linedelimiters[j];

        if (operation === ' ') {
          _toPos++;
        } else if (operation === '-') {
          lines.splice(_toPos, 1);
          delimiters.splice(_toPos, 1);
          /* istanbul ignore else */
        } else if (operation === '+') {
          lines.splice(_toPos, 0, content);
          delimiters.splice(_toPos, 0, delimiter);
          _toPos++;
        } else if (operation === '\\') {
          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;

          if (previousOperation === '+') {
            removeEOFNL = true;
          } else if (previousOperation === '-') {
            addEOFNL = true;
          }
        }
      }
    } // Handle EOFNL insertion/removal


    if (removeEOFNL) {
      while (!lines[lines.length - 1]) {
        lines.pop();
        delimiters.pop();
      }
    } else if (addEOFNL) {
      lines.push('');
      delimiters.push('\n');
    }

    for (var _k = 0; _k < lines.length - 1; _k++) {
      lines[_k] = lines[_k] + delimiters[_k];
    }

    return lines.join('');
  } // Wrapper that supports multiple file patches via callbacks.

  function applyPatches(uniDiff, options) {
    if (typeof uniDiff === 'string') {
      uniDiff = parsePatch(uniDiff);
    }

    var currentIndex = 0;

    function processIndex() {
      var index = uniDiff[currentIndex++];

      if (!index) {
        return options.complete();
      }

      options.loadFile(index, function (err, data) {
        if (err) {
          return options.complete(err);
        }

        var updatedContent = applyPatch(data, index, options);
        options.patched(index, updatedContent, function (err) {
          if (err) {
            return options.complete(err);
          }

          processIndex();
        });
      });
    }

    processIndex();
  }

  function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
    if (!options) {
      options = {};
    }

    if (typeof options.context === 'undefined') {
      options.context = 4;
    }

    var diff = diffLines(oldStr, newStr, options);
    diff.push({
      value: '',
      lines: []
    }); // Append an empty value to make cleanup easier

    function contextLines(lines) {
      return lines.map(function (entry) {
        return ' ' + entry;
      });
    }

    var hunks = [];
    var oldRangeStart = 0,
        newRangeStart = 0,
        curRange = [],
        oldLine = 1,
        newLine = 1;

    var _loop = function _loop(i) {
      var current = diff[i],
          lines = current.lines || current.value.replace(/\n$/, '').split('\n');
      current.lines = lines;

      if (current.added || current.removed) {
        var _curRange;

        // If we have previous context, start with that
        if (!oldRangeStart) {
          var prev = diff[i - 1];
          oldRangeStart = oldLine;
          newRangeStart = newLine;

          if (prev) {
            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
            oldRangeStart -= curRange.length;
            newRangeStart -= curRange.length;
          }
        } // Output our changes


        (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {
          return (current.added ? '+' : '-') + entry;
        }))); // Track the updated file position


        if (current.added) {
          newLine += lines.length;
        } else {
          oldLine += lines.length;
        }
      } else {
        // Identical context lines. Track line changes
        if (oldRangeStart) {
          // Close out any changes that have been output (or join overlapping)
          if (lines.length <= options.context * 2 && i < diff.length - 2) {
            var _curRange2;

            // Overlapping
            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
          } else {
            var _curRange3;

            // end the range and output
            var contextSize = Math.min(lines.length, options.context);

            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));

            var hunk = {
              oldStart: oldRangeStart,
              oldLines: oldLine - oldRangeStart + contextSize,
              newStart: newRangeStart,
              newLines: newLine - newRangeStart + contextSize,
              lines: curRange
            };

            if (i >= diff.length - 2 && lines.length <= options.context) {
              // EOF is inside this hunk
              var oldEOFNewline = /\n$/.test(oldStr);
              var newEOFNewline = /\n$/.test(newStr);
              var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;

              if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {
                // special case: old has no eol and no trailing context; no-nl can end up before adds
                // however, if the old file is empty, do not output the no-nl line
                curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
              }

              if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
                curRange.push('\\ No newline at end of file');
              }
            }

            hunks.push(hunk);
            oldRangeStart = 0;
            newRangeStart = 0;
            curRange = [];
          }
        }

        oldLine += lines.length;
        newLine += lines.length;
      }
    };

    for (var i = 0; i < diff.length; i++) {
      _loop(i);
    }

    return {
      oldFileName: oldFileName,
      newFileName: newFileName,
      oldHeader: oldHeader,
      newHeader: newHeader,
      hunks: hunks
    };
  }
  function formatPatch(diff) {
    var ret = [];

    if (diff.oldFileName == diff.newFileName) {
      ret.push('Index: ' + diff.oldFileName);
    }

    ret.push('===================================================================');
    ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
    ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));

    for (var i = 0; i < diff.hunks.length; i++) {
      var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,
      // the first number is one lower than one would expect.
      // https://www.artima.com/weblogs/viewpost.jsp?thread=164293

      if (hunk.oldLines === 0) {
        hunk.oldStart -= 1;
      }

      if (hunk.newLines === 0) {
        hunk.newStart -= 1;
      }

      ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
      ret.push.apply(ret, hunk.lines);
    }

    return ret.join('\n') + '\n';
  }
  function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
    return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));
  }
  function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
  }

  function arrayEqual(a, b) {
    if (a.length !== b.length) {
      return false;
    }

    return arrayStartsWith(a, b);
  }
  function arrayStartsWith(array, start) {
    if (start.length > array.length) {
      return false;
    }

    for (var i = 0; i < start.length; i++) {
      if (start[i] !== array[i]) {
        return false;
      }
    }

    return true;
  }

  function calcLineCount(hunk) {
    var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),
        oldLines = _calcOldNewLineCount.oldLines,
        newLines = _calcOldNewLineCount.newLines;

    if (oldLines !== undefined) {
      hunk.oldLines = oldLines;
    } else {
      delete hunk.oldLines;
    }

    if (newLines !== undefined) {
      hunk.newLines = newLines;
    } else {
      delete hunk.newLines;
    }
  }
  function merge(mine, theirs, base) {
    mine = loadPatch(mine, base);
    theirs = loadPatch(theirs, base);
    var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.
    // Leaving sanity checks on this to the API consumer that may know more about the
    // meaning in their own context.

    if (mine.index || theirs.index) {
      ret.index = mine.index || theirs.index;
    }

    if (mine.newFileName || theirs.newFileName) {
      if (!fileNameChanged(mine)) {
        // No header or no change in ours, use theirs (and ours if theirs does not exist)
        ret.oldFileName = theirs.oldFileName || mine.oldFileName;
        ret.newFileName = theirs.newFileName || mine.newFileName;
        ret.oldHeader = theirs.oldHeader || mine.oldHeader;
        ret.newHeader = theirs.newHeader || mine.newHeader;
      } else if (!fileNameChanged(theirs)) {
        // No header or no change in theirs, use ours
        ret.oldFileName = mine.oldFileName;
        ret.newFileName = mine.newFileName;
        ret.oldHeader = mine.oldHeader;
        ret.newHeader = mine.newHeader;
      } else {
        // Both changed... figure it out
        ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
        ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
        ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
        ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
      }
    }

    ret.hunks = [];
    var mineIndex = 0,
        theirsIndex = 0,
        mineOffset = 0,
        theirsOffset = 0;

    while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
      var mineCurrent = mine.hunks[mineIndex] || {
        oldStart: Infinity
      },
          theirsCurrent = theirs.hunks[theirsIndex] || {
        oldStart: Infinity
      };

      if (hunkBefore(mineCurrent, theirsCurrent)) {
        // This patch does not overlap with any of the others, yay.
        ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
        mineIndex++;
        theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
      } else if (hunkBefore(theirsCurrent, mineCurrent)) {
        // This patch does not overlap with any of the others, yay.
        ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
        theirsIndex++;
        mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
      } else {
        // Overlap, merge as best we can
        var mergedHunk = {
          oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
          oldLines: 0,
          newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
          newLines: 0,
          lines: []
        };
        mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
        theirsIndex++;
        mineIndex++;
        ret.hunks.push(mergedHunk);
      }
    }

    return ret;
  }

  function loadPatch(param, base) {
    if (typeof param === 'string') {
      if (/^@@/m.test(param) || /^Index:/m.test(param)) {
        return parsePatch(param)[0];
      }

      if (!base) {
        throw new Error('Must provide a base reference or pass in a patch');
      }

      return structuredPatch(undefined, undefined, base, param);
    }

    return param;
  }

  function fileNameChanged(patch) {
    return patch.newFileName && patch.newFileName !== patch.oldFileName;
  }

  function selectField(index, mine, theirs) {
    if (mine === theirs) {
      return mine;
    } else {
      index.conflict = true;
      return {
        mine: mine,
        theirs: theirs
      };
    }
  }

  function hunkBefore(test, check) {
    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
  }

  function cloneHunk(hunk, offset) {
    return {
      oldStart: hunk.oldStart,
      oldLines: hunk.oldLines,
      newStart: hunk.newStart + offset,
      newLines: hunk.newLines,
      lines: hunk.lines
    };
  }

  function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
    // This will generally result in a conflicted hunk, but there are cases where the context
    // is the only overlap where we can successfully merge the content here.
    var mine = {
      offset: mineOffset,
      lines: mineLines,
      index: 0
    },
        their = {
      offset: theirOffset,
      lines: theirLines,
      index: 0
    }; // Handle any leading content

    insertLeading(hunk, mine, their);
    insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.

    while (mine.index < mine.lines.length && their.index < their.lines.length) {
      var mineCurrent = mine.lines[mine.index],
          theirCurrent = their.lines[their.index];

      if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {
        // Both modified ...
        mutualChange(hunk, mine, their);
      } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {
        var _hunk$lines;

        // Mine inserted
        (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));
      } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {
        var _hunk$lines2;

        // Theirs inserted
        (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));
      } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {
        // Mine removed or edited
        removal(hunk, mine, their);
      } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {
        // Their removed or edited
        removal(hunk, their, mine, true);
      } else if (mineCurrent === theirCurrent) {
        // Context identity
        hunk.lines.push(mineCurrent);
        mine.index++;
        their.index++;
      } else {
        // Context mismatch
        conflict(hunk, collectChange(mine), collectChange(their));
      }
    } // Now push anything that may be remaining


    insertTrailing(hunk, mine);
    insertTrailing(hunk, their);
    calcLineCount(hunk);
  }

  function mutualChange(hunk, mine, their) {
    var myChanges = collectChange(mine),
        theirChanges = collectChange(their);

    if (allRemoves(myChanges) && allRemoves(theirChanges)) {
      // Special case for remove changes that are supersets of one another
      if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
        var _hunk$lines3;

        (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));

        return;
      } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
        var _hunk$lines4;

        (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));

        return;
      }
    } else if (arrayEqual(myChanges, theirChanges)) {
      var _hunk$lines5;

      (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));

      return;
    }

    conflict(hunk, myChanges, theirChanges);
  }

  function removal(hunk, mine, their, swap) {
    var myChanges = collectChange(mine),
        theirChanges = collectContext(their, myChanges);

    if (theirChanges.merged) {
      var _hunk$lines6;

      (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));
    } else {
      conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
    }
  }

  function conflict(hunk, mine, their) {
    hunk.conflict = true;
    hunk.lines.push({
      conflict: true,
      mine: mine,
      theirs: their
    });
  }

  function insertLeading(hunk, insert, their) {
    while (insert.offset < their.offset && insert.index < insert.lines.length) {
      var line = insert.lines[insert.index++];
      hunk.lines.push(line);
      insert.offset++;
    }
  }

  function insertTrailing(hunk, insert) {
    while (insert.index < insert.lines.length) {
      var line = insert.lines[insert.index++];
      hunk.lines.push(line);
    }
  }

  function collectChange(state) {
    var ret = [],
        operation = state.lines[state.index][0];

    while (state.index < state.lines.length) {
      var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one "atomic" modify change.

      if (operation === '-' && line[0] === '+') {
        operation = '+';
      }

      if (operation === line[0]) {
        ret.push(line);
        state.index++;
      } else {
        break;
      }
    }

    return ret;
  }

  function collectContext(state, matchChanges) {
    var changes = [],
        merged = [],
        matchIndex = 0,
        contextChanges = false,
        conflicted = false;

    while (matchIndex < matchChanges.length && state.index < state.lines.length) {
      var change = state.lines[state.index],
          match = matchChanges[matchIndex]; // Once we've hit our add, then we are done

      if (match[0] === '+') {
        break;
      }

      contextChanges = contextChanges || change[0] !== ' ';
      merged.push(match);
      matchIndex++; // Consume any additions in the other block as a conflict to attempt
      // to pull in the remaining context after this

      if (change[0] === '+') {
        conflicted = true;

        while (change[0] === '+') {
          changes.push(change);
          change = state.lines[++state.index];
        }
      }

      if (match.substr(1) === change.substr(1)) {
        changes.push(change);
        state.index++;
      } else {
        conflicted = true;
      }
    }

    if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {
      conflicted = true;
    }

    if (conflicted) {
      return changes;
    }

    while (matchIndex < matchChanges.length) {
      merged.push(matchChanges[matchIndex++]);
    }

    return {
      merged: merged,
      changes: changes
    };
  }

  function allRemoves(changes) {
    return changes.reduce(function (prev, change) {
      return prev && change[0] === '-';
    }, true);
  }

  function skipRemoveSuperset(state, removeChanges, delta) {
    for (var i = 0; i < delta; i++) {
      var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);

      if (state.lines[state.index + i] !== ' ' + changeContent) {
        return false;
      }
    }

    state.index += delta;
    return true;
  }

  function calcOldNewLineCount(lines) {
    var oldLines = 0;
    var newLines = 0;
    lines.forEach(function (line) {
      if (typeof line !== 'string') {
        var myCount = calcOldNewLineCount(line.mine);
        var theirCount = calcOldNewLineCount(line.theirs);

        if (oldLines !== undefined) {
          if (myCount.oldLines === theirCount.oldLines) {
            oldLines += myCount.oldLines;
          } else {
            oldLines = undefined;
          }
        }

        if (newLines !== undefined) {
          if (myCount.newLines === theirCount.newLines) {
            newLines += myCount.newLines;
          } else {
            newLines = undefined;
          }
        }
      } else {
        if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {
          newLines++;
        }

        if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {
          oldLines++;
        }
      }
    });
    return {
      oldLines: oldLines,
      newLines: newLines
    };
  }

  // See: http://code.google.com/p/google-diff-match-patch/wiki/API
  function convertChangesToDMP(changes) {
    var ret = [],
        change,
        operation;

    for (var i = 0; i < changes.length; i++) {
      change = changes[i];

      if (change.added) {
        operation = 1;
      } else if (change.removed) {
        operation = -1;
      } else {
        operation = 0;
      }

      ret.push([operation, change.value]);
    }

    return ret;
  }

  function convertChangesToXML(changes) {
    var ret = [];

    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];

      if (change.added) {
        ret.push('<ins>');
      } else if (change.removed) {
        ret.push('<del>');
      }

      ret.push(escapeHTML(change.value));

      if (change.added) {
        ret.push('</ins>');
      } else if (change.removed) {
        ret.push('</del>');
      }
    }

    return ret.join('');
  }

  function escapeHTML(s) {
    var n = s;
    n = n.replace(/&/g, '&amp;');
    n = n.replace(/</g, '&lt;');
    n = n.replace(/>/g, '&gt;');
    n = n.replace(/"/g, '&quot;');
    return n;
  }

  exports.Diff = Diff;
  exports.applyPatch = applyPatch;
  exports.applyPatches = applyPatches;
  exports.canonicalize = canonicalize;
  exports.convertChangesToDMP = convertChangesToDMP;
  exports.convertChangesToXML = convertChangesToXML;
  exports.createPatch = createPatch;
  exports.createTwoFilesPatch = createTwoFilesPatch;
  exports.diffArrays = diffArrays;
  exports.diffChars = diffChars;
  exports.diffCss = diffCss;
  exports.diffJson = diffJson;
  exports.diffLines = diffLines;
  exports.diffSentences = diffSentences;
  exports.diffTrimmedLines = diffTrimmedLines;
  exports.diffWords = diffWords;
  exports.diffWordsWithSpace = diffWordsWithSpace;
  exports.merge = merge;
  exports.parsePatch = parsePatch;
  exports.structuredPatch = structuredPatch;

  Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "./node_modules/he/he.js":
/*!*******************************!*\
  !*** ./node_modules/he/he.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/he v1.2.0 by @mathias | MIT license */
;(function(root) {

	// Detect free variables `exports`.
	var freeExports =  true && exports;

	// Detect free variable `module`.
	var freeModule =  true && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`.
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	// All astral symbols.
	var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	// All ASCII symbols (not just printable ASCII) except those listed in the
	// first column of the overrides table.
	// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides
	var regexAsciiWhitelist = /[\x01-\x7F]/g;
	// All BMP symbols that are not ASCII newlines, printable ASCII symbols, or
	// code points listed in the first column of the overrides table on
	// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.
	var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;

	var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
	var encodeMap = {'\xAD':'shy','\u200C':'zwnj','\u200D':'zwj','\u200E':'lrm','\u2063':'ic','\u2062':'it','\u2061':'af','\u200F':'rlm','\u200B':'ZeroWidthSpace','\u2060':'NoBreak','\u0311':'DownBreve','\u20DB':'tdot','\u20DC':'DotDot','\t':'Tab','\n':'NewLine','\u2008':'puncsp','\u205F':'MediumSpace','\u2009':'thinsp','\u200A':'hairsp','\u2004':'emsp13','\u2002':'ensp','\u2005':'emsp14','\u2003':'emsp','\u2007':'numsp','\xA0':'nbsp','\u205F\u200A':'ThickSpace','\u203E':'oline','_':'lowbar','\u2010':'dash','\u2013':'ndash','\u2014':'mdash','\u2015':'horbar',',':'comma',';':'semi','\u204F':'bsemi',':':'colon','\u2A74':'Colone','!':'excl','\xA1':'iexcl','?':'quest','\xBF':'iquest','.':'period','\u2025':'nldr','\u2026':'mldr','\xB7':'middot','\'':'apos','\u2018':'lsquo','\u2019':'rsquo','\u201A':'sbquo','\u2039':'lsaquo','\u203A':'rsaquo','"':'quot','\u201C':'ldquo','\u201D':'rdquo','\u201E':'bdquo','\xAB':'laquo','\xBB':'raquo','(':'lpar',')':'rpar','[':'lsqb',']':'rsqb','{':'lcub','}':'rcub','\u2308':'lceil','\u2309':'rceil','\u230A':'lfloor','\u230B':'rfloor','\u2985':'lopar','\u2986':'ropar','\u298B':'lbrke','\u298C':'rbrke','\u298D':'lbrkslu','\u298E':'rbrksld','\u298F':'lbrksld','\u2990':'rbrkslu','\u2991':'langd','\u2992':'rangd','\u2993':'lparlt','\u2994':'rpargt','\u2995':'gtlPar','\u2996':'ltrPar','\u27E6':'lobrk','\u27E7':'robrk','\u27E8':'lang','\u27E9':'rang','\u27EA':'Lang','\u27EB':'Rang','\u27EC':'loang','\u27ED':'roang','\u2772':'lbbrk','\u2773':'rbbrk','\u2016':'Vert','\xA7':'sect','\xB6':'para','@':'commat','*':'ast','/':'sol','undefined':null,'&':'amp','#':'num','%':'percnt','\u2030':'permil','\u2031':'pertenk','\u2020':'dagger','\u2021':'Dagger','\u2022':'bull','\u2043':'hybull','\u2032':'prime','\u2033':'Prime','\u2034':'tprime','\u2057':'qprime','\u2035':'bprime','\u2041':'caret','`':'grave','\xB4':'acute','\u02DC':'tilde','^':'Hat','\xAF':'macr','\u02D8':'breve','\u02D9':'dot','\xA8':'die','\u02DA':'ring','\u02DD':'dblac','\xB8':'cedil','\u02DB':'ogon','\u02C6':'circ','\u02C7':'caron','\xB0':'deg','\xA9':'copy','\xAE':'reg','\u2117':'copysr','\u2118':'wp','\u211E':'rx','\u2127':'mho','\u2129':'iiota','\u2190':'larr','\u219A':'nlarr','\u2192':'rarr','\u219B':'nrarr','\u2191':'uarr','\u2193':'darr','\u2194':'harr','\u21AE':'nharr','\u2195':'varr','\u2196':'nwarr','\u2197':'nearr','\u2198':'searr','\u2199':'swarr','\u219D':'rarrw','\u219D\u0338':'nrarrw','\u219E':'Larr','\u219F':'Uarr','\u21A0':'Rarr','\u21A1':'Darr','\u21A2':'larrtl','\u21A3':'rarrtl','\u21A4':'mapstoleft','\u21A5':'mapstoup','\u21A6':'map','\u21A7':'mapstodown','\u21A9':'larrhk','\u21AA':'rarrhk','\u21AB':'larrlp','\u21AC':'rarrlp','\u21AD':'harrw','\u21B0':'lsh','\u21B1':'rsh','\u21B2':'ldsh','\u21B3':'rdsh','\u21B5':'crarr','\u21B6':'cularr','\u21B7':'curarr','\u21BA':'olarr','\u21BB':'orarr','\u21BC':'lharu','\u21BD':'lhard','\u21BE':'uharr','\u21BF':'uharl','\u21C0':'rharu','\u21C1':'rhard','\u21C2':'dharr','\u21C3':'dharl','\u21C4':'rlarr','\u21C5':'udarr','\u21C6':'lrarr','\u21C7':'llarr','\u21C8':'uuarr','\u21C9':'rrarr','\u21CA':'ddarr','\u21CB':'lrhar','\u21CC':'rlhar','\u21D0':'lArr','\u21CD':'nlArr','\u21D1':'uArr','\u21D2':'rArr','\u21CF':'nrArr','\u21D3':'dArr','\u21D4':'iff','\u21CE':'nhArr','\u21D5':'vArr','\u21D6':'nwArr','\u21D7':'neArr','\u21D8':'seArr','\u21D9':'swArr','\u21DA':'lAarr','\u21DB':'rAarr','\u21DD':'zigrarr','\u21E4':'larrb','\u21E5':'rarrb','\u21F5':'duarr','\u21FD':'loarr','\u21FE':'roarr','\u21FF':'hoarr','\u2200':'forall','\u2201':'comp','\u2202':'part','\u2202\u0338':'npart','\u2203':'exist','\u2204':'nexist','\u2205':'empty','\u2207':'Del','\u2208':'in','\u2209':'notin','\u220B':'ni','\u220C':'notni','\u03F6':'bepsi','\u220F':'prod','\u2210':'coprod','\u2211':'sum','+':'plus','\xB1':'pm','\xF7':'div','\xD7':'times','<':'lt','\u226E':'nlt','<\u20D2':'nvlt','=':'equals','\u2260':'ne','=\u20E5':'bne','\u2A75':'Equal','>':'gt','\u226F':'ngt','>\u20D2':'nvgt','\xAC':'not','|':'vert','\xA6':'brvbar','\u2212':'minus','\u2213':'mp','\u2214':'plusdo','\u2044':'frasl','\u2216':'setmn','\u2217':'lowast','\u2218':'compfn','\u221A':'Sqrt','\u221D':'prop','\u221E':'infin','\u221F':'angrt','\u2220':'ang','\u2220\u20D2':'nang','\u2221':'angmsd','\u2222':'angsph','\u2223':'mid','\u2224':'nmid','\u2225':'par','\u2226':'npar','\u2227':'and','\u2228':'or','\u2229':'cap','\u2229\uFE00':'caps','\u222A':'cup','\u222A\uFE00':'cups','\u222B':'int','\u222C':'Int','\u222D':'tint','\u2A0C':'qint','\u222E':'oint','\u222F':'Conint','\u2230':'Cconint','\u2231':'cwint','\u2232':'cwconint','\u2233':'awconint','\u2234':'there4','\u2235':'becaus','\u2236':'ratio','\u2237':'Colon','\u2238':'minusd','\u223A':'mDDot','\u223B':'homtht','\u223C':'sim','\u2241':'nsim','\u223C\u20D2':'nvsim','\u223D':'bsim','\u223D\u0331':'race','\u223E':'ac','\u223E\u0333':'acE','\u223F':'acd','\u2240':'wr','\u2242':'esim','\u2242\u0338':'nesim','\u2243':'sime','\u2244':'nsime','\u2245':'cong','\u2247':'ncong','\u2246':'simne','\u2248':'ap','\u2249':'nap','\u224A':'ape','\u224B':'apid','\u224B\u0338':'napid','\u224C':'bcong','\u224D':'CupCap','\u226D':'NotCupCap','\u224D\u20D2':'nvap','\u224E':'bump','\u224E\u0338':'nbump','\u224F':'bumpe','\u224F\u0338':'nbumpe','\u2250':'doteq','\u2250\u0338':'nedot','\u2251':'eDot','\u2252':'efDot','\u2253':'erDot','\u2254':'colone','\u2255':'ecolon','\u2256':'ecir','\u2257':'cire','\u2259':'wedgeq','\u225A':'veeeq','\u225C':'trie','\u225F':'equest','\u2261':'equiv','\u2262':'nequiv','\u2261\u20E5':'bnequiv','\u2264':'le','\u2270':'nle','\u2264\u20D2':'nvle','\u2265':'ge','\u2271':'nge','\u2265\u20D2':'nvge','\u2266':'lE','\u2266\u0338':'nlE','\u2267':'gE','\u2267\u0338':'ngE','\u2268\uFE00':'lvnE','\u2268':'lnE','\u2269':'gnE','\u2269\uFE00':'gvnE','\u226A':'ll','\u226A\u0338':'nLtv','\u226A\u20D2':'nLt','\u226B':'gg','\u226B\u0338':'nGtv','\u226B\u20D2':'nGt','\u226C':'twixt','\u2272':'lsim','\u2274':'nlsim','\u2273':'gsim','\u2275':'ngsim','\u2276':'lg','\u2278':'ntlg','\u2277':'gl','\u2279':'ntgl','\u227A':'pr','\u2280':'npr','\u227B':'sc','\u2281':'nsc','\u227C':'prcue','\u22E0':'nprcue','\u227D':'sccue','\u22E1':'nsccue','\u227E':'prsim','\u227F':'scsim','\u227F\u0338':'NotSucceedsTilde','\u2282':'sub','\u2284':'nsub','\u2282\u20D2':'vnsub','\u2283':'sup','\u2285':'nsup','\u2283\u20D2':'vnsup','\u2286':'sube','\u2288':'nsube','\u2287':'supe','\u2289':'nsupe','\u228A\uFE00':'vsubne','\u228A':'subne','\u228B\uFE00':'vsupne','\u228B':'supne','\u228D':'cupdot','\u228E':'uplus','\u228F':'sqsub','\u228F\u0338':'NotSquareSubset','\u2290':'sqsup','\u2290\u0338':'NotSquareSuperset','\u2291':'sqsube','\u22E2':'nsqsube','\u2292':'sqsupe','\u22E3':'nsqsupe','\u2293':'sqcap','\u2293\uFE00':'sqcaps','\u2294':'sqcup','\u2294\uFE00':'sqcups','\u2295':'oplus','\u2296':'ominus','\u2297':'otimes','\u2298':'osol','\u2299':'odot','\u229A':'ocir','\u229B':'oast','\u229D':'odash','\u229E':'plusb','\u229F':'minusb','\u22A0':'timesb','\u22A1':'sdotb','\u22A2':'vdash','\u22AC':'nvdash','\u22A3':'dashv','\u22A4':'top','\u22A5':'bot','\u22A7':'models','\u22A8':'vDash','\u22AD':'nvDash','\u22A9':'Vdash','\u22AE':'nVdash','\u22AA':'Vvdash','\u22AB':'VDash','\u22AF':'nVDash','\u22B0':'prurel','\u22B2':'vltri','\u22EA':'nltri','\u22B3':'vrtri','\u22EB':'nrtri','\u22B4':'ltrie','\u22EC':'nltrie','\u22B4\u20D2':'nvltrie','\u22B5':'rtrie','\u22ED':'nrtrie','\u22B5\u20D2':'nvrtrie','\u22B6':'origof','\u22B7':'imof','\u22B8':'mumap','\u22B9':'hercon','\u22BA':'intcal','\u22BB':'veebar','\u22BD':'barvee','\u22BE':'angrtvb','\u22BF':'lrtri','\u22C0':'Wedge','\u22C1':'Vee','\u22C2':'xcap','\u22C3':'xcup','\u22C4':'diam','\u22C5':'sdot','\u22C6':'Star','\u22C7':'divonx','\u22C8':'bowtie','\u22C9':'ltimes','\u22CA':'rtimes','\u22CB':'lthree','\u22CC':'rthree','\u22CD':'bsime','\u22CE':'cuvee','\u22CF':'cuwed','\u22D0':'Sub','\u22D1':'Sup','\u22D2':'Cap','\u22D3':'Cup','\u22D4':'fork','\u22D5':'epar','\u22D6':'ltdot','\u22D7':'gtdot','\u22D8':'Ll','\u22D8\u0338':'nLl','\u22D9':'Gg','\u22D9\u0338':'nGg','\u22DA\uFE00':'lesg','\u22DA':'leg','\u22DB':'gel','\u22DB\uFE00':'gesl','\u22DE':'cuepr','\u22DF':'cuesc','\u22E6':'lnsim','\u22E7':'gnsim','\u22E8':'prnsim','\u22E9':'scnsim','\u22EE':'vellip','\u22EF':'ctdot','\u22F0':'utdot','\u22F1':'dtdot','\u22F2':'disin','\u22F3':'isinsv','\u22F4':'isins','\u22F5':'isindot','\u22F5\u0338':'notindot','\u22F6':'notinvc','\u22F7':'notinvb','\u22F9':'isinE','\u22F9\u0338':'notinE','\u22FA':'nisd','\u22FB':'xnis','\u22FC':'nis','\u22FD':'notnivc','\u22FE':'notnivb','\u2305':'barwed','\u2306':'Barwed','\u230C':'drcrop','\u230D':'dlcrop','\u230E':'urcrop','\u230F':'ulcrop','\u2310':'bnot','\u2312':'profline','\u2313':'profsurf','\u2315':'telrec','\u2316':'target','\u231C':'ulcorn','\u231D':'urcorn','\u231E':'dlcorn','\u231F':'drcorn','\u2322':'frown','\u2323':'smile','\u232D':'cylcty','\u232E':'profalar','\u2336':'topbot','\u233D':'ovbar','\u233F':'solbar','\u237C':'angzarr','\u23B0':'lmoust','\u23B1':'rmoust','\u23B4':'tbrk','\u23B5':'bbrk','\u23B6':'bbrktbrk','\u23DC':'OverParenthesis','\u23DD':'UnderParenthesis','\u23DE':'OverBrace','\u23DF':'UnderBrace','\u23E2':'trpezium','\u23E7':'elinters','\u2423':'blank','\u2500':'boxh','\u2502':'boxv','\u250C':'boxdr','\u2510':'boxdl','\u2514':'boxur','\u2518':'boxul','\u251C':'boxvr','\u2524':'boxvl','\u252C':'boxhd','\u2534':'boxhu','\u253C':'boxvh','\u2550':'boxH','\u2551':'boxV','\u2552':'boxdR','\u2553':'boxDr','\u2554':'boxDR','\u2555':'boxdL','\u2556':'boxDl','\u2557':'boxDL','\u2558':'boxuR','\u2559':'boxUr','\u255A':'boxUR','\u255B':'boxuL','\u255C':'boxUl','\u255D':'boxUL','\u255E':'boxvR','\u255F':'boxVr','\u2560':'boxVR','\u2561':'boxvL','\u2562':'boxVl','\u2563':'boxVL','\u2564':'boxHd','\u2565':'boxhD','\u2566':'boxHD','\u2567':'boxHu','\u2568':'boxhU','\u2569':'boxHU','\u256A':'boxvH','\u256B':'boxVh','\u256C':'boxVH','\u2580':'uhblk','\u2584':'lhblk','\u2588':'block','\u2591':'blk14','\u2592':'blk12','\u2593':'blk34','\u25A1':'squ','\u25AA':'squf','\u25AB':'EmptyVerySmallSquare','\u25AD':'rect','\u25AE':'marker','\u25B1':'fltns','\u25B3':'xutri','\u25B4':'utrif','\u25B5':'utri','\u25B8':'rtrif','\u25B9':'rtri','\u25BD':'xdtri','\u25BE':'dtrif','\u25BF':'dtri','\u25C2':'ltrif','\u25C3':'ltri','\u25CA':'loz','\u25CB':'cir','\u25EC':'tridot','\u25EF':'xcirc','\u25F8':'ultri','\u25F9':'urtri','\u25FA':'lltri','\u25FB':'EmptySmallSquare','\u25FC':'FilledSmallSquare','\u2605':'starf','\u2606':'star','\u260E':'phone','\u2640':'female','\u2642':'male','\u2660':'spades','\u2663':'clubs','\u2665':'hearts','\u2666':'diams','\u266A':'sung','\u2713':'check','\u2717':'cross','\u2720':'malt','\u2736':'sext','\u2758':'VerticalSeparator','\u27C8':'bsolhsub','\u27C9':'suphsol','\u27F5':'xlarr','\u27F6':'xrarr','\u27F7':'xharr','\u27F8':'xlArr','\u27F9':'xrArr','\u27FA':'xhArr','\u27FC':'xmap','\u27FF':'dzigrarr','\u2902':'nvlArr','\u2903':'nvrArr','\u2904':'nvHarr','\u2905':'Map','\u290C':'lbarr','\u290D':'rbarr','\u290E':'lBarr','\u290F':'rBarr','\u2910':'RBarr','\u2911':'DDotrahd','\u2912':'UpArrowBar','\u2913':'DownArrowBar','\u2916':'Rarrtl','\u2919':'latail','\u291A':'ratail','\u291B':'lAtail','\u291C':'rAtail','\u291D':'larrfs','\u291E':'rarrfs','\u291F':'larrbfs','\u2920':'rarrbfs','\u2923':'nwarhk','\u2924':'nearhk','\u2925':'searhk','\u2926':'swarhk','\u2927':'nwnear','\u2928':'toea','\u2929':'tosa','\u292A':'swnwar','\u2933':'rarrc','\u2933\u0338':'nrarrc','\u2935':'cudarrr','\u2936':'ldca','\u2937':'rdca','\u2938':'cudarrl','\u2939':'larrpl','\u293C':'curarrm','\u293D':'cularrp','\u2945':'rarrpl','\u2948':'harrcir','\u2949':'Uarrocir','\u294A':'lurdshar','\u294B':'ldrushar','\u294E':'LeftRightVector','\u294F':'RightUpDownVector','\u2950':'DownLeftRightVector','\u2951':'LeftUpDownVector','\u2952':'LeftVectorBar','\u2953':'RightVectorBar','\u2954':'RightUpVectorBar','\u2955':'RightDownVectorBar','\u2956':'DownLeftVectorBar','\u2957':'DownRightVectorBar','\u2958':'LeftUpVectorBar','\u2959':'LeftDownVectorBar','\u295A':'LeftTeeVector','\u295B':'RightTeeVector','\u295C':'RightUpTeeVector','\u295D':'RightDownTeeVector','\u295E':'DownLeftTeeVector','\u295F':'DownRightTeeVector','\u2960':'LeftUpTeeVector','\u2961':'LeftDownTeeVector','\u2962':'lHar','\u2963':'uHar','\u2964':'rHar','\u2965':'dHar','\u2966':'luruhar','\u2967':'ldrdhar','\u2968':'ruluhar','\u2969':'rdldhar','\u296A':'lharul','\u296B':'llhard','\u296C':'rharul','\u296D':'lrhard','\u296E':'udhar','\u296F':'duhar','\u2970':'RoundImplies','\u2971':'erarr','\u2972':'simrarr','\u2973':'larrsim','\u2974':'rarrsim','\u2975':'rarrap','\u2976':'ltlarr','\u2978':'gtrarr','\u2979':'subrarr','\u297B':'suplarr','\u297C':'lfisht','\u297D':'rfisht','\u297E':'ufisht','\u297F':'dfisht','\u299A':'vzigzag','\u299C':'vangrt','\u299D':'angrtvbd','\u29A4':'ange','\u29A5':'range','\u29A6':'dwangle','\u29A7':'uwangle','\u29A8':'angmsdaa','\u29A9':'angmsdab','\u29AA':'angmsdac','\u29AB':'angmsdad','\u29AC':'angmsdae','\u29AD':'angmsdaf','\u29AE':'angmsdag','\u29AF':'angmsdah','\u29B0':'bemptyv','\u29B1':'demptyv','\u29B2':'cemptyv','\u29B3':'raemptyv','\u29B4':'laemptyv','\u29B5':'ohbar','\u29B6':'omid','\u29B7':'opar','\u29B9':'operp','\u29BB':'olcross','\u29BC':'odsold','\u29BE':'olcir','\u29BF':'ofcir','\u29C0':'olt','\u29C1':'ogt','\u29C2':'cirscir','\u29C3':'cirE','\u29C4':'solb','\u29C5':'bsolb','\u29C9':'boxbox','\u29CD':'trisb','\u29CE':'rtriltri','\u29CF':'LeftTriangleBar','\u29CF\u0338':'NotLeftTriangleBar','\u29D0':'RightTriangleBar','\u29D0\u0338':'NotRightTriangleBar','\u29DC':'iinfin','\u29DD':'infintie','\u29DE':'nvinfin','\u29E3':'eparsl','\u29E4':'smeparsl','\u29E5':'eqvparsl','\u29EB':'lozf','\u29F4':'RuleDelayed','\u29F6':'dsol','\u2A00':'xodot','\u2A01':'xoplus','\u2A02':'xotime','\u2A04':'xuplus','\u2A06':'xsqcup','\u2A0D':'fpartint','\u2A10':'cirfnint','\u2A11':'awint','\u2A12':'rppolint','\u2A13':'scpolint','\u2A14':'npolint','\u2A15':'pointint','\u2A16':'quatint','\u2A17':'intlarhk','\u2A22':'pluscir','\u2A23':'plusacir','\u2A24':'simplus','\u2A25':'plusdu','\u2A26':'plussim','\u2A27':'plustwo','\u2A29':'mcomma','\u2A2A':'minusdu','\u2A2D':'loplus','\u2A2E':'roplus','\u2A2F':'Cross','\u2A30':'timesd','\u2A31':'timesbar','\u2A33':'smashp','\u2A34':'lotimes','\u2A35':'rotimes','\u2A36':'otimesas','\u2A37':'Otimes','\u2A38':'odiv','\u2A39':'triplus','\u2A3A':'triminus','\u2A3B':'tritime','\u2A3C':'iprod','\u2A3F':'amalg','\u2A40':'capdot','\u2A42':'ncup','\u2A43':'ncap','\u2A44':'capand','\u2A45':'cupor','\u2A46':'cupcap','\u2A47':'capcup','\u2A48':'cupbrcap','\u2A49':'capbrcup','\u2A4A':'cupcup','\u2A4B':'capcap','\u2A4C':'ccups','\u2A4D':'ccaps','\u2A50':'ccupssm','\u2A53':'And','\u2A54':'Or','\u2A55':'andand','\u2A56':'oror','\u2A57':'orslope','\u2A58':'andslope','\u2A5A':'andv','\u2A5B':'orv','\u2A5C':'andd','\u2A5D':'ord','\u2A5F':'wedbar','\u2A66':'sdote','\u2A6A':'simdot','\u2A6D':'congdot','\u2A6D\u0338':'ncongdot','\u2A6E':'easter','\u2A6F':'apacir','\u2A70':'apE','\u2A70\u0338':'napE','\u2A71':'eplus','\u2A72':'pluse','\u2A73':'Esim','\u2A77':'eDDot','\u2A78':'equivDD','\u2A79':'ltcir','\u2A7A':'gtcir','\u2A7B':'ltquest','\u2A7C':'gtquest','\u2A7D':'les','\u2A7D\u0338':'nles','\u2A7E':'ges','\u2A7E\u0338':'nges','\u2A7F':'lesdot','\u2A80':'gesdot','\u2A81':'lesdoto','\u2A82':'gesdoto','\u2A83':'lesdotor','\u2A84':'gesdotol','\u2A85':'lap','\u2A86':'gap','\u2A87':'lne','\u2A88':'gne','\u2A89':'lnap','\u2A8A':'gnap','\u2A8B':'lEg','\u2A8C':'gEl','\u2A8D':'lsime','\u2A8E':'gsime','\u2A8F':'lsimg','\u2A90':'gsiml','\u2A91':'lgE','\u2A92':'glE','\u2A93':'lesges','\u2A94':'gesles','\u2A95':'els','\u2A96':'egs','\u2A97':'elsdot','\u2A98':'egsdot','\u2A99':'el','\u2A9A':'eg','\u2A9D':'siml','\u2A9E':'simg','\u2A9F':'simlE','\u2AA0':'simgE','\u2AA1':'LessLess','\u2AA1\u0338':'NotNestedLessLess','\u2AA2':'GreaterGreater','\u2AA2\u0338':'NotNestedGreaterGreater','\u2AA4':'glj','\u2AA5':'gla','\u2AA6':'ltcc','\u2AA7':'gtcc','\u2AA8':'lescc','\u2AA9':'gescc','\u2AAA':'smt','\u2AAB':'lat','\u2AAC':'smte','\u2AAC\uFE00':'smtes','\u2AAD':'late','\u2AAD\uFE00':'lates','\u2AAE':'bumpE','\u2AAF':'pre','\u2AAF\u0338':'npre','\u2AB0':'sce','\u2AB0\u0338':'nsce','\u2AB3':'prE','\u2AB4':'scE','\u2AB5':'prnE','\u2AB6':'scnE','\u2AB7':'prap','\u2AB8':'scap','\u2AB9':'prnap','\u2ABA':'scnap','\u2ABB':'Pr','\u2ABC':'Sc','\u2ABD':'subdot','\u2ABE':'supdot','\u2ABF':'subplus','\u2AC0':'supplus','\u2AC1':'submult','\u2AC2':'supmult','\u2AC3':'subedot','\u2AC4':'supedot','\u2AC5':'subE','\u2AC5\u0338':'nsubE','\u2AC6':'supE','\u2AC6\u0338':'nsupE','\u2AC7':'subsim','\u2AC8':'supsim','\u2ACB\uFE00':'vsubnE','\u2ACB':'subnE','\u2ACC\uFE00':'vsupnE','\u2ACC':'supnE','\u2ACF':'csub','\u2AD0':'csup','\u2AD1':'csube','\u2AD2':'csupe','\u2AD3':'subsup','\u2AD4':'supsub','\u2AD5':'subsub','\u2AD6':'supsup','\u2AD7':'suphsub','\u2AD8':'supdsub','\u2AD9':'forkv','\u2ADA':'topfork','\u2ADB':'mlcp','\u2AE4':'Dashv','\u2AE6':'Vdashl','\u2AE7':'Barv','\u2AE8':'vBar','\u2AE9':'vBarv','\u2AEB':'Vbar','\u2AEC':'Not','\u2AED':'bNot','\u2AEE':'rnmid','\u2AEF':'cirmid','\u2AF0':'midcir','\u2AF1':'topcir','\u2AF2':'nhpar','\u2AF3':'parsim','\u2AFD':'parsl','\u2AFD\u20E5':'nparsl','\u266D':'flat','\u266E':'natur','\u266F':'sharp','\xA4':'curren','\xA2':'cent','$':'dollar','\xA3':'pound','\xA5':'yen','\u20AC':'euro','\xB9':'sup1','\xBD':'half','\u2153':'frac13','\xBC':'frac14','\u2155':'frac15','\u2159':'frac16','\u215B':'frac18','\xB2':'sup2','\u2154':'frac23','\u2156':'frac25','\xB3':'sup3','\xBE':'frac34','\u2157':'frac35','\u215C':'frac38','\u2158':'frac45','\u215A':'frac56','\u215D':'frac58','\u215E':'frac78','\uD835\uDCB6':'ascr','\uD835\uDD52':'aopf','\uD835\uDD1E':'afr','\uD835\uDD38':'Aopf','\uD835\uDD04':'Afr','\uD835\uDC9C':'Ascr','\xAA':'ordf','\xE1':'aacute','\xC1':'Aacute','\xE0':'agrave','\xC0':'Agrave','\u0103':'abreve','\u0102':'Abreve','\xE2':'acirc','\xC2':'Acirc','\xE5':'aring','\xC5':'angst','\xE4':'auml','\xC4':'Auml','\xE3':'atilde','\xC3':'Atilde','\u0105':'aogon','\u0104':'Aogon','\u0101':'amacr','\u0100':'Amacr','\xE6':'aelig','\xC6':'AElig','\uD835\uDCB7':'bscr','\uD835\uDD53':'bopf','\uD835\uDD1F':'bfr','\uD835\uDD39':'Bopf','\u212C':'Bscr','\uD835\uDD05':'Bfr','\uD835\uDD20':'cfr','\uD835\uDCB8':'cscr','\uD835\uDD54':'copf','\u212D':'Cfr','\uD835\uDC9E':'Cscr','\u2102':'Copf','\u0107':'cacute','\u0106':'Cacute','\u0109':'ccirc','\u0108':'Ccirc','\u010D':'ccaron','\u010C':'Ccaron','\u010B':'cdot','\u010A':'Cdot','\xE7':'ccedil','\xC7':'Ccedil','\u2105':'incare','\uD835\uDD21':'dfr','\u2146':'dd','\uD835\uDD55':'dopf','\uD835\uDCB9':'dscr','\uD835\uDC9F':'Dscr','\uD835\uDD07':'Dfr','\u2145':'DD','\uD835\uDD3B':'Dopf','\u010F':'dcaron','\u010E':'Dcaron','\u0111':'dstrok','\u0110':'Dstrok','\xF0':'eth','\xD0':'ETH','\u2147':'ee','\u212F':'escr','\uD835\uDD22':'efr','\uD835\uDD56':'eopf','\u2130':'Escr','\uD835\uDD08':'Efr','\uD835\uDD3C':'Eopf','\xE9':'eacute','\xC9':'Eacute','\xE8':'egrave','\xC8':'Egrave','\xEA':'ecirc','\xCA':'Ecirc','\u011B':'ecaron','\u011A':'Ecaron','\xEB':'euml','\xCB':'Euml','\u0117':'edot','\u0116':'Edot','\u0119':'eogon','\u0118':'Eogon','\u0113':'emacr','\u0112':'Emacr','\uD835\uDD23':'ffr','\uD835\uDD57':'fopf','\uD835\uDCBB':'fscr','\uD835\uDD09':'Ffr','\uD835\uDD3D':'Fopf','\u2131':'Fscr','\uFB00':'fflig','\uFB03':'ffilig','\uFB04':'ffllig','\uFB01':'filig','fj':'fjlig','\uFB02':'fllig','\u0192':'fnof','\u210A':'gscr','\uD835\uDD58':'gopf','\uD835\uDD24':'gfr','\uD835\uDCA2':'Gscr','\uD835\uDD3E':'Gopf','\uD835\uDD0A':'Gfr','\u01F5':'gacute','\u011F':'gbreve','\u011E':'Gbreve','\u011D':'gcirc','\u011C':'Gcirc','\u0121':'gdot','\u0120':'Gdot','\u0122':'Gcedil','\uD835\uDD25':'hfr','\u210E':'planckh','\uD835\uDCBD':'hscr','\uD835\uDD59':'hopf','\u210B':'Hscr','\u210C':'Hfr','\u210D':'Hopf','\u0125':'hcirc','\u0124':'Hcirc','\u210F':'hbar','\u0127':'hstrok','\u0126':'Hstrok','\uD835\uDD5A':'iopf','\uD835\uDD26':'ifr','\uD835\uDCBE':'iscr','\u2148':'ii','\uD835\uDD40':'Iopf','\u2110':'Iscr','\u2111':'Im','\xED':'iacute','\xCD':'Iacute','\xEC':'igrave','\xCC':'Igrave','\xEE':'icirc','\xCE':'Icirc','\xEF':'iuml','\xCF':'Iuml','\u0129':'itilde','\u0128':'Itilde','\u0130':'Idot','\u012F':'iogon','\u012E':'Iogon','\u012B':'imacr','\u012A':'Imacr','\u0133':'ijlig','\u0132':'IJlig','\u0131':'imath','\uD835\uDCBF':'jscr','\uD835\uDD5B':'jopf','\uD835\uDD27':'jfr','\uD835\uDCA5':'Jscr','\uD835\uDD0D':'Jfr','\uD835\uDD41':'Jopf','\u0135':'jcirc','\u0134':'Jcirc','\u0237':'jmath','\uD835\uDD5C':'kopf','\uD835\uDCC0':'kscr','\uD835\uDD28':'kfr','\uD835\uDCA6':'Kscr','\uD835\uDD42':'Kopf','\uD835\uDD0E':'Kfr','\u0137':'kcedil','\u0136':'Kcedil','\uD835\uDD29':'lfr','\uD835\uDCC1':'lscr','\u2113':'ell','\uD835\uDD5D':'lopf','\u2112':'Lscr','\uD835\uDD0F':'Lfr','\uD835\uDD43':'Lopf','\u013A':'lacute','\u0139':'Lacute','\u013E':'lcaron','\u013D':'Lcaron','\u013C':'lcedil','\u013B':'Lcedil','\u0142':'lstrok','\u0141':'Lstrok','\u0140':'lmidot','\u013F':'Lmidot','\uD835\uDD2A':'mfr','\uD835\uDD5E':'mopf','\uD835\uDCC2':'mscr','\uD835\uDD10':'Mfr','\uD835\uDD44':'Mopf','\u2133':'Mscr','\uD835\uDD2B':'nfr','\uD835\uDD5F':'nopf','\uD835\uDCC3':'nscr','\u2115':'Nopf','\uD835\uDCA9':'Nscr','\uD835\uDD11':'Nfr','\u0144':'nacute','\u0143':'Nacute','\u0148':'ncaron','\u0147':'Ncaron','\xF1':'ntilde','\xD1':'Ntilde','\u0146':'ncedil','\u0145':'Ncedil','\u2116':'numero','\u014B':'eng','\u014A':'ENG','\uD835\uDD60':'oopf','\uD835\uDD2C':'ofr','\u2134':'oscr','\uD835\uDCAA':'Oscr','\uD835\uDD12':'Ofr','\uD835\uDD46':'Oopf','\xBA':'ordm','\xF3':'oacute','\xD3':'Oacute','\xF2':'ograve','\xD2':'Ograve','\xF4':'ocirc','\xD4':'Ocirc','\xF6':'ouml','\xD6':'Ouml','\u0151':'odblac','\u0150':'Odblac','\xF5':'otilde','\xD5':'Otilde','\xF8':'oslash','\xD8':'Oslash','\u014D':'omacr','\u014C':'Omacr','\u0153':'oelig','\u0152':'OElig','\uD835\uDD2D':'pfr','\uD835\uDCC5':'pscr','\uD835\uDD61':'popf','\u2119':'Popf','\uD835\uDD13':'Pfr','\uD835\uDCAB':'Pscr','\uD835\uDD62':'qopf','\uD835\uDD2E':'qfr','\uD835\uDCC6':'qscr','\uD835\uDCAC':'Qscr','\uD835\uDD14':'Qfr','\u211A':'Qopf','\u0138':'kgreen','\uD835\uDD2F':'rfr','\uD835\uDD63':'ropf','\uD835\uDCC7':'rscr','\u211B':'Rscr','\u211C':'Re','\u211D':'Ropf','\u0155':'racute','\u0154':'Racute','\u0159':'rcaron','\u0158':'Rcaron','\u0157':'rcedil','\u0156':'Rcedil','\uD835\uDD64':'sopf','\uD835\uDCC8':'sscr','\uD835\uDD30':'sfr','\uD835\uDD4A':'Sopf','\uD835\uDD16':'Sfr','\uD835\uDCAE':'Sscr','\u24C8':'oS','\u015B':'sacute','\u015A':'Sacute','\u015D':'scirc','\u015C':'Scirc','\u0161':'scaron','\u0160':'Scaron','\u015F':'scedil','\u015E':'Scedil','\xDF':'szlig','\uD835\uDD31':'tfr','\uD835\uDCC9':'tscr','\uD835\uDD65':'topf','\uD835\uDCAF':'Tscr','\uD835\uDD17':'Tfr','\uD835\uDD4B':'Topf','\u0165':'tcaron','\u0164':'Tcaron','\u0163':'tcedil','\u0162':'Tcedil','\u2122':'trade','\u0167':'tstrok','\u0166':'Tstrok','\uD835\uDCCA':'uscr','\uD835\uDD66':'uopf','\uD835\uDD32':'ufr','\uD835\uDD4C':'Uopf','\uD835\uDD18':'Ufr','\uD835\uDCB0':'Uscr','\xFA':'uacute','\xDA':'Uacute','\xF9':'ugrave','\xD9':'Ugrave','\u016D':'ubreve','\u016C':'Ubreve','\xFB':'ucirc','\xDB':'Ucirc','\u016F':'uring','\u016E':'Uring','\xFC':'uuml','\xDC':'Uuml','\u0171':'udblac','\u0170':'Udblac','\u0169':'utilde','\u0168':'Utilde','\u0173':'uogon','\u0172':'Uogon','\u016B':'umacr','\u016A':'Umacr','\uD835\uDD33':'vfr','\uD835\uDD67':'vopf','\uD835\uDCCB':'vscr','\uD835\uDD19':'Vfr','\uD835\uDD4D':'Vopf','\uD835\uDCB1':'Vscr','\uD835\uDD68':'wopf','\uD835\uDCCC':'wscr','\uD835\uDD34':'wfr','\uD835\uDCB2':'Wscr','\uD835\uDD4E':'Wopf','\uD835\uDD1A':'Wfr','\u0175':'wcirc','\u0174':'Wcirc','\uD835\uDD35':'xfr','\uD835\uDCCD':'xscr','\uD835\uDD69':'xopf','\uD835\uDD4F':'Xopf','\uD835\uDD1B':'Xfr','\uD835\uDCB3':'Xscr','\uD835\uDD36':'yfr','\uD835\uDCCE':'yscr','\uD835\uDD6A':'yopf','\uD835\uDCB4':'Yscr','\uD835\uDD1C':'Yfr','\uD835\uDD50':'Yopf','\xFD':'yacute','\xDD':'Yacute','\u0177':'ycirc','\u0176':'Ycirc','\xFF':'yuml','\u0178':'Yuml','\uD835\uDCCF':'zscr','\uD835\uDD37':'zfr','\uD835\uDD6B':'zopf','\u2128':'Zfr','\u2124':'Zopf','\uD835\uDCB5':'Zscr','\u017A':'zacute','\u0179':'Zacute','\u017E':'zcaron','\u017D':'Zcaron','\u017C':'zdot','\u017B':'Zdot','\u01B5':'imped','\xFE':'thorn','\xDE':'THORN','\u0149':'napos','\u03B1':'alpha','\u0391':'Alpha','\u03B2':'beta','\u0392':'Beta','\u03B3':'gamma','\u0393':'Gamma','\u03B4':'delta','\u0394':'Delta','\u03B5':'epsi','\u03F5':'epsiv','\u0395':'Epsilon','\u03DD':'gammad','\u03DC':'Gammad','\u03B6':'zeta','\u0396':'Zeta','\u03B7':'eta','\u0397':'Eta','\u03B8':'theta','\u03D1':'thetav','\u0398':'Theta','\u03B9':'iota','\u0399':'Iota','\u03BA':'kappa','\u03F0':'kappav','\u039A':'Kappa','\u03BB':'lambda','\u039B':'Lambda','\u03BC':'mu','\xB5':'micro','\u039C':'Mu','\u03BD':'nu','\u039D':'Nu','\u03BE':'xi','\u039E':'Xi','\u03BF':'omicron','\u039F':'Omicron','\u03C0':'pi','\u03D6':'piv','\u03A0':'Pi','\u03C1':'rho','\u03F1':'rhov','\u03A1':'Rho','\u03C3':'sigma','\u03A3':'Sigma','\u03C2':'sigmaf','\u03C4':'tau','\u03A4':'Tau','\u03C5':'upsi','\u03A5':'Upsilon','\u03D2':'Upsi','\u03C6':'phi','\u03D5':'phiv','\u03A6':'Phi','\u03C7':'chi','\u03A7':'Chi','\u03C8':'psi','\u03A8':'Psi','\u03C9':'omega','\u03A9':'ohm','\u0430':'acy','\u0410':'Acy','\u0431':'bcy','\u0411':'Bcy','\u0432':'vcy','\u0412':'Vcy','\u0433':'gcy','\u0413':'Gcy','\u0453':'gjcy','\u0403':'GJcy','\u0434':'dcy','\u0414':'Dcy','\u0452':'djcy','\u0402':'DJcy','\u0435':'iecy','\u0415':'IEcy','\u0451':'iocy','\u0401':'IOcy','\u0454':'jukcy','\u0404':'Jukcy','\u0436':'zhcy','\u0416':'ZHcy','\u0437':'zcy','\u0417':'Zcy','\u0455':'dscy','\u0405':'DScy','\u0438':'icy','\u0418':'Icy','\u0456':'iukcy','\u0406':'Iukcy','\u0457':'yicy','\u0407':'YIcy','\u0439':'jcy','\u0419':'Jcy','\u0458':'jsercy','\u0408':'Jsercy','\u043A':'kcy','\u041A':'Kcy','\u045C':'kjcy','\u040C':'KJcy','\u043B':'lcy','\u041B':'Lcy','\u0459':'ljcy','\u0409':'LJcy','\u043C':'mcy','\u041C':'Mcy','\u043D':'ncy','\u041D':'Ncy','\u045A':'njcy','\u040A':'NJcy','\u043E':'ocy','\u041E':'Ocy','\u043F':'pcy','\u041F':'Pcy','\u0440':'rcy','\u0420':'Rcy','\u0441':'scy','\u0421':'Scy','\u0442':'tcy','\u0422':'Tcy','\u045B':'tshcy','\u040B':'TSHcy','\u0443':'ucy','\u0423':'Ucy','\u045E':'ubrcy','\u040E':'Ubrcy','\u0444':'fcy','\u0424':'Fcy','\u0445':'khcy','\u0425':'KHcy','\u0446':'tscy','\u0426':'TScy','\u0447':'chcy','\u0427':'CHcy','\u045F':'dzcy','\u040F':'DZcy','\u0448':'shcy','\u0428':'SHcy','\u0449':'shchcy','\u0429':'SHCHcy','\u044A':'hardcy','\u042A':'HARDcy','\u044B':'ycy','\u042B':'Ycy','\u044C':'softcy','\u042C':'SOFTcy','\u044D':'ecy','\u042D':'Ecy','\u044E':'yucy','\u042E':'YUcy','\u044F':'yacy','\u042F':'YAcy','\u2135':'aleph','\u2136':'beth','\u2137':'gimel','\u2138':'daleth'};

	var regexEscape = /["&'<>`]/g;
	var escapeMap = {
		'"': '&quot;',
		'&': '&amp;',
		'\'': '&#x27;',
		'<': '&lt;',
		// See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
		// following is not strictly necessary unless its part of a tag or an
		// unquoted attribute value. Were only escaping it to support those
		// situations, and for XML support.
		'>': '&gt;',
		// In Internet Explorer  8, the backtick character can be used
		// to break out of (un)quoted attribute values or HTML comments.
		// See http://html5sec.org/#102, http://html5sec.org/#108, and
		// http://html5sec.org/#133.
		'`': '&#x60;'
	};

	var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
	var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
	var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
	var decodeMap = {'aacute':'\xE1','Aacute':'\xC1','abreve':'\u0103','Abreve':'\u0102','ac':'\u223E','acd':'\u223F','acE':'\u223E\u0333','acirc':'\xE2','Acirc':'\xC2','acute':'\xB4','acy':'\u0430','Acy':'\u0410','aelig':'\xE6','AElig':'\xC6','af':'\u2061','afr':'\uD835\uDD1E','Afr':'\uD835\uDD04','agrave':'\xE0','Agrave':'\xC0','alefsym':'\u2135','aleph':'\u2135','alpha':'\u03B1','Alpha':'\u0391','amacr':'\u0101','Amacr':'\u0100','amalg':'\u2A3F','amp':'&','AMP':'&','and':'\u2227','And':'\u2A53','andand':'\u2A55','andd':'\u2A5C','andslope':'\u2A58','andv':'\u2A5A','ang':'\u2220','ange':'\u29A4','angle':'\u2220','angmsd':'\u2221','angmsdaa':'\u29A8','angmsdab':'\u29A9','angmsdac':'\u29AA','angmsdad':'\u29AB','angmsdae':'\u29AC','angmsdaf':'\u29AD','angmsdag':'\u29AE','angmsdah':'\u29AF','angrt':'\u221F','angrtvb':'\u22BE','angrtvbd':'\u299D','angsph':'\u2222','angst':'\xC5','angzarr':'\u237C','aogon':'\u0105','Aogon':'\u0104','aopf':'\uD835\uDD52','Aopf':'\uD835\uDD38','ap':'\u2248','apacir':'\u2A6F','ape':'\u224A','apE':'\u2A70','apid':'\u224B','apos':'\'','ApplyFunction':'\u2061','approx':'\u2248','approxeq':'\u224A','aring':'\xE5','Aring':'\xC5','ascr':'\uD835\uDCB6','Ascr':'\uD835\uDC9C','Assign':'\u2254','ast':'*','asymp':'\u2248','asympeq':'\u224D','atilde':'\xE3','Atilde':'\xC3','auml':'\xE4','Auml':'\xC4','awconint':'\u2233','awint':'\u2A11','backcong':'\u224C','backepsilon':'\u03F6','backprime':'\u2035','backsim':'\u223D','backsimeq':'\u22CD','Backslash':'\u2216','Barv':'\u2AE7','barvee':'\u22BD','barwed':'\u2305','Barwed':'\u2306','barwedge':'\u2305','bbrk':'\u23B5','bbrktbrk':'\u23B6','bcong':'\u224C','bcy':'\u0431','Bcy':'\u0411','bdquo':'\u201E','becaus':'\u2235','because':'\u2235','Because':'\u2235','bemptyv':'\u29B0','bepsi':'\u03F6','bernou':'\u212C','Bernoullis':'\u212C','beta':'\u03B2','Beta':'\u0392','beth':'\u2136','between':'\u226C','bfr':'\uD835\uDD1F','Bfr':'\uD835\uDD05','bigcap':'\u22C2','bigcirc':'\u25EF','bigcup':'\u22C3','bigodot':'\u2A00','bigoplus':'\u2A01','bigotimes':'\u2A02','bigsqcup':'\u2A06','bigstar':'\u2605','bigtriangledown':'\u25BD','bigtriangleup':'\u25B3','biguplus':'\u2A04','bigvee':'\u22C1','bigwedge':'\u22C0','bkarow':'\u290D','blacklozenge':'\u29EB','blacksquare':'\u25AA','blacktriangle':'\u25B4','blacktriangledown':'\u25BE','blacktriangleleft':'\u25C2','blacktriangleright':'\u25B8','blank':'\u2423','blk12':'\u2592','blk14':'\u2591','blk34':'\u2593','block':'\u2588','bne':'=\u20E5','bnequiv':'\u2261\u20E5','bnot':'\u2310','bNot':'\u2AED','bopf':'\uD835\uDD53','Bopf':'\uD835\uDD39','bot':'\u22A5','bottom':'\u22A5','bowtie':'\u22C8','boxbox':'\u29C9','boxdl':'\u2510','boxdL':'\u2555','boxDl':'\u2556','boxDL':'\u2557','boxdr':'\u250C','boxdR':'\u2552','boxDr':'\u2553','boxDR':'\u2554','boxh':'\u2500','boxH':'\u2550','boxhd':'\u252C','boxhD':'\u2565','boxHd':'\u2564','boxHD':'\u2566','boxhu':'\u2534','boxhU':'\u2568','boxHu':'\u2567','boxHU':'\u2569','boxminus':'\u229F','boxplus':'\u229E','boxtimes':'\u22A0','boxul':'\u2518','boxuL':'\u255B','boxUl':'\u255C','boxUL':'\u255D','boxur':'\u2514','boxuR':'\u2558','boxUr':'\u2559','boxUR':'\u255A','boxv':'\u2502','boxV':'\u2551','boxvh':'\u253C','boxvH':'\u256A','boxVh':'\u256B','boxVH':'\u256C','boxvl':'\u2524','boxvL':'\u2561','boxVl':'\u2562','boxVL':'\u2563','boxvr':'\u251C','boxvR':'\u255E','boxVr':'\u255F','boxVR':'\u2560','bprime':'\u2035','breve':'\u02D8','Breve':'\u02D8','brvbar':'\xA6','bscr':'\uD835\uDCB7','Bscr':'\u212C','bsemi':'\u204F','bsim':'\u223D','bsime':'\u22CD','bsol':'\\','bsolb':'\u29C5','bsolhsub':'\u27C8','bull':'\u2022','bullet':'\u2022','bump':'\u224E','bumpe':'\u224F','bumpE':'\u2AAE','bumpeq':'\u224F','Bumpeq':'\u224E','cacute':'\u0107','Cacute':'\u0106','cap':'\u2229','Cap':'\u22D2','capand':'\u2A44','capbrcup':'\u2A49','capcap':'\u2A4B','capcup':'\u2A47','capdot':'\u2A40','CapitalDifferentialD':'\u2145','caps':'\u2229\uFE00','caret':'\u2041','caron':'\u02C7','Cayleys':'\u212D','ccaps':'\u2A4D','ccaron':'\u010D','Ccaron':'\u010C','ccedil':'\xE7','Ccedil':'\xC7','ccirc':'\u0109','Ccirc':'\u0108','Cconint':'\u2230','ccups':'\u2A4C','ccupssm':'\u2A50','cdot':'\u010B','Cdot':'\u010A','cedil':'\xB8','Cedilla':'\xB8','cemptyv':'\u29B2','cent':'\xA2','centerdot':'\xB7','CenterDot':'\xB7','cfr':'\uD835\uDD20','Cfr':'\u212D','chcy':'\u0447','CHcy':'\u0427','check':'\u2713','checkmark':'\u2713','chi':'\u03C7','Chi':'\u03A7','cir':'\u25CB','circ':'\u02C6','circeq':'\u2257','circlearrowleft':'\u21BA','circlearrowright':'\u21BB','circledast':'\u229B','circledcirc':'\u229A','circleddash':'\u229D','CircleDot':'\u2299','circledR':'\xAE','circledS':'\u24C8','CircleMinus':'\u2296','CirclePlus':'\u2295','CircleTimes':'\u2297','cire':'\u2257','cirE':'\u29C3','cirfnint':'\u2A10','cirmid':'\u2AEF','cirscir':'\u29C2','ClockwiseContourIntegral':'\u2232','CloseCurlyDoubleQuote':'\u201D','CloseCurlyQuote':'\u2019','clubs':'\u2663','clubsuit':'\u2663','colon':':','Colon':'\u2237','colone':'\u2254','Colone':'\u2A74','coloneq':'\u2254','comma':',','commat':'@','comp':'\u2201','compfn':'\u2218','complement':'\u2201','complexes':'\u2102','cong':'\u2245','congdot':'\u2A6D','Congruent':'\u2261','conint':'\u222E','Conint':'\u222F','ContourIntegral':'\u222E','copf':'\uD835\uDD54','Copf':'\u2102','coprod':'\u2210','Coproduct':'\u2210','copy':'\xA9','COPY':'\xA9','copysr':'\u2117','CounterClockwiseContourIntegral':'\u2233','crarr':'\u21B5','cross':'\u2717','Cross':'\u2A2F','cscr':'\uD835\uDCB8','Cscr':'\uD835\uDC9E','csub':'\u2ACF','csube':'\u2AD1','csup':'\u2AD0','csupe':'\u2AD2','ctdot':'\u22EF','cudarrl':'\u2938','cudarrr':'\u2935','cuepr':'\u22DE','cuesc':'\u22DF','cularr':'\u21B6','cularrp':'\u293D','cup':'\u222A','Cup':'\u22D3','cupbrcap':'\u2A48','cupcap':'\u2A46','CupCap':'\u224D','cupcup':'\u2A4A','cupdot':'\u228D','cupor':'\u2A45','cups':'\u222A\uFE00','curarr':'\u21B7','curarrm':'\u293C','curlyeqprec':'\u22DE','curlyeqsucc':'\u22DF','curlyvee':'\u22CE','curlywedge':'\u22CF','curren':'\xA4','curvearrowleft':'\u21B6','curvearrowright':'\u21B7','cuvee':'\u22CE','cuwed':'\u22CF','cwconint':'\u2232','cwint':'\u2231','cylcty':'\u232D','dagger':'\u2020','Dagger':'\u2021','daleth':'\u2138','darr':'\u2193','dArr':'\u21D3','Darr':'\u21A1','dash':'\u2010','dashv':'\u22A3','Dashv':'\u2AE4','dbkarow':'\u290F','dblac':'\u02DD','dcaron':'\u010F','Dcaron':'\u010E','dcy':'\u0434','Dcy':'\u0414','dd':'\u2146','DD':'\u2145','ddagger':'\u2021','ddarr':'\u21CA','DDotrahd':'\u2911','ddotseq':'\u2A77','deg':'\xB0','Del':'\u2207','delta':'\u03B4','Delta':'\u0394','demptyv':'\u29B1','dfisht':'\u297F','dfr':'\uD835\uDD21','Dfr':'\uD835\uDD07','dHar':'\u2965','dharl':'\u21C3','dharr':'\u21C2','DiacriticalAcute':'\xB4','DiacriticalDot':'\u02D9','DiacriticalDoubleAcute':'\u02DD','DiacriticalGrave':'`','DiacriticalTilde':'\u02DC','diam':'\u22C4','diamond':'\u22C4','Diamond':'\u22C4','diamondsuit':'\u2666','diams':'\u2666','die':'\xA8','DifferentialD':'\u2146','digamma':'\u03DD','disin':'\u22F2','div':'\xF7','divide':'\xF7','divideontimes':'\u22C7','divonx':'\u22C7','djcy':'\u0452','DJcy':'\u0402','dlcorn':'\u231E','dlcrop':'\u230D','dollar':'$','dopf':'\uD835\uDD55','Dopf':'\uD835\uDD3B','dot':'\u02D9','Dot':'\xA8','DotDot':'\u20DC','doteq':'\u2250','doteqdot':'\u2251','DotEqual':'\u2250','dotminus':'\u2238','dotplus':'\u2214','dotsquare':'\u22A1','doublebarwedge':'\u2306','DoubleContourIntegral':'\u222F','DoubleDot':'\xA8','DoubleDownArrow':'\u21D3','DoubleLeftArrow':'\u21D0','DoubleLeftRightArrow':'\u21D4','DoubleLeftTee':'\u2AE4','DoubleLongLeftArrow':'\u27F8','DoubleLongLeftRightArrow':'\u27FA','DoubleLongRightArrow':'\u27F9','DoubleRightArrow':'\u21D2','DoubleRightTee':'\u22A8','DoubleUpArrow':'\u21D1','DoubleUpDownArrow':'\u21D5','DoubleVerticalBar':'\u2225','downarrow':'\u2193','Downarrow':'\u21D3','DownArrow':'\u2193','DownArrowBar':'\u2913','DownArrowUpArrow':'\u21F5','DownBreve':'\u0311','downdownarrows':'\u21CA','downharpoonleft':'\u21C3','downharpoonright':'\u21C2','DownLeftRightVector':'\u2950','DownLeftTeeVector':'\u295E','DownLeftVector':'\u21BD','DownLeftVectorBar':'\u2956','DownRightTeeVector':'\u295F','DownRightVector':'\u21C1','DownRightVectorBar':'\u2957','DownTee':'\u22A4','DownTeeArrow':'\u21A7','drbkarow':'\u2910','drcorn':'\u231F','drcrop':'\u230C','dscr':'\uD835\uDCB9','Dscr':'\uD835\uDC9F','dscy':'\u0455','DScy':'\u0405','dsol':'\u29F6','dstrok':'\u0111','Dstrok':'\u0110','dtdot':'\u22F1','dtri':'\u25BF','dtrif':'\u25BE','duarr':'\u21F5','duhar':'\u296F','dwangle':'\u29A6','dzcy':'\u045F','DZcy':'\u040F','dzigrarr':'\u27FF','eacute':'\xE9','Eacute':'\xC9','easter':'\u2A6E','ecaron':'\u011B','Ecaron':'\u011A','ecir':'\u2256','ecirc':'\xEA','Ecirc':'\xCA','ecolon':'\u2255','ecy':'\u044D','Ecy':'\u042D','eDDot':'\u2A77','edot':'\u0117','eDot':'\u2251','Edot':'\u0116','ee':'\u2147','efDot':'\u2252','efr':'\uD835\uDD22','Efr':'\uD835\uDD08','eg':'\u2A9A','egrave':'\xE8','Egrave':'\xC8','egs':'\u2A96','egsdot':'\u2A98','el':'\u2A99','Element':'\u2208','elinters':'\u23E7','ell':'\u2113','els':'\u2A95','elsdot':'\u2A97','emacr':'\u0113','Emacr':'\u0112','empty':'\u2205','emptyset':'\u2205','EmptySmallSquare':'\u25FB','emptyv':'\u2205','EmptyVerySmallSquare':'\u25AB','emsp':'\u2003','emsp13':'\u2004','emsp14':'\u2005','eng':'\u014B','ENG':'\u014A','ensp':'\u2002','eogon':'\u0119','Eogon':'\u0118','eopf':'\uD835\uDD56','Eopf':'\uD835\uDD3C','epar':'\u22D5','eparsl':'\u29E3','eplus':'\u2A71','epsi':'\u03B5','epsilon':'\u03B5','Epsilon':'\u0395','epsiv':'\u03F5','eqcirc':'\u2256','eqcolon':'\u2255','eqsim':'\u2242','eqslantgtr':'\u2A96','eqslantless':'\u2A95','Equal':'\u2A75','equals':'=','EqualTilde':'\u2242','equest':'\u225F','Equilibrium':'\u21CC','equiv':'\u2261','equivDD':'\u2A78','eqvparsl':'\u29E5','erarr':'\u2971','erDot':'\u2253','escr':'\u212F','Escr':'\u2130','esdot':'\u2250','esim':'\u2242','Esim':'\u2A73','eta':'\u03B7','Eta':'\u0397','eth':'\xF0','ETH':'\xD0','euml':'\xEB','Euml':'\xCB','euro':'\u20AC','excl':'!','exist':'\u2203','Exists':'\u2203','expectation':'\u2130','exponentiale':'\u2147','ExponentialE':'\u2147','fallingdotseq':'\u2252','fcy':'\u0444','Fcy':'\u0424','female':'\u2640','ffilig':'\uFB03','fflig':'\uFB00','ffllig':'\uFB04','ffr':'\uD835\uDD23','Ffr':'\uD835\uDD09','filig':'\uFB01','FilledSmallSquare':'\u25FC','FilledVerySmallSquare':'\u25AA','fjlig':'fj','flat':'\u266D','fllig':'\uFB02','fltns':'\u25B1','fnof':'\u0192','fopf':'\uD835\uDD57','Fopf':'\uD835\uDD3D','forall':'\u2200','ForAll':'\u2200','fork':'\u22D4','forkv':'\u2AD9','Fouriertrf':'\u2131','fpartint':'\u2A0D','frac12':'\xBD','frac13':'\u2153','frac14':'\xBC','frac15':'\u2155','frac16':'\u2159','frac18':'\u215B','frac23':'\u2154','frac25':'\u2156','frac34':'\xBE','frac35':'\u2157','frac38':'\u215C','frac45':'\u2158','frac56':'\u215A','frac58':'\u215D','frac78':'\u215E','frasl':'\u2044','frown':'\u2322','fscr':'\uD835\uDCBB','Fscr':'\u2131','gacute':'\u01F5','gamma':'\u03B3','Gamma':'\u0393','gammad':'\u03DD','Gammad':'\u03DC','gap':'\u2A86','gbreve':'\u011F','Gbreve':'\u011E','Gcedil':'\u0122','gcirc':'\u011D','Gcirc':'\u011C','gcy':'\u0433','Gcy':'\u0413','gdot':'\u0121','Gdot':'\u0120','ge':'\u2265','gE':'\u2267','gel':'\u22DB','gEl':'\u2A8C','geq':'\u2265','geqq':'\u2267','geqslant':'\u2A7E','ges':'\u2A7E','gescc':'\u2AA9','gesdot':'\u2A80','gesdoto':'\u2A82','gesdotol':'\u2A84','gesl':'\u22DB\uFE00','gesles':'\u2A94','gfr':'\uD835\uDD24','Gfr':'\uD835\uDD0A','gg':'\u226B','Gg':'\u22D9','ggg':'\u22D9','gimel':'\u2137','gjcy':'\u0453','GJcy':'\u0403','gl':'\u2277','gla':'\u2AA5','glE':'\u2A92','glj':'\u2AA4','gnap':'\u2A8A','gnapprox':'\u2A8A','gne':'\u2A88','gnE':'\u2269','gneq':'\u2A88','gneqq':'\u2269','gnsim':'\u22E7','gopf':'\uD835\uDD58','Gopf':'\uD835\uDD3E','grave':'`','GreaterEqual':'\u2265','GreaterEqualLess':'\u22DB','GreaterFullEqual':'\u2267','GreaterGreater':'\u2AA2','GreaterLess':'\u2277','GreaterSlantEqual':'\u2A7E','GreaterTilde':'\u2273','gscr':'\u210A','Gscr':'\uD835\uDCA2','gsim':'\u2273','gsime':'\u2A8E','gsiml':'\u2A90','gt':'>','Gt':'\u226B','GT':'>','gtcc':'\u2AA7','gtcir':'\u2A7A','gtdot':'\u22D7','gtlPar':'\u2995','gtquest':'\u2A7C','gtrapprox':'\u2A86','gtrarr':'\u2978','gtrdot':'\u22D7','gtreqless':'\u22DB','gtreqqless':'\u2A8C','gtrless':'\u2277','gtrsim':'\u2273','gvertneqq':'\u2269\uFE00','gvnE':'\u2269\uFE00','Hacek':'\u02C7','hairsp':'\u200A','half':'\xBD','hamilt':'\u210B','hardcy':'\u044A','HARDcy':'\u042A','harr':'\u2194','hArr':'\u21D4','harrcir':'\u2948','harrw':'\u21AD','Hat':'^','hbar':'\u210F','hcirc':'\u0125','Hcirc':'\u0124','hearts':'\u2665','heartsuit':'\u2665','hellip':'\u2026','hercon':'\u22B9','hfr':'\uD835\uDD25','Hfr':'\u210C','HilbertSpace':'\u210B','hksearow':'\u2925','hkswarow':'\u2926','hoarr':'\u21FF','homtht':'\u223B','hookleftarrow':'\u21A9','hookrightarrow':'\u21AA','hopf':'\uD835\uDD59','Hopf':'\u210D','horbar':'\u2015','HorizontalLine':'\u2500','hscr':'\uD835\uDCBD','Hscr':'\u210B','hslash':'\u210F','hstrok':'\u0127','Hstrok':'\u0126','HumpDownHump':'\u224E','HumpEqual':'\u224F','hybull':'\u2043','hyphen':'\u2010','iacute':'\xED','Iacute':'\xCD','ic':'\u2063','icirc':'\xEE','Icirc':'\xCE','icy':'\u0438','Icy':'\u0418','Idot':'\u0130','iecy':'\u0435','IEcy':'\u0415','iexcl':'\xA1','iff':'\u21D4','ifr':'\uD835\uDD26','Ifr':'\u2111','igrave':'\xEC','Igrave':'\xCC','ii':'\u2148','iiiint':'\u2A0C','iiint':'\u222D','iinfin':'\u29DC','iiota':'\u2129','ijlig':'\u0133','IJlig':'\u0132','Im':'\u2111','imacr':'\u012B','Imacr':'\u012A','image':'\u2111','ImaginaryI':'\u2148','imagline':'\u2110','imagpart':'\u2111','imath':'\u0131','imof':'\u22B7','imped':'\u01B5','Implies':'\u21D2','in':'\u2208','incare':'\u2105','infin':'\u221E','infintie':'\u29DD','inodot':'\u0131','int':'\u222B','Int':'\u222C','intcal':'\u22BA','integers':'\u2124','Integral':'\u222B','intercal':'\u22BA','Intersection':'\u22C2','intlarhk':'\u2A17','intprod':'\u2A3C','InvisibleComma':'\u2063','InvisibleTimes':'\u2062','iocy':'\u0451','IOcy':'\u0401','iogon':'\u012F','Iogon':'\u012E','iopf':'\uD835\uDD5A','Iopf':'\uD835\uDD40','iota':'\u03B9','Iota':'\u0399','iprod':'\u2A3C','iquest':'\xBF','iscr':'\uD835\uDCBE','Iscr':'\u2110','isin':'\u2208','isindot':'\u22F5','isinE':'\u22F9','isins':'\u22F4','isinsv':'\u22F3','isinv':'\u2208','it':'\u2062','itilde':'\u0129','Itilde':'\u0128','iukcy':'\u0456','Iukcy':'\u0406','iuml':'\xEF','Iuml':'\xCF','jcirc':'\u0135','Jcirc':'\u0134','jcy':'\u0439','Jcy':'\u0419','jfr':'\uD835\uDD27','Jfr':'\uD835\uDD0D','jmath':'\u0237','jopf':'\uD835\uDD5B','Jopf':'\uD835\uDD41','jscr':'\uD835\uDCBF','Jscr':'\uD835\uDCA5','jsercy':'\u0458','Jsercy':'\u0408','jukcy':'\u0454','Jukcy':'\u0404','kappa':'\u03BA','Kappa':'\u039A','kappav':'\u03F0','kcedil':'\u0137','Kcedil':'\u0136','kcy':'\u043A','Kcy':'\u041A','kfr':'\uD835\uDD28','Kfr':'\uD835\uDD0E','kgreen':'\u0138','khcy':'\u0445','KHcy':'\u0425','kjcy':'\u045C','KJcy':'\u040C','kopf':'\uD835\uDD5C','Kopf':'\uD835\uDD42','kscr':'\uD835\uDCC0','Kscr':'\uD835\uDCA6','lAarr':'\u21DA','lacute':'\u013A','Lacute':'\u0139','laemptyv':'\u29B4','lagran':'\u2112','lambda':'\u03BB','Lambda':'\u039B','lang':'\u27E8','Lang':'\u27EA','langd':'\u2991','langle':'\u27E8','lap':'\u2A85','Laplacetrf':'\u2112','laquo':'\xAB','larr':'\u2190','lArr':'\u21D0','Larr':'\u219E','larrb':'\u21E4','larrbfs':'\u291F','larrfs':'\u291D','larrhk':'\u21A9','larrlp':'\u21AB','larrpl':'\u2939','larrsim':'\u2973','larrtl':'\u21A2','lat':'\u2AAB','latail':'\u2919','lAtail':'\u291B','late':'\u2AAD','lates':'\u2AAD\uFE00','lbarr':'\u290C','lBarr':'\u290E','lbbrk':'\u2772','lbrace':'{','lbrack':'[','lbrke':'\u298B','lbrksld':'\u298F','lbrkslu':'\u298D','lcaron':'\u013E','Lcaron':'\u013D','lcedil':'\u013C','Lcedil':'\u013B','lceil':'\u2308','lcub':'{','lcy':'\u043B','Lcy':'\u041B','ldca':'\u2936','ldquo':'\u201C','ldquor':'\u201E','ldrdhar':'\u2967','ldrushar':'\u294B','ldsh':'\u21B2','le':'\u2264','lE':'\u2266','LeftAngleBracket':'\u27E8','leftarrow':'\u2190','Leftarrow':'\u21D0','LeftArrow':'\u2190','LeftArrowBar':'\u21E4','LeftArrowRightArrow':'\u21C6','leftarrowtail':'\u21A2','LeftCeiling':'\u2308','LeftDoubleBracket':'\u27E6','LeftDownTeeVector':'\u2961','LeftDownVector':'\u21C3','LeftDownVectorBar':'\u2959','LeftFloor':'\u230A','leftharpoondown':'\u21BD','leftharpoonup':'\u21BC','leftleftarrows':'\u21C7','leftrightarrow':'\u2194','Leftrightarrow':'\u21D4','LeftRightArrow':'\u2194','leftrightarrows':'\u21C6','leftrightharpoons':'\u21CB','leftrightsquigarrow':'\u21AD','LeftRightVector':'\u294E','LeftTee':'\u22A3','LeftTeeArrow':'\u21A4','LeftTeeVector':'\u295A','leftthreetimes':'\u22CB','LeftTriangle':'\u22B2','LeftTriangleBar':'\u29CF','LeftTriangleEqual':'\u22B4','LeftUpDownVector':'\u2951','LeftUpTeeVector':'\u2960','LeftUpVector':'\u21BF','LeftUpVectorBar':'\u2958','LeftVector':'\u21BC','LeftVectorBar':'\u2952','leg':'\u22DA','lEg':'\u2A8B','leq':'\u2264','leqq':'\u2266','leqslant':'\u2A7D','les':'\u2A7D','lescc':'\u2AA8','lesdot':'\u2A7F','lesdoto':'\u2A81','lesdotor':'\u2A83','lesg':'\u22DA\uFE00','lesges':'\u2A93','lessapprox':'\u2A85','lessdot':'\u22D6','lesseqgtr':'\u22DA','lesseqqgtr':'\u2A8B','LessEqualGreater':'\u22DA','LessFullEqual':'\u2266','LessGreater':'\u2276','lessgtr':'\u2276','LessLess':'\u2AA1','lesssim':'\u2272','LessSlantEqual':'\u2A7D','LessTilde':'\u2272','lfisht':'\u297C','lfloor':'\u230A','lfr':'\uD835\uDD29','Lfr':'\uD835\uDD0F','lg':'\u2276','lgE':'\u2A91','lHar':'\u2962','lhard':'\u21BD','lharu':'\u21BC','lharul':'\u296A','lhblk':'\u2584','ljcy':'\u0459','LJcy':'\u0409','ll':'\u226A','Ll':'\u22D8','llarr':'\u21C7','llcorner':'\u231E','Lleftarrow':'\u21DA','llhard':'\u296B','lltri':'\u25FA','lmidot':'\u0140','Lmidot':'\u013F','lmoust':'\u23B0','lmoustache':'\u23B0','lnap':'\u2A89','lnapprox':'\u2A89','lne':'\u2A87','lnE':'\u2268','lneq':'\u2A87','lneqq':'\u2268','lnsim':'\u22E6','loang':'\u27EC','loarr':'\u21FD','lobrk':'\u27E6','longleftarrow':'\u27F5','Longleftarrow':'\u27F8','LongLeftArrow':'\u27F5','longleftrightarrow':'\u27F7','Longleftrightarrow':'\u27FA','LongLeftRightArrow':'\u27F7','longmapsto':'\u27FC','longrightarrow':'\u27F6','Longrightarrow':'\u27F9','LongRightArrow':'\u27F6','looparrowleft':'\u21AB','looparrowright':'\u21AC','lopar':'\u2985','lopf':'\uD835\uDD5D','Lopf':'\uD835\uDD43','loplus':'\u2A2D','lotimes':'\u2A34','lowast':'\u2217','lowbar':'_','LowerLeftArrow':'\u2199','LowerRightArrow':'\u2198','loz':'\u25CA','lozenge':'\u25CA','lozf':'\u29EB','lpar':'(','lparlt':'\u2993','lrarr':'\u21C6','lrcorner':'\u231F','lrhar':'\u21CB','lrhard':'\u296D','lrm':'\u200E','lrtri':'\u22BF','lsaquo':'\u2039','lscr':'\uD835\uDCC1','Lscr':'\u2112','lsh':'\u21B0','Lsh':'\u21B0','lsim':'\u2272','lsime':'\u2A8D','lsimg':'\u2A8F','lsqb':'[','lsquo':'\u2018','lsquor':'\u201A','lstrok':'\u0142','Lstrok':'\u0141','lt':'<','Lt':'\u226A','LT':'<','ltcc':'\u2AA6','ltcir':'\u2A79','ltdot':'\u22D6','lthree':'\u22CB','ltimes':'\u22C9','ltlarr':'\u2976','ltquest':'\u2A7B','ltri':'\u25C3','ltrie':'\u22B4','ltrif':'\u25C2','ltrPar':'\u2996','lurdshar':'\u294A','luruhar':'\u2966','lvertneqq':'\u2268\uFE00','lvnE':'\u2268\uFE00','macr':'\xAF','male':'\u2642','malt':'\u2720','maltese':'\u2720','map':'\u21A6','Map':'\u2905','mapsto':'\u21A6','mapstodown':'\u21A7','mapstoleft':'\u21A4','mapstoup':'\u21A5','marker':'\u25AE','mcomma':'\u2A29','mcy':'\u043C','Mcy':'\u041C','mdash':'\u2014','mDDot':'\u223A','measuredangle':'\u2221','MediumSpace':'\u205F','Mellintrf':'\u2133','mfr':'\uD835\uDD2A','Mfr':'\uD835\uDD10','mho':'\u2127','micro':'\xB5','mid':'\u2223','midast':'*','midcir':'\u2AF0','middot':'\xB7','minus':'\u2212','minusb':'\u229F','minusd':'\u2238','minusdu':'\u2A2A','MinusPlus':'\u2213','mlcp':'\u2ADB','mldr':'\u2026','mnplus':'\u2213','models':'\u22A7','mopf':'\uD835\uDD5E','Mopf':'\uD835\uDD44','mp':'\u2213','mscr':'\uD835\uDCC2','Mscr':'\u2133','mstpos':'\u223E','mu':'\u03BC','Mu':'\u039C','multimap':'\u22B8','mumap':'\u22B8','nabla':'\u2207','nacute':'\u0144','Nacute':'\u0143','nang':'\u2220\u20D2','nap':'\u2249','napE':'\u2A70\u0338','napid':'\u224B\u0338','napos':'\u0149','napprox':'\u2249','natur':'\u266E','natural':'\u266E','naturals':'\u2115','nbsp':'\xA0','nbump':'\u224E\u0338','nbumpe':'\u224F\u0338','ncap':'\u2A43','ncaron':'\u0148','Ncaron':'\u0147','ncedil':'\u0146','Ncedil':'\u0145','ncong':'\u2247','ncongdot':'\u2A6D\u0338','ncup':'\u2A42','ncy':'\u043D','Ncy':'\u041D','ndash':'\u2013','ne':'\u2260','nearhk':'\u2924','nearr':'\u2197','neArr':'\u21D7','nearrow':'\u2197','nedot':'\u2250\u0338','NegativeMediumSpace':'\u200B','NegativeThickSpace':'\u200B','NegativeThinSpace':'\u200B','NegativeVeryThinSpace':'\u200B','nequiv':'\u2262','nesear':'\u2928','nesim':'\u2242\u0338','NestedGreaterGreater':'\u226B','NestedLessLess':'\u226A','NewLine':'\n','nexist':'\u2204','nexists':'\u2204','nfr':'\uD835\uDD2B','Nfr':'\uD835\uDD11','nge':'\u2271','ngE':'\u2267\u0338','ngeq':'\u2271','ngeqq':'\u2267\u0338','ngeqslant':'\u2A7E\u0338','nges':'\u2A7E\u0338','nGg':'\u22D9\u0338','ngsim':'\u2275','ngt':'\u226F','nGt':'\u226B\u20D2','ngtr':'\u226F','nGtv':'\u226B\u0338','nharr':'\u21AE','nhArr':'\u21CE','nhpar':'\u2AF2','ni':'\u220B','nis':'\u22FC','nisd':'\u22FA','niv':'\u220B','njcy':'\u045A','NJcy':'\u040A','nlarr':'\u219A','nlArr':'\u21CD','nldr':'\u2025','nle':'\u2270','nlE':'\u2266\u0338','nleftarrow':'\u219A','nLeftarrow':'\u21CD','nleftrightarrow':'\u21AE','nLeftrightarrow':'\u21CE','nleq':'\u2270','nleqq':'\u2266\u0338','nleqslant':'\u2A7D\u0338','nles':'\u2A7D\u0338','nless':'\u226E','nLl':'\u22D8\u0338','nlsim':'\u2274','nlt':'\u226E','nLt':'\u226A\u20D2','nltri':'\u22EA','nltrie':'\u22EC','nLtv':'\u226A\u0338','nmid':'\u2224','NoBreak':'\u2060','NonBreakingSpace':'\xA0','nopf':'\uD835\uDD5F','Nopf':'\u2115','not':'\xAC','Not':'\u2AEC','NotCongruent':'\u2262','NotCupCap':'\u226D','NotDoubleVerticalBar':'\u2226','NotElement':'\u2209','NotEqual':'\u2260','NotEqualTilde':'\u2242\u0338','NotExists':'\u2204','NotGreater':'\u226F','NotGreaterEqual':'\u2271','NotGreaterFullEqual':'\u2267\u0338','NotGreaterGreater':'\u226B\u0338','NotGreaterLess':'\u2279','NotGreaterSlantEqual':'\u2A7E\u0338','NotGreaterTilde':'\u2275','NotHumpDownHump':'\u224E\u0338','NotHumpEqual':'\u224F\u0338','notin':'\u2209','notindot':'\u22F5\u0338','notinE':'\u22F9\u0338','notinva':'\u2209','notinvb':'\u22F7','notinvc':'\u22F6','NotLeftTriangle':'\u22EA','NotLeftTriangleBar':'\u29CF\u0338','NotLeftTriangleEqual':'\u22EC','NotLess':'\u226E','NotLessEqual':'\u2270','NotLessGreater':'\u2278','NotLessLess':'\u226A\u0338','NotLessSlantEqual':'\u2A7D\u0338','NotLessTilde':'\u2274','NotNestedGreaterGreater':'\u2AA2\u0338','NotNestedLessLess':'\u2AA1\u0338','notni':'\u220C','notniva':'\u220C','notnivb':'\u22FE','notnivc':'\u22FD','NotPrecedes':'\u2280','NotPrecedesEqual':'\u2AAF\u0338','NotPrecedesSlantEqual':'\u22E0','NotReverseElement':'\u220C','NotRightTriangle':'\u22EB','NotRightTriangleBar':'\u29D0\u0338','NotRightTriangleEqual':'\u22ED','NotSquareSubset':'\u228F\u0338','NotSquareSubsetEqual':'\u22E2','NotSquareSuperset':'\u2290\u0338','NotSquareSupersetEqual':'\u22E3','NotSubset':'\u2282\u20D2','NotSubsetEqual':'\u2288','NotSucceeds':'\u2281','NotSucceedsEqual':'\u2AB0\u0338','NotSucceedsSlantEqual':'\u22E1','NotSucceedsTilde':'\u227F\u0338','NotSuperset':'\u2283\u20D2','NotSupersetEqual':'\u2289','NotTilde':'\u2241','NotTildeEqual':'\u2244','NotTildeFullEqual':'\u2247','NotTildeTilde':'\u2249','NotVerticalBar':'\u2224','npar':'\u2226','nparallel':'\u2226','nparsl':'\u2AFD\u20E5','npart':'\u2202\u0338','npolint':'\u2A14','npr':'\u2280','nprcue':'\u22E0','npre':'\u2AAF\u0338','nprec':'\u2280','npreceq':'\u2AAF\u0338','nrarr':'\u219B','nrArr':'\u21CF','nrarrc':'\u2933\u0338','nrarrw':'\u219D\u0338','nrightarrow':'\u219B','nRightarrow':'\u21CF','nrtri':'\u22EB','nrtrie':'\u22ED','nsc':'\u2281','nsccue':'\u22E1','nsce':'\u2AB0\u0338','nscr':'\uD835\uDCC3','Nscr':'\uD835\uDCA9','nshortmid':'\u2224','nshortparallel':'\u2226','nsim':'\u2241','nsime':'\u2244','nsimeq':'\u2244','nsmid':'\u2224','nspar':'\u2226','nsqsube':'\u22E2','nsqsupe':'\u22E3','nsub':'\u2284','nsube':'\u2288','nsubE':'\u2AC5\u0338','nsubset':'\u2282\u20D2','nsubseteq':'\u2288','nsubseteqq':'\u2AC5\u0338','nsucc':'\u2281','nsucceq':'\u2AB0\u0338','nsup':'\u2285','nsupe':'\u2289','nsupE':'\u2AC6\u0338','nsupset':'\u2283\u20D2','nsupseteq':'\u2289','nsupseteqq':'\u2AC6\u0338','ntgl':'\u2279','ntilde':'\xF1','Ntilde':'\xD1','ntlg':'\u2278','ntriangleleft':'\u22EA','ntrianglelefteq':'\u22EC','ntriangleright':'\u22EB','ntrianglerighteq':'\u22ED','nu':'\u03BD','Nu':'\u039D','num':'#','numero':'\u2116','numsp':'\u2007','nvap':'\u224D\u20D2','nvdash':'\u22AC','nvDash':'\u22AD','nVdash':'\u22AE','nVDash':'\u22AF','nvge':'\u2265\u20D2','nvgt':'>\u20D2','nvHarr':'\u2904','nvinfin':'\u29DE','nvlArr':'\u2902','nvle':'\u2264\u20D2','nvlt':'<\u20D2','nvltrie':'\u22B4\u20D2','nvrArr':'\u2903','nvrtrie':'\u22B5\u20D2','nvsim':'\u223C\u20D2','nwarhk':'\u2923','nwarr':'\u2196','nwArr':'\u21D6','nwarrow':'\u2196','nwnear':'\u2927','oacute':'\xF3','Oacute':'\xD3','oast':'\u229B','ocir':'\u229A','ocirc':'\xF4','Ocirc':'\xD4','ocy':'\u043E','Ocy':'\u041E','odash':'\u229D','odblac':'\u0151','Odblac':'\u0150','odiv':'\u2A38','odot':'\u2299','odsold':'\u29BC','oelig':'\u0153','OElig':'\u0152','ofcir':'\u29BF','ofr':'\uD835\uDD2C','Ofr':'\uD835\uDD12','ogon':'\u02DB','ograve':'\xF2','Ograve':'\xD2','ogt':'\u29C1','ohbar':'\u29B5','ohm':'\u03A9','oint':'\u222E','olarr':'\u21BA','olcir':'\u29BE','olcross':'\u29BB','oline':'\u203E','olt':'\u29C0','omacr':'\u014D','Omacr':'\u014C','omega':'\u03C9','Omega':'\u03A9','omicron':'\u03BF','Omicron':'\u039F','omid':'\u29B6','ominus':'\u2296','oopf':'\uD835\uDD60','Oopf':'\uD835\uDD46','opar':'\u29B7','OpenCurlyDoubleQuote':'\u201C','OpenCurlyQuote':'\u2018','operp':'\u29B9','oplus':'\u2295','or':'\u2228','Or':'\u2A54','orarr':'\u21BB','ord':'\u2A5D','order':'\u2134','orderof':'\u2134','ordf':'\xAA','ordm':'\xBA','origof':'\u22B6','oror':'\u2A56','orslope':'\u2A57','orv':'\u2A5B','oS':'\u24C8','oscr':'\u2134','Oscr':'\uD835\uDCAA','oslash':'\xF8','Oslash':'\xD8','osol':'\u2298','otilde':'\xF5','Otilde':'\xD5','otimes':'\u2297','Otimes':'\u2A37','otimesas':'\u2A36','ouml':'\xF6','Ouml':'\xD6','ovbar':'\u233D','OverBar':'\u203E','OverBrace':'\u23DE','OverBracket':'\u23B4','OverParenthesis':'\u23DC','par':'\u2225','para':'\xB6','parallel':'\u2225','parsim':'\u2AF3','parsl':'\u2AFD','part':'\u2202','PartialD':'\u2202','pcy':'\u043F','Pcy':'\u041F','percnt':'%','period':'.','permil':'\u2030','perp':'\u22A5','pertenk':'\u2031','pfr':'\uD835\uDD2D','Pfr':'\uD835\uDD13','phi':'\u03C6','Phi':'\u03A6','phiv':'\u03D5','phmmat':'\u2133','phone':'\u260E','pi':'\u03C0','Pi':'\u03A0','pitchfork':'\u22D4','piv':'\u03D6','planck':'\u210F','planckh':'\u210E','plankv':'\u210F','plus':'+','plusacir':'\u2A23','plusb':'\u229E','pluscir':'\u2A22','plusdo':'\u2214','plusdu':'\u2A25','pluse':'\u2A72','PlusMinus':'\xB1','plusmn':'\xB1','plussim':'\u2A26','plustwo':'\u2A27','pm':'\xB1','Poincareplane':'\u210C','pointint':'\u2A15','popf':'\uD835\uDD61','Popf':'\u2119','pound':'\xA3','pr':'\u227A','Pr':'\u2ABB','prap':'\u2AB7','prcue':'\u227C','pre':'\u2AAF','prE':'\u2AB3','prec':'\u227A','precapprox':'\u2AB7','preccurlyeq':'\u227C','Precedes':'\u227A','PrecedesEqual':'\u2AAF','PrecedesSlantEqual':'\u227C','PrecedesTilde':'\u227E','preceq':'\u2AAF','precnapprox':'\u2AB9','precneqq':'\u2AB5','precnsim':'\u22E8','precsim':'\u227E','prime':'\u2032','Prime':'\u2033','primes':'\u2119','prnap':'\u2AB9','prnE':'\u2AB5','prnsim':'\u22E8','prod':'\u220F','Product':'\u220F','profalar':'\u232E','profline':'\u2312','profsurf':'\u2313','prop':'\u221D','Proportion':'\u2237','Proportional':'\u221D','propto':'\u221D','prsim':'\u227E','prurel':'\u22B0','pscr':'\uD835\uDCC5','Pscr':'\uD835\uDCAB','psi':'\u03C8','Psi':'\u03A8','puncsp':'\u2008','qfr':'\uD835\uDD2E','Qfr':'\uD835\uDD14','qint':'\u2A0C','qopf':'\uD835\uDD62','Qopf':'\u211A','qprime':'\u2057','qscr':'\uD835\uDCC6','Qscr':'\uD835\uDCAC','quaternions':'\u210D','quatint':'\u2A16','quest':'?','questeq':'\u225F','quot':'"','QUOT':'"','rAarr':'\u21DB','race':'\u223D\u0331','racute':'\u0155','Racute':'\u0154','radic':'\u221A','raemptyv':'\u29B3','rang':'\u27E9','Rang':'\u27EB','rangd':'\u2992','range':'\u29A5','rangle':'\u27E9','raquo':'\xBB','rarr':'\u2192','rArr':'\u21D2','Rarr':'\u21A0','rarrap':'\u2975','rarrb':'\u21E5','rarrbfs':'\u2920','rarrc':'\u2933','rarrfs':'\u291E','rarrhk':'\u21AA','rarrlp':'\u21AC','rarrpl':'\u2945','rarrsim':'\u2974','rarrtl':'\u21A3','Rarrtl':'\u2916','rarrw':'\u219D','ratail':'\u291A','rAtail':'\u291C','ratio':'\u2236','rationals':'\u211A','rbarr':'\u290D','rBarr':'\u290F','RBarr':'\u2910','rbbrk':'\u2773','rbrace':'}','rbrack':']','rbrke':'\u298C','rbrksld':'\u298E','rbrkslu':'\u2990','rcaron':'\u0159','Rcaron':'\u0158','rcedil':'\u0157','Rcedil':'\u0156','rceil':'\u2309','rcub':'}','rcy':'\u0440','Rcy':'\u0420','rdca':'\u2937','rdldhar':'\u2969','rdquo':'\u201D','rdquor':'\u201D','rdsh':'\u21B3','Re':'\u211C','real':'\u211C','realine':'\u211B','realpart':'\u211C','reals':'\u211D','rect':'\u25AD','reg':'\xAE','REG':'\xAE','ReverseElement':'\u220B','ReverseEquilibrium':'\u21CB','ReverseUpEquilibrium':'\u296F','rfisht':'\u297D','rfloor':'\u230B','rfr':'\uD835\uDD2F','Rfr':'\u211C','rHar':'\u2964','rhard':'\u21C1','rharu':'\u21C0','rharul':'\u296C','rho':'\u03C1','Rho':'\u03A1','rhov':'\u03F1','RightAngleBracket':'\u27E9','rightarrow':'\u2192','Rightarrow':'\u21D2','RightArrow':'\u2192','RightArrowBar':'\u21E5','RightArrowLeftArrow':'\u21C4','rightarrowtail':'\u21A3','RightCeiling':'\u2309','RightDoubleBracket':'\u27E7','RightDownTeeVector':'\u295D','RightDownVector':'\u21C2','RightDownVectorBar':'\u2955','RightFloor':'\u230B','rightharpoondown':'\u21C1','rightharpoonup':'\u21C0','rightleftarrows':'\u21C4','rightleftharpoons':'\u21CC','rightrightarrows':'\u21C9','rightsquigarrow':'\u219D','RightTee':'\u22A2','RightTeeArrow':'\u21A6','RightTeeVector':'\u295B','rightthreetimes':'\u22CC','RightTriangle':'\u22B3','RightTriangleBar':'\u29D0','RightTriangleEqual':'\u22B5','RightUpDownVector':'\u294F','RightUpTeeVector':'\u295C','RightUpVector':'\u21BE','RightUpVectorBar':'\u2954','RightVector':'\u21C0','RightVectorBar':'\u2953','ring':'\u02DA','risingdotseq':'\u2253','rlarr':'\u21C4','rlhar':'\u21CC','rlm':'\u200F','rmoust':'\u23B1','rmoustache':'\u23B1','rnmid':'\u2AEE','roang':'\u27ED','roarr':'\u21FE','robrk':'\u27E7','ropar':'\u2986','ropf':'\uD835\uDD63','Ropf':'\u211D','roplus':'\u2A2E','rotimes':'\u2A35','RoundImplies':'\u2970','rpar':')','rpargt':'\u2994','rppolint':'\u2A12','rrarr':'\u21C9','Rrightarrow':'\u21DB','rsaquo':'\u203A','rscr':'\uD835\uDCC7','Rscr':'\u211B','rsh':'\u21B1','Rsh':'\u21B1','rsqb':']','rsquo':'\u2019','rsquor':'\u2019','rthree':'\u22CC','rtimes':'\u22CA','rtri':'\u25B9','rtrie':'\u22B5','rtrif':'\u25B8','rtriltri':'\u29CE','RuleDelayed':'\u29F4','ruluhar':'\u2968','rx':'\u211E','sacute':'\u015B','Sacute':'\u015A','sbquo':'\u201A','sc':'\u227B','Sc':'\u2ABC','scap':'\u2AB8','scaron':'\u0161','Scaron':'\u0160','sccue':'\u227D','sce':'\u2AB0','scE':'\u2AB4','scedil':'\u015F','Scedil':'\u015E','scirc':'\u015D','Scirc':'\u015C','scnap':'\u2ABA','scnE':'\u2AB6','scnsim':'\u22E9','scpolint':'\u2A13','scsim':'\u227F','scy':'\u0441','Scy':'\u0421','sdot':'\u22C5','sdotb':'\u22A1','sdote':'\u2A66','searhk':'\u2925','searr':'\u2198','seArr':'\u21D8','searrow':'\u2198','sect':'\xA7','semi':';','seswar':'\u2929','setminus':'\u2216','setmn':'\u2216','sext':'\u2736','sfr':'\uD835\uDD30','Sfr':'\uD835\uDD16','sfrown':'\u2322','sharp':'\u266F','shchcy':'\u0449','SHCHcy':'\u0429','shcy':'\u0448','SHcy':'\u0428','ShortDownArrow':'\u2193','ShortLeftArrow':'\u2190','shortmid':'\u2223','shortparallel':'\u2225','ShortRightArrow':'\u2192','ShortUpArrow':'\u2191','shy':'\xAD','sigma':'\u03C3','Sigma':'\u03A3','sigmaf':'\u03C2','sigmav':'\u03C2','sim':'\u223C','simdot':'\u2A6A','sime':'\u2243','simeq':'\u2243','simg':'\u2A9E','simgE':'\u2AA0','siml':'\u2A9D','simlE':'\u2A9F','simne':'\u2246','simplus':'\u2A24','simrarr':'\u2972','slarr':'\u2190','SmallCircle':'\u2218','smallsetminus':'\u2216','smashp':'\u2A33','smeparsl':'\u29E4','smid':'\u2223','smile':'\u2323','smt':'\u2AAA','smte':'\u2AAC','smtes':'\u2AAC\uFE00','softcy':'\u044C','SOFTcy':'\u042C','sol':'/','solb':'\u29C4','solbar':'\u233F','sopf':'\uD835\uDD64','Sopf':'\uD835\uDD4A','spades':'\u2660','spadesuit':'\u2660','spar':'\u2225','sqcap':'\u2293','sqcaps':'\u2293\uFE00','sqcup':'\u2294','sqcups':'\u2294\uFE00','Sqrt':'\u221A','sqsub':'\u228F','sqsube':'\u2291','sqsubset':'\u228F','sqsubseteq':'\u2291','sqsup':'\u2290','sqsupe':'\u2292','sqsupset':'\u2290','sqsupseteq':'\u2292','squ':'\u25A1','square':'\u25A1','Square':'\u25A1','SquareIntersection':'\u2293','SquareSubset':'\u228F','SquareSubsetEqual':'\u2291','SquareSuperset':'\u2290','SquareSupersetEqual':'\u2292','SquareUnion':'\u2294','squarf':'\u25AA','squf':'\u25AA','srarr':'\u2192','sscr':'\uD835\uDCC8','Sscr':'\uD835\uDCAE','ssetmn':'\u2216','ssmile':'\u2323','sstarf':'\u22C6','star':'\u2606','Star':'\u22C6','starf':'\u2605','straightepsilon':'\u03F5','straightphi':'\u03D5','strns':'\xAF','sub':'\u2282','Sub':'\u22D0','subdot':'\u2ABD','sube':'\u2286','subE':'\u2AC5','subedot':'\u2AC3','submult':'\u2AC1','subne':'\u228A','subnE':'\u2ACB','subplus':'\u2ABF','subrarr':'\u2979','subset':'\u2282','Subset':'\u22D0','subseteq':'\u2286','subseteqq':'\u2AC5','SubsetEqual':'\u2286','subsetneq':'\u228A','subsetneqq':'\u2ACB','subsim':'\u2AC7','subsub':'\u2AD5','subsup':'\u2AD3','succ':'\u227B','succapprox':'\u2AB8','succcurlyeq':'\u227D','Succeeds':'\u227B','SucceedsEqual':'\u2AB0','SucceedsSlantEqual':'\u227D','SucceedsTilde':'\u227F','succeq':'\u2AB0','succnapprox':'\u2ABA','succneqq':'\u2AB6','succnsim':'\u22E9','succsim':'\u227F','SuchThat':'\u220B','sum':'\u2211','Sum':'\u2211','sung':'\u266A','sup':'\u2283','Sup':'\u22D1','sup1':'\xB9','sup2':'\xB2','sup3':'\xB3','supdot':'\u2ABE','supdsub':'\u2AD8','supe':'\u2287','supE':'\u2AC6','supedot':'\u2AC4','Superset':'\u2283','SupersetEqual':'\u2287','suphsol':'\u27C9','suphsub':'\u2AD7','suplarr':'\u297B','supmult':'\u2AC2','supne':'\u228B','supnE':'\u2ACC','supplus':'\u2AC0','supset':'\u2283','Supset':'\u22D1','supseteq':'\u2287','supseteqq':'\u2AC6','supsetneq':'\u228B','supsetneqq':'\u2ACC','supsim':'\u2AC8','supsub':'\u2AD4','supsup':'\u2AD6','swarhk':'\u2926','swarr':'\u2199','swArr':'\u21D9','swarrow':'\u2199','swnwar':'\u292A','szlig':'\xDF','Tab':'\t','target':'\u2316','tau':'\u03C4','Tau':'\u03A4','tbrk':'\u23B4','tcaron':'\u0165','Tcaron':'\u0164','tcedil':'\u0163','Tcedil':'\u0162','tcy':'\u0442','Tcy':'\u0422','tdot':'\u20DB','telrec':'\u2315','tfr':'\uD835\uDD31','Tfr':'\uD835\uDD17','there4':'\u2234','therefore':'\u2234','Therefore':'\u2234','theta':'\u03B8','Theta':'\u0398','thetasym':'\u03D1','thetav':'\u03D1','thickapprox':'\u2248','thicksim':'\u223C','ThickSpace':'\u205F\u200A','thinsp':'\u2009','ThinSpace':'\u2009','thkap':'\u2248','thksim':'\u223C','thorn':'\xFE','THORN':'\xDE','tilde':'\u02DC','Tilde':'\u223C','TildeEqual':'\u2243','TildeFullEqual':'\u2245','TildeTilde':'\u2248','times':'\xD7','timesb':'\u22A0','timesbar':'\u2A31','timesd':'\u2A30','tint':'\u222D','toea':'\u2928','top':'\u22A4','topbot':'\u2336','topcir':'\u2AF1','topf':'\uD835\uDD65','Topf':'\uD835\uDD4B','topfork':'\u2ADA','tosa':'\u2929','tprime':'\u2034','trade':'\u2122','TRADE':'\u2122','triangle':'\u25B5','triangledown':'\u25BF','triangleleft':'\u25C3','trianglelefteq':'\u22B4','triangleq':'\u225C','triangleright':'\u25B9','trianglerighteq':'\u22B5','tridot':'\u25EC','trie':'\u225C','triminus':'\u2A3A','TripleDot':'\u20DB','triplus':'\u2A39','trisb':'\u29CD','tritime':'\u2A3B','trpezium':'\u23E2','tscr':'\uD835\uDCC9','Tscr':'\uD835\uDCAF','tscy':'\u0446','TScy':'\u0426','tshcy':'\u045B','TSHcy':'\u040B','tstrok':'\u0167','Tstrok':'\u0166','twixt':'\u226C','twoheadleftarrow':'\u219E','twoheadrightarrow':'\u21A0','uacute':'\xFA','Uacute':'\xDA','uarr':'\u2191','uArr':'\u21D1','Uarr':'\u219F','Uarrocir':'\u2949','ubrcy':'\u045E','Ubrcy':'\u040E','ubreve':'\u016D','Ubreve':'\u016C','ucirc':'\xFB','Ucirc':'\xDB','ucy':'\u0443','Ucy':'\u0423','udarr':'\u21C5','udblac':'\u0171','Udblac':'\u0170','udhar':'\u296E','ufisht':'\u297E','ufr':'\uD835\uDD32','Ufr':'\uD835\uDD18','ugrave':'\xF9','Ugrave':'\xD9','uHar':'\u2963','uharl':'\u21BF','uharr':'\u21BE','uhblk':'\u2580','ulcorn':'\u231C','ulcorner':'\u231C','ulcrop':'\u230F','ultri':'\u25F8','umacr':'\u016B','Umacr':'\u016A','uml':'\xA8','UnderBar':'_','UnderBrace':'\u23DF','UnderBracket':'\u23B5','UnderParenthesis':'\u23DD','Union':'\u22C3','UnionPlus':'\u228E','uogon':'\u0173','Uogon':'\u0172','uopf':'\uD835\uDD66','Uopf':'\uD835\uDD4C','uparrow':'\u2191','Uparrow':'\u21D1','UpArrow':'\u2191','UpArrowBar':'\u2912','UpArrowDownArrow':'\u21C5','updownarrow':'\u2195','Updownarrow':'\u21D5','UpDownArrow':'\u2195','UpEquilibrium':'\u296E','upharpoonleft':'\u21BF','upharpoonright':'\u21BE','uplus':'\u228E','UpperLeftArrow':'\u2196','UpperRightArrow':'\u2197','upsi':'\u03C5','Upsi':'\u03D2','upsih':'\u03D2','upsilon':'\u03C5','Upsilon':'\u03A5','UpTee':'\u22A5','UpTeeArrow':'\u21A5','upuparrows':'\u21C8','urcorn':'\u231D','urcorner':'\u231D','urcrop':'\u230E','uring':'\u016F','Uring':'\u016E','urtri':'\u25F9','uscr':'\uD835\uDCCA','Uscr':'\uD835\uDCB0','utdot':'\u22F0','utilde':'\u0169','Utilde':'\u0168','utri':'\u25B5','utrif':'\u25B4','uuarr':'\u21C8','uuml':'\xFC','Uuml':'\xDC','uwangle':'\u29A7','vangrt':'\u299C','varepsilon':'\u03F5','varkappa':'\u03F0','varnothing':'\u2205','varphi':'\u03D5','varpi':'\u03D6','varpropto':'\u221D','varr':'\u2195','vArr':'\u21D5','varrho':'\u03F1','varsigma':'\u03C2','varsubsetneq':'\u228A\uFE00','varsubsetneqq':'\u2ACB\uFE00','varsupsetneq':'\u228B\uFE00','varsupsetneqq':'\u2ACC\uFE00','vartheta':'\u03D1','vartriangleleft':'\u22B2','vartriangleright':'\u22B3','vBar':'\u2AE8','Vbar':'\u2AEB','vBarv':'\u2AE9','vcy':'\u0432','Vcy':'\u0412','vdash':'\u22A2','vDash':'\u22A8','Vdash':'\u22A9','VDash':'\u22AB','Vdashl':'\u2AE6','vee':'\u2228','Vee':'\u22C1','veebar':'\u22BB','veeeq':'\u225A','vellip':'\u22EE','verbar':'|','Verbar':'\u2016','vert':'|','Vert':'\u2016','VerticalBar':'\u2223','VerticalLine':'|','VerticalSeparator':'\u2758','VerticalTilde':'\u2240','VeryThinSpace':'\u200A','vfr':'\uD835\uDD33','Vfr':'\uD835\uDD19','vltri':'\u22B2','vnsub':'\u2282\u20D2','vnsup':'\u2283\u20D2','vopf':'\uD835\uDD67','Vopf':'\uD835\uDD4D','vprop':'\u221D','vrtri':'\u22B3','vscr':'\uD835\uDCCB','Vscr':'\uD835\uDCB1','vsubne':'\u228A\uFE00','vsubnE':'\u2ACB\uFE00','vsupne':'\u228B\uFE00','vsupnE':'\u2ACC\uFE00','Vvdash':'\u22AA','vzigzag':'\u299A','wcirc':'\u0175','Wcirc':'\u0174','wedbar':'\u2A5F','wedge':'\u2227','Wedge':'\u22C0','wedgeq':'\u2259','weierp':'\u2118','wfr':'\uD835\uDD34','Wfr':'\uD835\uDD1A','wopf':'\uD835\uDD68','Wopf':'\uD835\uDD4E','wp':'\u2118','wr':'\u2240','wreath':'\u2240','wscr':'\uD835\uDCCC','Wscr':'\uD835\uDCB2','xcap':'\u22C2','xcirc':'\u25EF','xcup':'\u22C3','xdtri':'\u25BD','xfr':'\uD835\uDD35','Xfr':'\uD835\uDD1B','xharr':'\u27F7','xhArr':'\u27FA','xi':'\u03BE','Xi':'\u039E','xlarr':'\u27F5','xlArr':'\u27F8','xmap':'\u27FC','xnis':'\u22FB','xodot':'\u2A00','xopf':'\uD835\uDD69','Xopf':'\uD835\uDD4F','xoplus':'\u2A01','xotime':'\u2A02','xrarr':'\u27F6','xrArr':'\u27F9','xscr':'\uD835\uDCCD','Xscr':'\uD835\uDCB3','xsqcup':'\u2A06','xuplus':'\u2A04','xutri':'\u25B3','xvee':'\u22C1','xwedge':'\u22C0','yacute':'\xFD','Yacute':'\xDD','yacy':'\u044F','YAcy':'\u042F','ycirc':'\u0177','Ycirc':'\u0176','ycy':'\u044B','Ycy':'\u042B','yen':'\xA5','yfr':'\uD835\uDD36','Yfr':'\uD835\uDD1C','yicy':'\u0457','YIcy':'\u0407','yopf':'\uD835\uDD6A','Yopf':'\uD835\uDD50','yscr':'\uD835\uDCCE','Yscr':'\uD835\uDCB4','yucy':'\u044E','YUcy':'\u042E','yuml':'\xFF','Yuml':'\u0178','zacute':'\u017A','Zacute':'\u0179','zcaron':'\u017E','Zcaron':'\u017D','zcy':'\u0437','Zcy':'\u0417','zdot':'\u017C','Zdot':'\u017B','zeetrf':'\u2128','ZeroWidthSpace':'\u200B','zeta':'\u03B6','Zeta':'\u0396','zfr':'\uD835\uDD37','Zfr':'\u2128','zhcy':'\u0436','ZHcy':'\u0416','zigrarr':'\u21DD','zopf':'\uD835\uDD6B','Zopf':'\u2124','zscr':'\uD835\uDCCF','Zscr':'\uD835\uDCB5','zwj':'\u200D','zwnj':'\u200C'};
	var decodeMapLegacy = {'aacute':'\xE1','Aacute':'\xC1','acirc':'\xE2','Acirc':'\xC2','acute':'\xB4','aelig':'\xE6','AElig':'\xC6','agrave':'\xE0','Agrave':'\xC0','amp':'&','AMP':'&','aring':'\xE5','Aring':'\xC5','atilde':'\xE3','Atilde':'\xC3','auml':'\xE4','Auml':'\xC4','brvbar':'\xA6','ccedil':'\xE7','Ccedil':'\xC7','cedil':'\xB8','cent':'\xA2','copy':'\xA9','COPY':'\xA9','curren':'\xA4','deg':'\xB0','divide':'\xF7','eacute':'\xE9','Eacute':'\xC9','ecirc':'\xEA','Ecirc':'\xCA','egrave':'\xE8','Egrave':'\xC8','eth':'\xF0','ETH':'\xD0','euml':'\xEB','Euml':'\xCB','frac12':'\xBD','frac14':'\xBC','frac34':'\xBE','gt':'>','GT':'>','iacute':'\xED','Iacute':'\xCD','icirc':'\xEE','Icirc':'\xCE','iexcl':'\xA1','igrave':'\xEC','Igrave':'\xCC','iquest':'\xBF','iuml':'\xEF','Iuml':'\xCF','laquo':'\xAB','lt':'<','LT':'<','macr':'\xAF','micro':'\xB5','middot':'\xB7','nbsp':'\xA0','not':'\xAC','ntilde':'\xF1','Ntilde':'\xD1','oacute':'\xF3','Oacute':'\xD3','ocirc':'\xF4','Ocirc':'\xD4','ograve':'\xF2','Ograve':'\xD2','ordf':'\xAA','ordm':'\xBA','oslash':'\xF8','Oslash':'\xD8','otilde':'\xF5','Otilde':'\xD5','ouml':'\xF6','Ouml':'\xD6','para':'\xB6','plusmn':'\xB1','pound':'\xA3','quot':'"','QUOT':'"','raquo':'\xBB','reg':'\xAE','REG':'\xAE','sect':'\xA7','shy':'\xAD','sup1':'\xB9','sup2':'\xB2','sup3':'\xB3','szlig':'\xDF','thorn':'\xFE','THORN':'\xDE','times':'\xD7','uacute':'\xFA','Uacute':'\xDA','ucirc':'\xFB','Ucirc':'\xDB','ugrave':'\xF9','Ugrave':'\xD9','uml':'\xA8','uuml':'\xFC','Uuml':'\xDC','yacute':'\xFD','Yacute':'\xDD','yen':'\xA5','yuml':'\xFF'};
	var decodeMapNumeric = {'0':'\uFFFD','128':'\u20AC','130':'\u201A','131':'\u0192','132':'\u201E','133':'\u2026','134':'\u2020','135':'\u2021','136':'\u02C6','137':'\u2030','138':'\u0160','139':'\u2039','140':'\u0152','142':'\u017D','145':'\u2018','146':'\u2019','147':'\u201C','148':'\u201D','149':'\u2022','150':'\u2013','151':'\u2014','152':'\u02DC','153':'\u2122','154':'\u0161','155':'\u203A','156':'\u0153','158':'\u017E','159':'\u0178'};
	var invalidReferenceCodePoints = [1,2,3,4,5,6,7,8,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,64976,64977,64978,64979,64980,64981,64982,64983,64984,64985,64986,64987,64988,64989,64990,64991,64992,64993,64994,64995,64996,64997,64998,64999,65000,65001,65002,65003,65004,65005,65006,65007,65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111];

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	var object = {};
	var hasOwnProperty = object.hasOwnProperty;
	var has = function(object, propertyName) {
		return hasOwnProperty.call(object, propertyName);
	};

	var contains = function(array, value) {
		var index = -1;
		var length = array.length;
		while (++index < length) {
			if (array[index] == value) {
				return true;
			}
		}
		return false;
	};

	var merge = function(options, defaults) {
		if (!options) {
			return defaults;
		}
		var result = {};
		var key;
		for (key in defaults) {
			// A `hasOwnProperty` check is not needed here, since only recognized
			// option names are used anyway. Any others are ignored.
			result[key] = has(options, key) ? options[key] : defaults[key];
		}
		return result;
	};

	// Modified version of `ucs2encode`; see https://mths.be/punycode.
	var codePointToSymbol = function(codePoint, strict) {
		var output = '';
		if ((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF) {
			// See issue #4:
			// Otherwise, if the number is in the range 0xD800 to 0xDFFF or is
			// greater than 0x10FFFF, then this is a parse error. Return a U+FFFD
			// REPLACEMENT CHARACTER.
			if (strict) {
				parseError('character reference outside the permissible Unicode range');
			}
			return '\uFFFD';
		}
		if (has(decodeMapNumeric, codePoint)) {
			if (strict) {
				parseError('disallowed character reference');
			}
			return decodeMapNumeric[codePoint];
		}
		if (strict && contains(invalidReferenceCodePoints, codePoint)) {
			parseError('disallowed character reference');
		}
		if (codePoint > 0xFFFF) {
			codePoint -= 0x10000;
			output += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
			codePoint = 0xDC00 | codePoint & 0x3FF;
		}
		output += stringFromCharCode(codePoint);
		return output;
	};

	var hexEscape = function(codePoint) {
		return '&#x' + codePoint.toString(16).toUpperCase() + ';';
	};

	var decEscape = function(codePoint) {
		return '&#' + codePoint + ';';
	};

	var parseError = function(message) {
		throw Error('Parse error: ' + message);
	};

	/*--------------------------------------------------------------------------*/

	var encode = function(string, options) {
		options = merge(options, encode.options);
		var strict = options.strict;
		if (strict && regexInvalidRawCodePoint.test(string)) {
			parseError('forbidden code point');
		}
		var encodeEverything = options.encodeEverything;
		var useNamedReferences = options.useNamedReferences;
		var allowUnsafeSymbols = options.allowUnsafeSymbols;
		var escapeCodePoint = options.decimal ? decEscape : hexEscape;

		var escapeBmpSymbol = function(symbol) {
			return escapeCodePoint(symbol.charCodeAt(0));
		};

		if (encodeEverything) {
			// Encode ASCII symbols.
			string = string.replace(regexAsciiWhitelist, function(symbol) {
				// Use named references if requested & possible.
				if (useNamedReferences && has(encodeMap, symbol)) {
					return '&' + encodeMap[symbol] + ';';
				}
				return escapeBmpSymbol(symbol);
			});
			// Shorten a few escapes that represent two symbols, of which at least one
			// is within the ASCII range.
			if (useNamedReferences) {
				string = string
					.replace(/&gt;\u20D2/g, '&nvgt;')
					.replace(/&lt;\u20D2/g, '&nvlt;')
					.replace(/&#x66;&#x6A;/g, '&fjlig;');
			}
			// Encode non-ASCII symbols.
			if (useNamedReferences) {
				// Encode non-ASCII symbols that can be replaced with a named reference.
				string = string.replace(regexEncodeNonAscii, function(string) {
					// Note: there is no need to check `has(encodeMap, string)` here.
					return '&' + encodeMap[string] + ';';
				});
			}
			// Note: any remaining non-ASCII symbols are handled outside of the `if`.
		} else if (useNamedReferences) {
			// Apply named character references.
			// Encode `<>"'&` using named character references.
			if (!allowUnsafeSymbols) {
				string = string.replace(regexEscape, function(string) {
					return '&' + encodeMap[string] + ';'; // no need to check `has()` here
				});
			}
			// Shorten escapes that represent two symbols, of which at least one is
			// `<>"'&`.
			string = string
				.replace(/&gt;\u20D2/g, '&nvgt;')
				.replace(/&lt;\u20D2/g, '&nvlt;');
			// Encode non-ASCII symbols that can be replaced with a named reference.
			string = string.replace(regexEncodeNonAscii, function(string) {
				// Note: there is no need to check `has(encodeMap, string)` here.
				return '&' + encodeMap[string] + ';';
			});
		} else if (!allowUnsafeSymbols) {
			// Encode `<>"'&` using hexadecimal escapes, now that theyre not handled
			// using named character references.
			string = string.replace(regexEscape, escapeBmpSymbol);
		}
		return string
			// Encode astral symbols.
			.replace(regexAstralSymbols, function($0) {
				// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
				var high = $0.charCodeAt(0);
				var low = $0.charCodeAt(1);
				var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
				return escapeCodePoint(codePoint);
			})
			// Encode any remaining BMP symbols that are not printable ASCII symbols
			// using a hexadecimal escape.
			.replace(regexBmpWhitelist, escapeBmpSymbol);
	};
	// Expose default options (so they can be overridden globally).
	encode.options = {
		'allowUnsafeSymbols': false,
		'encodeEverything': false,
		'strict': false,
		'useNamedReferences': false,
		'decimal' : false
	};

	var decode = function(html, options) {
		options = merge(options, decode.options);
		var strict = options.strict;
		if (strict && regexInvalidEntity.test(html)) {
			parseError('malformed character reference');
		}
		return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
			var codePoint;
			var semicolon;
			var decDigits;
			var hexDigits;
			var reference;
			var next;

			if ($1) {
				reference = $1;
				// Note: there is no need to check `has(decodeMap, reference)`.
				return decodeMap[reference];
			}

			if ($2) {
				// Decode named character references without trailing `;`, e.g. `&amp`.
				// This is only a parse error if it gets converted to `&`, or if it is
				// followed by `=` in an attribute context.
				reference = $2;
				next = $3;
				if (next && options.isAttributeValue) {
					if (strict && next == '=') {
						parseError('`&` did not start a character reference');
					}
					return $0;
				} else {
					if (strict) {
						parseError(
							'named character reference was not terminated by a semicolon'
						);
					}
					// Note: there is no need to check `has(decodeMapLegacy, reference)`.
					return decodeMapLegacy[reference] + (next || '');
				}
			}

			if ($4) {
				// Decode decimal escapes, e.g. `&#119558;`.
				decDigits = $4;
				semicolon = $5;
				if (strict && !semicolon) {
					parseError('character reference was not terminated by a semicolon');
				}
				codePoint = parseInt(decDigits, 10);
				return codePointToSymbol(codePoint, strict);
			}

			if ($6) {
				// Decode hexadecimal escapes, e.g. `&#x1D306;`.
				hexDigits = $6;
				semicolon = $7;
				if (strict && !semicolon) {
					parseError('character reference was not terminated by a semicolon');
				}
				codePoint = parseInt(hexDigits, 16);
				return codePointToSymbol(codePoint, strict);
			}

			// If were still here, `if ($7)` is implied; its an ambiguous
			// ampersand for sure. https://mths.be/notes/ambiguous-ampersands
			if (strict) {
				parseError(
					'named character reference was not terminated by a semicolon'
				);
			}
			return $0;
		});
	};
	// Expose default options (so they can be overridden globally).
	decode.options = {
		'isAttributeValue': false,
		'strict': false
	};

	var escape = function(string) {
		return string.replace(regexEscape, function($0) {
			// Note: there is no need to check `has(escapeMap, $0)` here.
			return escapeMap[$0];
		});
	};

	/*--------------------------------------------------------------------------*/

	var he = {
		'version': '1.2.0',
		'encode': encode,
		'decode': decode,
		'escape': escape,
		'unescape': decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return he;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}	else { var key; }

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/module.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/log-symbols/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/log-symbols/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
	info: '',
	success: '',
	warning: '',
	error: ''
};


/***/ }),

/***/ "./node_modules/mocha/browser-entry.js":
/*!*********************************************!*\
  !*** ./node_modules/mocha/browser-entry.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global) {

/* eslint no-unused-vars: off */
/* eslint-env commonjs */

/**
 * Shim process.stdout.
 */

process.stdout = __webpack_require__(/*! browser-stdout */ "./node_modules/browser-stdout/index.js")({label: false});

var parseQuery = __webpack_require__(/*! ./lib/browser/parse-query */ "./node_modules/mocha/lib/browser/parse-query.js");
var highlightTags = __webpack_require__(/*! ./lib/browser/highlight-tags */ "./node_modules/mocha/lib/browser/highlight-tags.js");
var Mocha = __webpack_require__(/*! ./lib/mocha */ "./node_modules/mocha/lib/mocha.js");

/**
 * Create a Mocha instance.
 *
 * @return {undefined}
 */

var mocha = new Mocha({reporter: 'html'});

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 */

var Date = global.Date;
var setTimeout = global.setTimeout;
var setInterval = global.setInterval;
var clearTimeout = global.clearTimeout;
var clearInterval = global.clearInterval;

var uncaughtExceptionHandlers = [];

var originalOnerrorHandler = global.onerror;

/**
 * Remove uncaughtException listener.
 * Revert to original onerror handler if previously defined.
 */

process.removeListener = function (e, fn) {
  if (e === 'uncaughtException') {
    if (originalOnerrorHandler) {
      global.onerror = originalOnerrorHandler;
    } else {
      global.onerror = function () {};
    }
    var i = uncaughtExceptionHandlers.indexOf(fn);
    if (i !== -1) {
      uncaughtExceptionHandlers.splice(i, 1);
    }
  }
};

/**
 * Implements listenerCount for 'uncaughtException'.
 */

process.listenerCount = function (name) {
  if (name === 'uncaughtException') {
    return uncaughtExceptionHandlers.length;
  }
  return 0;
};

/**
 * Implements uncaughtException listener.
 */

process.on = function (e, fn) {
  if (e === 'uncaughtException') {
    global.onerror = function (err, url, line) {
      fn(new Error(err + ' (' + url + ':' + line + ')'));
      return !mocha.options.allowUncaught;
    };
    uncaughtExceptionHandlers.push(fn);
  }
};

process.listeners = function (e) {
  if (e === 'uncaughtException') {
    return uncaughtExceptionHandlers;
  }
  return [];
};

// The BDD UI is registered by default, but no UI will be functional in the
// browser without an explicit call to the overridden `mocha.ui` (see below).
// Ensure that this default UI does not expose its methods to the global scope.
mocha.suite.removeAllListeners('pre-require');

var immediateQueue = [];
var immediateTimeout;

function timeslice() {
  var immediateStart = new Date().getTime();
  while (immediateQueue.length && new Date().getTime() - immediateStart < 100) {
    immediateQueue.shift()();
  }
  if (immediateQueue.length) {
    immediateTimeout = setTimeout(timeslice, 0);
  } else {
    immediateTimeout = null;
  }
}

/**
 * High-performance override of Runner.immediately.
 */

Mocha.Runner.immediately = function (callback) {
  immediateQueue.push(callback);
  if (!immediateTimeout) {
    immediateTimeout = setTimeout(timeslice, 0);
  }
};

/**
 * Function to allow assertion libraries to throw errors directly into mocha.
 * This is useful when running tests in a browser because window.onerror will
 * only receive the 'message' attribute of the Error.
 */
mocha.throwError = function (err) {
  uncaughtExceptionHandlers.forEach(function (fn) {
    fn(err);
  });
  throw err;
};

/**
 * Override ui to ensure that the ui functions are initialized.
 * Normally this would happen in Mocha.prototype.loadFiles.
 */

mocha.ui = function (ui) {
  Mocha.prototype.ui.call(this, ui);
  this.suite.emit('pre-require', global, null, this);
  return this;
};

/**
 * Setup mocha with the given setting options.
 */

mocha.setup = function (opts) {
  if (typeof opts === 'string') {
    opts = {ui: opts};
  }
  if (opts.delay === true) {
    this.delay();
  }
  var self = this;
  Object.keys(opts)
    .filter(function (opt) {
      return opt !== 'delay';
    })
    .forEach(function (opt) {
      if (Object.prototype.hasOwnProperty.call(opts, opt)) {
        self[opt](opts[opt]);
      }
    });
  return this;
};

/**
 * Run mocha, returning the Runner.
 */

mocha.run = function (fn) {
  var options = mocha.options;
  mocha.globals('location');

  var query = parseQuery(global.location.search || '');
  if (query.grep) {
    mocha.grep(query.grep);
  }
  if (query.fgrep) {
    mocha.fgrep(query.fgrep);
  }
  if (query.invert) {
    mocha.invert();
  }

  return Mocha.prototype.run.call(mocha, function (err) {
    // The DOM Document is not available in Web Workers.
    var document = global.document;
    if (
      document &&
      document.getElementById('mocha') &&
      options.noHighlighting !== true
    ) {
      highlightTags('code');
    }
    if (fn) {
      fn(err);
    }
  });
};

/**
 * Expose the process shim.
 * https://github.com/mochajs/mocha/pull/916
 */

Mocha.process = process;

/**
 * Expose mocha.
 */
global.Mocha = Mocha;
global.mocha = mocha;

// for bundlers: enable `import {describe, it} from 'mocha'`
// `bdd` interface only
// prettier-ignore
[ 
  'describe', 'context', 'it', 'specify',
  'xdescribe', 'xcontext', 'xit', 'xspecify',
  'before', 'beforeEach', 'afterEach', 'after'
].forEach(function(key) {
  mocha[key] = global[key];
});

module.exports = mocha;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/mocha/lib sync recursive":
/*!*************************************!*\
  !*** ./node_modules/mocha/lib sync ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/mocha/lib sync recursive";

/***/ }),

/***/ "./node_modules/mocha/lib/browser/highlight-tags.js":
/*!**********************************************************!*\
  !*** ./node_modules/mocha/lib/browser/highlight-tags.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Highlight the given string of `js`.
 *
 * @private
 * @param {string} js
 * @return {string}
 */
function highlight(js) {
  return js
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/\/\/(.*)/gm, '<span class="comment">//$1</span>')
    .replace(/('.*?')/gm, '<span class="string">$1</span>')
    .replace(/(\d+\.\d+)/gm, '<span class="number">$1</span>')
    .replace(/(\d+)/gm, '<span class="number">$1</span>')
    .replace(
      /\bnew[ \t]+(\w+)/gm,
      '<span class="keyword">new</span> <span class="init">$1</span>'
    )
    .replace(
      /\b(function|new|throw|return|var|if|else)\b/gm,
      '<span class="keyword">$1</span>'
    );
}

/**
 * Highlight the contents of tag `name`.
 *
 * @private
 * @param {string} name
 */
module.exports = function highlightTags(name) {
  var code = document.getElementById('mocha').getElementsByTagName(name);
  for (var i = 0, len = code.length; i < len; ++i) {
    code[i].innerHTML = highlight(code[i].innerHTML);
  }
};


/***/ }),

/***/ "./node_modules/mocha/lib/browser/parse-query.js":
/*!*******************************************************!*\
  !*** ./node_modules/mocha/lib/browser/parse-query.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Parse the given `qs`.
 *
 * @private
 * @param {string} qs
 * @return {Object<string, string>}
 */
module.exports = function parseQuery(qs) {
  return qs
    .replace('?', '')
    .split('&')
    .reduce(function (obj, pair) {
      var i = pair.indexOf('=');
      var key = pair.slice(0, i);
      var val = pair.slice(++i);

      // Due to how the URLSearchParams API treats spaces
      obj[key] = decodeURIComponent(val.replace(/\+/g, '%20'));

      return obj;
    }, {});
};


/***/ }),

/***/ "./node_modules/mocha/lib/browser/progress.js":
/*!****************************************************!*\
  !*** ./node_modules/mocha/lib/browser/progress.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 @module browser/Progress
*/

/**
 * Expose `Progress`.
 */

module.exports = Progress;

/**
 * Initialize a new `Progress` indicator.
 */
function Progress() {
  this.percent = 0;
  this.size(0);
  this.fontSize(11);
  this.font('helvetica, arial, sans-serif');
}

/**
 * Set progress size to `size`.
 *
 * @public
 * @param {number} size
 * @return {Progress} Progress instance.
 */
Progress.prototype.size = function (size) {
  this._size = size;
  return this;
};

/**
 * Set text to `text`.
 *
 * @public
 * @param {string} text
 * @return {Progress} Progress instance.
 */
Progress.prototype.text = function (text) {
  this._text = text;
  return this;
};

/**
 * Set font size to `size`.
 *
 * @public
 * @param {number} size
 * @return {Progress} Progress instance.
 */
Progress.prototype.fontSize = function (size) {
  this._fontSize = size;
  return this;
};

/**
 * Set font to `family`.
 *
 * @param {string} family
 * @return {Progress} Progress instance.
 */
Progress.prototype.font = function (family) {
  this._font = family;
  return this;
};

/**
 * Update percentage to `n`.
 *
 * @param {number} n
 * @return {Progress} Progress instance.
 */
Progress.prototype.update = function (n) {
  this.percent = n;
  return this;
};

/**
 * Draw on `ctx`.
 *
 * @param {CanvasRenderingContext2d} ctx
 * @return {Progress} Progress instance.
 */
Progress.prototype.draw = function (ctx) {
  try {
    var percent = Math.min(this.percent, 100);
    var size = this._size;
    var half = size / 2;
    var x = half;
    var y = half;
    var rad = half - 1;
    var fontSize = this._fontSize;

    ctx.font = fontSize + 'px ' + this._font;

    var angle = Math.PI * 2 * (percent / 100);
    ctx.clearRect(0, 0, size, size);

    // outer circle
    ctx.strokeStyle = '#9f9f9f';
    ctx.beginPath();
    ctx.arc(x, y, rad, 0, angle, false);
    ctx.stroke();

    // inner circle
    ctx.strokeStyle = '#eee';
    ctx.beginPath();
    ctx.arc(x, y, rad - 1, 0, angle, true);
    ctx.stroke();

    // text
    var text = this._text || (percent | 0) + '%';
    var w = ctx.measureText(text).width;

    ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);
  } catch (ignore) {
    // don't fail if we can't render progress
  }
  return this;
};


/***/ }),

/***/ "./node_modules/mocha/lib/context.js":
/*!*******************************************!*\
  !*** ./node_modules/mocha/lib/context.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @module Context
 */
/**
 * Expose `Context`.
 */

module.exports = Context;

/**
 * Initialize a new `Context`.
 *
 * @private
 */
function Context() {}

/**
 * Set or get the context `Runnable` to `runnable`.
 *
 * @private
 * @param {Runnable} runnable
 * @return {Context} context
 */
Context.prototype.runnable = function (runnable) {
  if (!arguments.length) {
    return this._runnable;
  }
  this.test = this._runnable = runnable;
  return this;
};

/**
 * Set or get test timeout `ms`.
 *
 * @private
 * @param {number} ms
 * @return {Context} self
 */
Context.prototype.timeout = function (ms) {
  if (!arguments.length) {
    return this.runnable().timeout();
  }
  this.runnable().timeout(ms);
  return this;
};

/**
 * Set or get test slowness threshold `ms`.
 *
 * @private
 * @param {number} ms
 * @return {Context} self
 */
Context.prototype.slow = function (ms) {
  if (!arguments.length) {
    return this.runnable().slow();
  }
  this.runnable().slow(ms);
  return this;
};

/**
 * Mark a test as skipped.
 *
 * @private
 * @throws Pending
 */
Context.prototype.skip = function () {
  this.runnable().skip();
};

/**
 * Set or get a number of allowed retries on failed tests
 *
 * @private
 * @param {number} n
 * @return {Context} self
 */
Context.prototype.retries = function (n) {
  if (!arguments.length) {
    return this.runnable().retries();
  }
  this.runnable().retries(n);
  return this;
};


/***/ }),

/***/ "./node_modules/mocha/lib/errors.js":
/*!******************************************!*\
  !*** ./node_modules/mocha/lib/errors.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

const {format} = __webpack_require__(/*! util */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/util/util.js");

/**
 * Contains error codes, factory functions to create throwable error objects,
 * and warning/deprecation functions.
 * @module
 */

/**
 * process.emitWarning or a polyfill
 * @see https://nodejs.org/api/process.html#process_process_emitwarning_warning_options
 * @ignore
 */
const emitWarning = (msg, type) => {
  if (process.emitWarning) {
    process.emitWarning(msg, type);
  } else {
    /* istanbul ignore next */
    process.nextTick(function () {
      console.warn(type + ': ' + msg);
    });
  }
};

/**
 * Show a deprecation warning. Each distinct message is only displayed once.
 * Ignores empty messages.
 *
 * @param {string} [msg] - Warning to print
 * @private
 */
const deprecate = msg => {
  msg = String(msg);
  if (msg && !deprecate.cache[msg]) {
    deprecate.cache[msg] = true;
    emitWarning(msg, 'DeprecationWarning');
  }
};
deprecate.cache = {};

/**
 * Show a generic warning.
 * Ignores empty messages.
 *
 * @param {string} [msg] - Warning to print
 * @private
 */
const warn = msg => {
  if (msg) {
    emitWarning(msg);
  }
};

/**
 * When Mocha throws exceptions (or rejects `Promise`s), it attempts to assign a `code` property to the `Error` object, for easier handling. These are the potential values of `code`.
 * @public
 * @namespace
 * @memberof module:lib/errors
 */
var constants = {
  /**
   * An unrecoverable error.
   * @constant
   * @default
   */
  FATAL: 'ERR_MOCHA_FATAL',

  /**
   * The type of an argument to a function call is invalid
   * @constant
   * @default
   */
  INVALID_ARG_TYPE: 'ERR_MOCHA_INVALID_ARG_TYPE',

  /**
   * The value of an argument to a function call is invalid
   * @constant
   * @default
   */
  INVALID_ARG_VALUE: 'ERR_MOCHA_INVALID_ARG_VALUE',

  /**
   * Something was thrown, but it wasn't an `Error`
   * @constant
   * @default
   */
  INVALID_EXCEPTION: 'ERR_MOCHA_INVALID_EXCEPTION',

  /**
   * An interface (e.g., `Mocha.interfaces`) is unknown or invalid
   * @constant
   * @default
   */
  INVALID_INTERFACE: 'ERR_MOCHA_INVALID_INTERFACE',

  /**
   * A reporter (.e.g, `Mocha.reporters`) is unknown or invalid
   * @constant
   * @default
   */
  INVALID_REPORTER: 'ERR_MOCHA_INVALID_REPORTER',

  /**
   * `done()` was called twice in a `Test` or `Hook` callback
   * @constant
   * @default
   */
  MULTIPLE_DONE: 'ERR_MOCHA_MULTIPLE_DONE',

  /**
   * No files matched the pattern provided by the user
   * @constant
   * @default
   */
  NO_FILES_MATCH_PATTERN: 'ERR_MOCHA_NO_FILES_MATCH_PATTERN',

  /**
   * Known, but unsupported behavior of some kind
   * @constant
   * @default
   */
  UNSUPPORTED: 'ERR_MOCHA_UNSUPPORTED',

  /**
   * Invalid state transition occurring in `Mocha` instance
   * @constant
   * @default
   */
  INSTANCE_ALREADY_RUNNING: 'ERR_MOCHA_INSTANCE_ALREADY_RUNNING',

  /**
   * Invalid state transition occurring in `Mocha` instance
   * @constant
   * @default
   */
  INSTANCE_ALREADY_DISPOSED: 'ERR_MOCHA_INSTANCE_ALREADY_DISPOSED',

  /**
   * Use of `only()` w/ `--forbid-only` results in this error.
   * @constant
   * @default
   */
  FORBIDDEN_EXCLUSIVITY: 'ERR_MOCHA_FORBIDDEN_EXCLUSIVITY',

  /**
   * To be thrown when a user-defined plugin implementation (e.g., `mochaHooks`) is invalid
   * @constant
   * @default
   */
  INVALID_PLUGIN_IMPLEMENTATION: 'ERR_MOCHA_INVALID_PLUGIN_IMPLEMENTATION',

  /**
   * To be thrown when a builtin or third-party plugin definition (the _definition_ of `mochaHooks`) is invalid
   * @constant
   * @default
   */
  INVALID_PLUGIN_DEFINITION: 'ERR_MOCHA_INVALID_PLUGIN_DEFINITION',

  /**
   * When a runnable exceeds its allowed run time.
   * @constant
   * @default
   */
  TIMEOUT: 'ERR_MOCHA_TIMEOUT',

  /**
   * Input file is not able to be parsed
   * @constant
   * @default
   */
  UNPARSABLE_FILE: 'ERR_MOCHA_UNPARSABLE_FILE'
};

/**
 * A set containing all string values of all Mocha error constants, for use by {@link isMochaError}.
 * @private
 */
const MOCHA_ERRORS = new Set(Object.values(constants));

/**
 * Creates an error object to be thrown when no files to be tested could be found using specified pattern.
 *
 * @public
 * @static
 * @param {string} message - Error message to be displayed.
 * @param {string} pattern - User-specified argument value.
 * @returns {Error} instance detailing the error condition
 */
function createNoFilesMatchPatternError(message, pattern) {
  var err = new Error(message);
  err.code = constants.NO_FILES_MATCH_PATTERN;
  err.pattern = pattern;
  return err;
}

/**
 * Creates an error object to be thrown when the reporter specified in the options was not found.
 *
 * @public
 * @param {string} message - Error message to be displayed.
 * @param {string} reporter - User-specified reporter value.
 * @returns {Error} instance detailing the error condition
 */
function createInvalidReporterError(message, reporter) {
  var err = new TypeError(message);
  err.code = constants.INVALID_REPORTER;
  err.reporter = reporter;
  return err;
}

/**
 * Creates an error object to be thrown when the interface specified in the options was not found.
 *
 * @public
 * @static
 * @param {string} message - Error message to be displayed.
 * @param {string} ui - User-specified interface value.
 * @returns {Error} instance detailing the error condition
 */
function createInvalidInterfaceError(message, ui) {
  var err = new Error(message);
  err.code = constants.INVALID_INTERFACE;
  err.interface = ui;
  return err;
}

/**
 * Creates an error object to be thrown when a behavior, option, or parameter is unsupported.
 *
 * @public
 * @static
 * @param {string} message - Error message to be displayed.
 * @returns {Error} instance detailing the error condition
 */
function createUnsupportedError(message) {
  var err = new Error(message);
  err.code = constants.UNSUPPORTED;
  return err;
}

/**
 * Creates an error object to be thrown when an argument is missing.
 *
 * @public
 * @static
 * @param {string} message - Error message to be displayed.
 * @param {string} argument - Argument name.
 * @param {string} expected - Expected argument datatype.
 * @returns {Error} instance detailing the error condition
 */
function createMissingArgumentError(message, argument, expected) {
  return createInvalidArgumentTypeError(message, argument, expected);
}

/**
 * Creates an error object to be thrown when an argument did not use the supported type
 *
 * @public
 * @static
 * @param {string} message - Error message to be displayed.
 * @param {string} argument - Argument name.
 * @param {string} expected - Expected argument datatype.
 * @returns {Error} instance detailing the error condition
 */
function createInvalidArgumentTypeError(message, argument, expected) {
  var err = new TypeError(message);
  err.code = constants.INVALID_ARG_TYPE;
  err.argument = argument;
  err.expected = expected;
  err.actual = typeof argument;
  return err;
}

/**
 * Creates an error object to be thrown when an argument did not use the supported value
 *
 * @public
 * @static
 * @param {string} message - Error message to be displayed.
 * @param {string} argument - Argument name.
 * @param {string} value - Argument value.
 * @param {string} [reason] - Why value is invalid.
 * @returns {Error} instance detailing the error condition
 */
function createInvalidArgumentValueError(message, argument, value, reason) {
  var err = new TypeError(message);
  err.code = constants.INVALID_ARG_VALUE;
  err.argument = argument;
  err.value = value;
  err.reason = typeof reason !== 'undefined' ? reason : 'is invalid';
  return err;
}

/**
 * Creates an error object to be thrown when an exception was caught, but the `Error` is falsy or undefined.
 *
 * @public
 * @static
 * @param {string} message - Error message to be displayed.
 * @returns {Error} instance detailing the error condition
 */
function createInvalidExceptionError(message, value) {
  var err = new Error(message);
  err.code = constants.INVALID_EXCEPTION;
  err.valueType = typeof value;
  err.value = value;
  return err;
}

/**
 * Creates an error object to be thrown when an unrecoverable error occurs.
 *
 * @public
 * @static
 * @param {string} message - Error message to be displayed.
 * @returns {Error} instance detailing the error condition
 */
function createFatalError(message, value) {
  var err = new Error(message);
  err.code = constants.FATAL;
  err.valueType = typeof value;
  err.value = value;
  return err;
}

/**
 * Dynamically creates a plugin-type-specific error based on plugin type
 * @param {string} message - Error message
 * @param {"reporter"|"ui"} pluginType - Plugin type. Future: expand as needed
 * @param {string} [pluginId] - Name/path of plugin, if any
 * @throws When `pluginType` is not known
 * @public
 * @static
 * @returns {Error}
 */
function createInvalidLegacyPluginError(message, pluginType, pluginId) {
  switch (pluginType) {
    case 'reporter':
      return createInvalidReporterError(message, pluginId);
    case 'ui':
      return createInvalidInterfaceError(message, pluginId);
    default:
      throw new Error('unknown pluginType "' + pluginType + '"');
  }
}

/**
 * **DEPRECATED**.  Use {@link createInvalidLegacyPluginError} instead  Dynamically creates a plugin-type-specific error based on plugin type
 * @deprecated
 * @param {string} message - Error message
 * @param {"reporter"|"interface"} pluginType - Plugin type. Future: expand as needed
 * @param {string} [pluginId] - Name/path of plugin, if any
 * @throws When `pluginType` is not known
 * @public
 * @static
 * @returns {Error}
 */
function createInvalidPluginError(...args) {
  deprecate('Use createInvalidLegacyPluginError() instead');
  return createInvalidLegacyPluginError(...args);
}

/**
 * Creates an error object to be thrown when a mocha object's `run` method is executed while it is already disposed.
 * @param {string} message The error message to be displayed.
 * @param {boolean} cleanReferencesAfterRun the value of `cleanReferencesAfterRun`
 * @param {Mocha} instance the mocha instance that throw this error
 * @static
 */
function createMochaInstanceAlreadyDisposedError(
  message,
  cleanReferencesAfterRun,
  instance
) {
  var err = new Error(message);
  err.code = constants.INSTANCE_ALREADY_DISPOSED;
  err.cleanReferencesAfterRun = cleanReferencesAfterRun;
  err.instance = instance;
  return err;
}

/**
 * Creates an error object to be thrown when a mocha object's `run` method is called while a test run is in progress.
 * @param {string} message The error message to be displayed.
 * @static
 * @public
 */
function createMochaInstanceAlreadyRunningError(message, instance) {
  var err = new Error(message);
  err.code = constants.INSTANCE_ALREADY_RUNNING;
  err.instance = instance;
  return err;
}

/**
 * Creates an error object to be thrown when done() is called multiple times in a test
 *
 * @public
 * @param {Runnable} runnable - Original runnable
 * @param {Error} [originalErr] - Original error, if any
 * @returns {Error} instance detailing the error condition
 * @static
 */
function createMultipleDoneError(runnable, originalErr) {
  var title;
  try {
    title = format('<%s>', runnable.fullTitle());
    if (runnable.parent.root) {
      title += ' (of root suite)';
    }
  } catch (ignored) {
    title = format('<%s> (of unknown suite)', runnable.title);
  }
  var message = format(
    'done() called multiple times in %s %s',
    runnable.type ? runnable.type : 'unknown runnable',
    title
  );
  if (runnable.file) {
    message += format(' of file %s', runnable.file);
  }
  if (originalErr) {
    message += format('; in addition, done() received error: %s', originalErr);
  }

  var err = new Error(message);
  err.code = constants.MULTIPLE_DONE;
  err.valueType = typeof originalErr;
  err.value = originalErr;
  return err;
}

/**
 * Creates an error object to be thrown when `.only()` is used with
 * `--forbid-only`.
 * @static
 * @public
 * @param {Mocha} mocha - Mocha instance
 * @returns {Error} Error with code {@link constants.FORBIDDEN_EXCLUSIVITY}
 */
function createForbiddenExclusivityError(mocha) {
  var err = new Error(
    mocha.isWorker
      ? '`.only` is not supported in parallel mode'
      : '`.only` forbidden by --forbid-only'
  );
  err.code = constants.FORBIDDEN_EXCLUSIVITY;
  return err;
}

/**
 * Creates an error object to be thrown when a plugin definition is invalid
 * @static
 * @param {string} msg - Error message
 * @param {PluginDefinition} [pluginDef] - Problematic plugin definition
 * @public
 * @returns {Error} Error with code {@link constants.INVALID_PLUGIN_DEFINITION}
 */
function createInvalidPluginDefinitionError(msg, pluginDef) {
  const err = new Error(msg);
  err.code = constants.INVALID_PLUGIN_DEFINITION;
  err.pluginDef = pluginDef;
  return err;
}

/**
 * Creates an error object to be thrown when a plugin implementation (user code) is invalid
 * @static
 * @param {string} msg - Error message
 * @param {Object} [opts] - Plugin definition and user-supplied implementation
 * @param {PluginDefinition} [opts.pluginDef] - Plugin Definition
 * @param {*} [opts.pluginImpl] - Plugin Implementation (user-supplied)
 * @public
 * @returns {Error} Error with code {@link constants.INVALID_PLUGIN_DEFINITION}
 */
function createInvalidPluginImplementationError(
  msg,
  {pluginDef, pluginImpl} = {}
) {
  const err = new Error(msg);
  err.code = constants.INVALID_PLUGIN_IMPLEMENTATION;
  err.pluginDef = pluginDef;
  err.pluginImpl = pluginImpl;
  return err;
}

/**
 * Creates an error object to be thrown when a runnable exceeds its allowed run time.
 * @static
 * @param {string} msg - Error message
 * @param {number} [timeout] - Timeout in ms
 * @param {string} [file] - File, if given
 * @returns {MochaTimeoutError}
 */
function createTimeoutError(msg, timeout, file) {
  const err = new Error(msg);
  err.code = constants.TIMEOUT;
  err.timeout = timeout;
  err.file = file;
  return err;
}

/**
 * Creates an error object to be thrown when file is unparsable
 * @public
 * @static
 * @param {string} message - Error message to be displayed.
 * @param {string} filename - File name
 * @returns {Error} Error with code {@link constants.UNPARSABLE_FILE}
 */
function createUnparsableFileError(message, filename) {
  var err = new Error(message);
  err.code = constants.UNPARSABLE_FILE;
  return err;
}

/**
 * Returns `true` if an error came out of Mocha.
 * _Can suffer from false negatives, but not false positives._
 * @static
 * @public
 * @param {*} err - Error, or anything
 * @returns {boolean}
 */
const isMochaError = err =>
  Boolean(err && typeof err === 'object' && MOCHA_ERRORS.has(err.code));

module.exports = {
  constants,
  createFatalError,
  createForbiddenExclusivityError,
  createInvalidArgumentTypeError,
  createInvalidArgumentValueError,
  createInvalidExceptionError,
  createInvalidInterfaceError,
  createInvalidLegacyPluginError,
  createInvalidPluginDefinitionError,
  createInvalidPluginError,
  createInvalidPluginImplementationError,
  createInvalidReporterError,
  createMissingArgumentError,
  createMochaInstanceAlreadyDisposedError,
  createMochaInstanceAlreadyRunningError,
  createMultipleDoneError,
  createNoFilesMatchPatternError,
  createTimeoutError,
  createUnparsableFileError,
  createUnsupportedError,
  deprecate,
  isMochaError,
  warn
};

/**
 * The error thrown when a Runnable times out
 * @memberof module:lib/errors
 * @typedef {Error} MochaTimeoutError
 * @property {constants.TIMEOUT} code - Error code
 * @property {number?} timeout Timeout in ms
 * @property {string?} file Filepath, if given
 */

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mocha/lib/hook.js":
/*!****************************************!*\
  !*** ./node_modules/mocha/lib/hook.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Runnable = __webpack_require__(/*! ./runnable */ "./node_modules/mocha/lib/runnable.js");
const {inherits, constants} = __webpack_require__(/*! ./utils */ "./node_modules/mocha/lib/utils.js");
const {MOCHA_ID_PROP_NAME} = constants;

/**
 * Expose `Hook`.
 */

module.exports = Hook;

/**
 * Initialize a new `Hook` with the given `title` and callback `fn`
 *
 * @class
 * @extends Runnable
 * @param {String} title
 * @param {Function} fn
 */
function Hook(title, fn) {
  Runnable.call(this, title, fn);
  this.type = 'hook';
}

/**
 * Inherit from `Runnable.prototype`.
 */
inherits(Hook, Runnable);

/**
 * Resets the state for a next run.
 */
Hook.prototype.reset = function () {
  Runnable.prototype.reset.call(this);
  delete this._error;
};

/**
 * Get or set the test `err`.
 *
 * @memberof Hook
 * @public
 * @param {Error} err
 * @return {Error}
 */
Hook.prototype.error = function (err) {
  if (!arguments.length) {
    err = this._error;
    this._error = null;
    return err;
  }

  this._error = err;
};

/**
 * Returns an object suitable for IPC.
 * Functions are represented by keys beginning with `$$`.
 * @private
 * @returns {Object}
 */
Hook.prototype.serialize = function serialize() {
  return {
    $$currentRetry: this.currentRetry(),
    $$fullTitle: this.fullTitle(),
    $$isPending: Boolean(this.isPending()),
    $$titlePath: this.titlePath(),
    ctx:
      this.ctx && this.ctx.currentTest
        ? {
            currentTest: {
              title: this.ctx.currentTest.title,
              [MOCHA_ID_PROP_NAME]: this.ctx.currentTest.id
            }
          }
        : {},
    duration: this.duration,
    file: this.file,
    parent: {
      $$fullTitle: this.parent.fullTitle(),
      [MOCHA_ID_PROP_NAME]: this.parent.id
    },
    state: this.state,
    title: this.title,
    type: this.type,
    [MOCHA_ID_PROP_NAME]: this.id
  };
};


/***/ }),

/***/ "./node_modules/mocha/lib/interfaces/bdd.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/interfaces/bdd.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Test = __webpack_require__(/*! ../test */ "./node_modules/mocha/lib/test.js");
var EVENT_FILE_PRE_REQUIRE =
  __webpack_require__(/*! ../suite */ "./node_modules/mocha/lib/suite.js").constants.EVENT_FILE_PRE_REQUIRE;

/**
 * BDD-style interface:
 *
 *      describe('Array', function() {
 *        describe('#indexOf()', function() {
 *          it('should return -1 when not present', function() {
 *            // ...
 *          });
 *
 *          it('should return the index when present', function() {
 *            // ...
 *          });
 *        });
 *      });
 *
 * @param {Suite} suite Root suite.
 */
module.exports = function bddInterface(suite) {
  var suites = [suite];

  suite.on(EVENT_FILE_PRE_REQUIRE, function (context, file, mocha) {
    var common = __webpack_require__(/*! ./common */ "./node_modules/mocha/lib/interfaces/common.js")(suites, context, mocha);

    context.before = common.before;
    context.after = common.after;
    context.beforeEach = common.beforeEach;
    context.afterEach = common.afterEach;
    context.run = mocha.options.delay && common.runWithSuite(suite);
    /**
     * Describe a "suite" with the given `title`
     * and callback `fn` containing nested suites
     * and/or tests.
     */

    context.describe = context.context = function (title, fn) {
      return common.suite.create({
        title: title,
        file: file,
        fn: fn
      });
    };

    /**
     * Pending describe.
     */

    context.xdescribe =
      context.xcontext =
      context.describe.skip =
        function (title, fn) {
          return common.suite.skip({
            title: title,
            file: file,
            fn: fn
          });
        };

    /**
     * Exclusive suite.
     */

    context.describe.only = function (title, fn) {
      return common.suite.only({
        title: title,
        file: file,
        fn: fn
      });
    };

    /**
     * Describe a specification or test-case
     * with the given `title` and callback `fn`
     * acting as a thunk.
     */

    context.it = context.specify = function (title, fn) {
      var suite = suites[0];
      if (suite.isPending()) {
        fn = null;
      }
      var test = new Test(title, fn);
      test.file = file;
      suite.addTest(test);
      return test;
    };

    /**
     * Exclusive test-case.
     */

    context.it.only = function (title, fn) {
      return common.test.only(mocha, context.it(title, fn));
    };

    /**
     * Pending test case.
     */

    context.xit =
      context.xspecify =
      context.it.skip =
        function (title) {
          return context.it(title);
        };
  });
};

module.exports.description = 'BDD or RSpec style [default]';


/***/ }),

/***/ "./node_modules/mocha/lib/interfaces/common.js":
/*!*****************************************************!*\
  !*** ./node_modules/mocha/lib/interfaces/common.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 @module interfaces/common
*/

var Suite = __webpack_require__(/*! ../suite */ "./node_modules/mocha/lib/suite.js");
var errors = __webpack_require__(/*! ../errors */ "./node_modules/mocha/lib/errors.js");
var createMissingArgumentError = errors.createMissingArgumentError;
var createUnsupportedError = errors.createUnsupportedError;
var createForbiddenExclusivityError = errors.createForbiddenExclusivityError;

/**
 * Functions common to more than one interface.
 *
 * @private
 * @param {Suite[]} suites
 * @param {Context} context
 * @param {Mocha} mocha
 * @return {Object} An object containing common functions.
 */
module.exports = function (suites, context, mocha) {
  /**
   * Check if the suite should be tested.
   *
   * @private
   * @param {Suite} suite - suite to check
   * @returns {boolean}
   */
  function shouldBeTested(suite) {
    return (
      !mocha.options.grep ||
      (mocha.options.grep &&
        mocha.options.grep.test(suite.fullTitle()) &&
        !mocha.options.invert)
    );
  }

  return {
    /**
     * This is only present if flag --delay is passed into Mocha. It triggers
     * root suite execution.
     *
     * @param {Suite} suite The root suite.
     * @return {Function} A function which runs the root suite
     */
    runWithSuite: function runWithSuite(suite) {
      return function run() {
        suite.run();
      };
    },

    /**
     * Execute before running tests.
     *
     * @param {string} name
     * @param {Function} fn
     */
    before: function (name, fn) {
      suites[0].beforeAll(name, fn);
    },

    /**
     * Execute after running tests.
     *
     * @param {string} name
     * @param {Function} fn
     */
    after: function (name, fn) {
      suites[0].afterAll(name, fn);
    },

    /**
     * Execute before each test case.
     *
     * @param {string} name
     * @param {Function} fn
     */
    beforeEach: function (name, fn) {
      suites[0].beforeEach(name, fn);
    },

    /**
     * Execute after each test case.
     *
     * @param {string} name
     * @param {Function} fn
     */
    afterEach: function (name, fn) {
      suites[0].afterEach(name, fn);
    },

    suite: {
      /**
       * Create an exclusive Suite; convenience function
       * See docstring for create() below.
       *
       * @param {Object} opts
       * @returns {Suite}
       */
      only: function only(opts) {
        if (mocha.options.forbidOnly) {
          throw createForbiddenExclusivityError(mocha);
        }
        opts.isOnly = true;
        return this.create(opts);
      },

      /**
       * Create a Suite, but skip it; convenience function
       * See docstring for create() below.
       *
       * @param {Object} opts
       * @returns {Suite}
       */
      skip: function skip(opts) {
        opts.pending = true;
        return this.create(opts);
      },

      /**
       * Creates a suite.
       *
       * @param {Object} opts Options
       * @param {string} opts.title Title of Suite
       * @param {Function} [opts.fn] Suite Function (not always applicable)
       * @param {boolean} [opts.pending] Is Suite pending?
       * @param {string} [opts.file] Filepath where this Suite resides
       * @param {boolean} [opts.isOnly] Is Suite exclusive?
       * @returns {Suite}
       */
      create: function create(opts) {
        var suite = Suite.create(suites[0], opts.title);
        suite.pending = Boolean(opts.pending);
        suite.file = opts.file;
        suites.unshift(suite);
        if (opts.isOnly) {
          suite.markOnly();
        }
        if (
          suite.pending &&
          mocha.options.forbidPending &&
          shouldBeTested(suite)
        ) {
          throw createUnsupportedError('Pending test forbidden');
        }
        if (typeof opts.fn === 'function') {
          opts.fn.call(suite);
          suites.shift();
        } else if (typeof opts.fn === 'undefined' && !suite.pending) {
          throw createMissingArgumentError(
            'Suite "' +
              suite.fullTitle() +
              '" was defined but no callback was supplied. ' +
              'Supply a callback or explicitly skip the suite.',
            'callback',
            'function'
          );
        } else if (!opts.fn && suite.pending) {
          suites.shift();
        }

        return suite;
      }
    },

    test: {
      /**
       * Exclusive test-case.
       *
       * @param {Object} mocha
       * @param {Function} test
       * @returns {*}
       */
      only: function (mocha, test) {
        if (mocha.options.forbidOnly) {
          throw createForbiddenExclusivityError(mocha);
        }
        test.markOnly();
        return test;
      },

      /**
       * Pending test case.
       *
       * @param {string} title
       */
      skip: function (title) {
        context.test(title);
      }
    }
  };
};


/***/ }),

/***/ "./node_modules/mocha/lib/interfaces/exports.js":
/*!******************************************************!*\
  !*** ./node_modules/mocha/lib/interfaces/exports.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Suite = __webpack_require__(/*! ../suite */ "./node_modules/mocha/lib/suite.js");
var Test = __webpack_require__(/*! ../test */ "./node_modules/mocha/lib/test.js");

/**
 * Exports-style (as Node.js module) interface:
 *
 *     exports.Array = {
 *       '#indexOf()': {
 *         'should return -1 when the value is not present': function() {
 *
 *         },
 *
 *         'should return the correct index when the value is present': function() {
 *
 *         }
 *       }
 *     };
 *
 * @param {Suite} suite Root suite.
 */
module.exports = function (suite) {
  var suites = [suite];

  suite.on(Suite.constants.EVENT_FILE_REQUIRE, visit);

  function visit(obj, file) {
    var suite;
    for (var key in obj) {
      if (typeof obj[key] === 'function') {
        var fn = obj[key];
        switch (key) {
          case 'before':
            suites[0].beforeAll(fn);
            break;
          case 'after':
            suites[0].afterAll(fn);
            break;
          case 'beforeEach':
            suites[0].beforeEach(fn);
            break;
          case 'afterEach':
            suites[0].afterEach(fn);
            break;
          default:
            var test = new Test(key, fn);
            test.file = file;
            suites[0].addTest(test);
        }
      } else {
        suite = Suite.create(suites[0], key);
        suites.unshift(suite);
        visit(obj[key], file);
        suites.shift();
      }
    }
  }
};

module.exports.description = 'Node.js module ("exports") style';


/***/ }),

/***/ "./node_modules/mocha/lib/interfaces/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mocha/lib/interfaces/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.bdd = __webpack_require__(/*! ./bdd */ "./node_modules/mocha/lib/interfaces/bdd.js");
exports.tdd = __webpack_require__(/*! ./tdd */ "./node_modules/mocha/lib/interfaces/tdd.js");
exports.qunit = __webpack_require__(/*! ./qunit */ "./node_modules/mocha/lib/interfaces/qunit.js");
exports.exports = __webpack_require__(/*! ./exports */ "./node_modules/mocha/lib/interfaces/exports.js");


/***/ }),

/***/ "./node_modules/mocha/lib/interfaces/qunit.js":
/*!****************************************************!*\
  !*** ./node_modules/mocha/lib/interfaces/qunit.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Test = __webpack_require__(/*! ../test */ "./node_modules/mocha/lib/test.js");
var EVENT_FILE_PRE_REQUIRE =
  __webpack_require__(/*! ../suite */ "./node_modules/mocha/lib/suite.js").constants.EVENT_FILE_PRE_REQUIRE;

/**
 * QUnit-style interface:
 *
 *     suite('Array');
 *
 *     test('#length', function() {
 *       var arr = [1,2,3];
 *       ok(arr.length == 3);
 *     });
 *
 *     test('#indexOf()', function() {
 *       var arr = [1,2,3];
 *       ok(arr.indexOf(1) == 0);
 *       ok(arr.indexOf(2) == 1);
 *       ok(arr.indexOf(3) == 2);
 *     });
 *
 *     suite('String');
 *
 *     test('#length', function() {
 *       ok('foo'.length == 3);
 *     });
 *
 * @param {Suite} suite Root suite.
 */
module.exports = function qUnitInterface(suite) {
  var suites = [suite];

  suite.on(EVENT_FILE_PRE_REQUIRE, function (context, file, mocha) {
    var common = __webpack_require__(/*! ./common */ "./node_modules/mocha/lib/interfaces/common.js")(suites, context, mocha);

    context.before = common.before;
    context.after = common.after;
    context.beforeEach = common.beforeEach;
    context.afterEach = common.afterEach;
    context.run = mocha.options.delay && common.runWithSuite(suite);
    /**
     * Describe a "suite" with the given `title`.
     */

    context.suite = function (title) {
      if (suites.length > 1) {
        suites.shift();
      }
      return common.suite.create({
        title: title,
        file: file,
        fn: false
      });
    };

    /**
     * Exclusive Suite.
     */

    context.suite.only = function (title) {
      if (suites.length > 1) {
        suites.shift();
      }
      return common.suite.only({
        title: title,
        file: file,
        fn: false
      });
    };

    /**
     * Describe a specification or test-case
     * with the given `title` and callback `fn`
     * acting as a thunk.
     */

    context.test = function (title, fn) {
      var test = new Test(title, fn);
      test.file = file;
      suites[0].addTest(test);
      return test;
    };

    /**
     * Exclusive test-case.
     */

    context.test.only = function (title, fn) {
      return common.test.only(mocha, context.test(title, fn));
    };

    context.test.skip = common.test.skip;
  });
};

module.exports.description = 'QUnit style';


/***/ }),

/***/ "./node_modules/mocha/lib/interfaces/tdd.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/interfaces/tdd.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Test = __webpack_require__(/*! ../test */ "./node_modules/mocha/lib/test.js");
var EVENT_FILE_PRE_REQUIRE =
  __webpack_require__(/*! ../suite */ "./node_modules/mocha/lib/suite.js").constants.EVENT_FILE_PRE_REQUIRE;

/**
 * TDD-style interface:
 *
 *      suite('Array', function() {
 *        suite('#indexOf()', function() {
 *          suiteSetup(function() {
 *
 *          });
 *
 *          test('should return -1 when not present', function() {
 *
 *          });
 *
 *          test('should return the index when present', function() {
 *
 *          });
 *
 *          suiteTeardown(function() {
 *
 *          });
 *        });
 *      });
 *
 * @param {Suite} suite Root suite.
 */
module.exports = function (suite) {
  var suites = [suite];

  suite.on(EVENT_FILE_PRE_REQUIRE, function (context, file, mocha) {
    var common = __webpack_require__(/*! ./common */ "./node_modules/mocha/lib/interfaces/common.js")(suites, context, mocha);

    context.setup = common.beforeEach;
    context.teardown = common.afterEach;
    context.suiteSetup = common.before;
    context.suiteTeardown = common.after;
    context.run = mocha.options.delay && common.runWithSuite(suite);

    /**
     * Describe a "suite" with the given `title` and callback `fn` containing
     * nested suites and/or tests.
     */
    context.suite = function (title, fn) {
      return common.suite.create({
        title: title,
        file: file,
        fn: fn
      });
    };

    /**
     * Pending suite.
     */
    context.suite.skip = function (title, fn) {
      return common.suite.skip({
        title: title,
        file: file,
        fn: fn
      });
    };

    /**
     * Exclusive test-case.
     */
    context.suite.only = function (title, fn) {
      return common.suite.only({
        title: title,
        file: file,
        fn: fn
      });
    };

    /**
     * Describe a specification or test-case with the given `title` and
     * callback `fn` acting as a thunk.
     */
    context.test = function (title, fn) {
      var suite = suites[0];
      if (suite.isPending()) {
        fn = null;
      }
      var test = new Test(title, fn);
      test.file = file;
      suite.addTest(test);
      return test;
    };

    /**
     * Exclusive test-case.
     */

    context.test.only = function (title, fn) {
      return common.test.only(mocha, context.test(title, fn));
    };

    context.test.skip = common.test.skip;
  });
};

module.exports.description =
  'traditional "suite"/"test" instead of BDD\'s "describe"/"it"';


/***/ }),

/***/ "./node_modules/mocha/lib/mocha.js":
/*!*****************************************!*\
  !*** ./node_modules/mocha/lib/mocha.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {

/*!
 * mocha
 * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

var escapeRe = __webpack_require__(/*! escape-string-regexp */ "./node_modules/mocha/node_modules/escape-string-regexp/index.js");
var path = __webpack_require__(/*! path */ 3);
var builtinReporters = __webpack_require__(/*! ./reporters */ "./node_modules/mocha/lib/reporters/index.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/mocha/lib/utils.js");
var mocharc = __webpack_require__(/*! ./mocharc.json */ "./node_modules/mocha/lib/mocharc.json");
var Suite = __webpack_require__(/*! ./suite */ "./node_modules/mocha/lib/suite.js");
var esmUtils = __webpack_require__(/*! ./nodejs/esm-utils */ 6);
var createStatsCollector = __webpack_require__(/*! ./stats-collector */ "./node_modules/mocha/lib/stats-collector.js");
const {
  createInvalidReporterError,
  createInvalidInterfaceError,
  createMochaInstanceAlreadyDisposedError,
  createMochaInstanceAlreadyRunningError,
  createUnsupportedError
} = __webpack_require__(/*! ./errors */ "./node_modules/mocha/lib/errors.js");
const {EVENT_FILE_PRE_REQUIRE, EVENT_FILE_POST_REQUIRE, EVENT_FILE_REQUIRE} =
  Suite.constants;
var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('mocha:mocha');

exports = module.exports = Mocha;

/**
 * A Mocha instance is a finite state machine.
 * These are the states it can be in.
 * @private
 */
var mochaStates = utils.defineConstants({
  /**
   * Initial state of the mocha instance
   * @private
   */
  INIT: 'init',
  /**
   * Mocha instance is running tests
   * @private
   */
  RUNNING: 'running',
  /**
   * Mocha instance is done running tests and references to test functions and hooks are cleaned.
   * You can reset this state by unloading the test files.
   * @private
   */
  REFERENCES_CLEANED: 'referencesCleaned',
  /**
   * Mocha instance is disposed and can no longer be used.
   * @private
   */
  DISPOSED: 'disposed'
});

/**
 * To require local UIs and reporters when running in node.
 */

if (!utils.isBrowser() && typeof module.paths !== 'undefined') {
  var cwd = utils.cwd();
  module.paths.push(cwd, path.join(cwd, 'node_modules'));
}

/**
 * Expose internals.
 * @private
 */

exports.utils = utils;
exports.interfaces = __webpack_require__(/*! ./interfaces */ "./node_modules/mocha/lib/interfaces/index.js");
/**
 * @public
 * @memberof Mocha
 */
exports.reporters = builtinReporters;
exports.Runnable = __webpack_require__(/*! ./runnable */ "./node_modules/mocha/lib/runnable.js");
exports.Context = __webpack_require__(/*! ./context */ "./node_modules/mocha/lib/context.js");
/**
 *
 * @memberof Mocha
 */
exports.Runner = __webpack_require__(/*! ./runner */ "./node_modules/mocha/lib/runner.js");
exports.Suite = Suite;
exports.Hook = __webpack_require__(/*! ./hook */ "./node_modules/mocha/lib/hook.js");
exports.Test = __webpack_require__(/*! ./test */ "./node_modules/mocha/lib/test.js");

let currentContext;
exports.afterEach = function (...args) {
  return (currentContext.afterEach || currentContext.teardown).apply(
    this,
    args
  );
};
exports.after = function (...args) {
  return (currentContext.after || currentContext.suiteTeardown).apply(
    this,
    args
  );
};
exports.beforeEach = function (...args) {
  return (currentContext.beforeEach || currentContext.setup).apply(this, args);
};
exports.before = function (...args) {
  return (currentContext.before || currentContext.suiteSetup).apply(this, args);
};
exports.describe = function (...args) {
  return (currentContext.describe || currentContext.suite).apply(this, args);
};
exports.describe.only = function (...args) {
  return (currentContext.describe || currentContext.suite).only.apply(
    this,
    args
  );
};
exports.describe.skip = function (...args) {
  return (currentContext.describe || currentContext.suite).skip.apply(
    this,
    args
  );
};
exports.it = function (...args) {
  return (currentContext.it || currentContext.test).apply(this, args);
};
exports.it.only = function (...args) {
  return (currentContext.it || currentContext.test).only.apply(this, args);
};
exports.it.skip = function (...args) {
  return (currentContext.it || currentContext.test).skip.apply(this, args);
};
exports.xdescribe = exports.describe.skip;
exports.xit = exports.it.skip;
exports.setup = exports.beforeEach;
exports.suiteSetup = exports.before;
exports.suiteTeardown = exports.after;
exports.suite = exports.describe;
exports.teardown = exports.afterEach;
exports.test = exports.it;
exports.run = function (...args) {
  return currentContext.run.apply(this, args);
};

/**
 * Constructs a new Mocha instance with `options`.
 *
 * @public
 * @class Mocha
 * @param {Object} [options] - Settings object.
 * @param {boolean} [options.allowUncaught] - Propagate uncaught errors?
 * @param {boolean} [options.asyncOnly] - Force `done` callback or promise?
 * @param {boolean} [options.bail] - Bail after first test failure?
 * @param {boolean} [options.checkLeaks] - Check for global variable leaks?
 * @param {boolean} [options.color] - Color TTY output from reporter?
 * @param {boolean} [options.delay] - Delay root suite execution?
 * @param {boolean} [options.diff] - Show diff on failure?
 * @param {boolean} [options.dryRun] - Report tests without running them?
 * @param {boolean} [options.failZero] - Fail test run if zero tests?
 * @param {string} [options.fgrep] - Test filter given string.
 * @param {boolean} [options.forbidOnly] - Tests marked `only` fail the suite?
 * @param {boolean} [options.forbidPending] - Pending tests fail the suite?
 * @param {boolean} [options.fullTrace] - Full stacktrace upon failure?
 * @param {string[]} [options.global] - Variables expected in global scope.
 * @param {RegExp|string} [options.grep] - Test filter given regular expression.
 * @param {boolean} [options.inlineDiffs] - Display inline diffs?
 * @param {boolean} [options.invert] - Invert test filter matches?
 * @param {boolean} [options.noHighlighting] - Disable syntax highlighting?
 * @param {string|constructor} [options.reporter] - Reporter name or constructor.
 * @param {Object} [options.reporterOption] - Reporter settings object.
 * @param {number} [options.retries] - Number of times to retry failed tests.
 * @param {number} [options.slow] - Slow threshold value.
 * @param {number|string} [options.timeout] - Timeout threshold value.
 * @param {string} [options.ui] - Interface name.
 * @param {boolean} [options.parallel] - Run jobs in parallel.
 * @param {number} [options.jobs] - Max number of worker processes for parallel runs.
 * @param {MochaRootHookObject} [options.rootHooks] - Hooks to bootstrap the root suite with.
 * @param {string[]} [options.require] - Pathname of `rootHooks` plugin for parallel runs.
 * @param {boolean} [options.isWorker] - Should be `true` if `Mocha` process is running in a worker process.
 */
function Mocha(options = {}) {
  options = {...mocharc, ...options};
  this.files = [];
  this.options = options;
  // root suite
  this.suite = new exports.Suite('', new exports.Context(), true);
  this._cleanReferencesAfterRun = true;
  this._state = mochaStates.INIT;

  this.grep(options.grep)
    .fgrep(options.fgrep)
    .ui(options.ui)
    .reporter(
      options.reporter,
      options.reporterOption || options.reporterOptions // for backwards compatibility
    )
    .slow(options.slow)
    .global(options.global);

  // this guard exists because Suite#timeout does not consider `undefined` to be valid input
  if (typeof options.timeout !== 'undefined') {
    this.timeout(options.timeout === false ? 0 : options.timeout);
  }

  if ('retries' in options) {
    this.retries(options.retries);
  }

  [
    'allowUncaught',
    'asyncOnly',
    'bail',
    'checkLeaks',
    'color',
    'delay',
    'diff',
    'dryRun',
    'failZero',
    'forbidOnly',
    'forbidPending',
    'fullTrace',
    'inlineDiffs',
    'invert'
  ].forEach(function (opt) {
    if (options[opt]) {
      this[opt]();
    }
  }, this);

  if (options.rootHooks) {
    this.rootHooks(options.rootHooks);
  }

  /**
   * The class which we'll instantiate in {@link Mocha#run}.  Defaults to
   * {@link Runner} in serial mode; changes in parallel mode.
   * @memberof Mocha
   * @private
   */
  this._runnerClass = exports.Runner;

  /**
   * Whether or not to call {@link Mocha#loadFiles} implicitly when calling
   * {@link Mocha#run}.  If this is `true`, then it's up to the consumer to call
   * {@link Mocha#loadFiles} _or_ {@link Mocha#loadFilesAsync}.
   * @private
   * @memberof Mocha
   */
  this._lazyLoadFiles = false;

  /**
   * It's useful for a Mocha instance to know if it's running in a worker process.
   * We could derive this via other means, but it's helpful to have a flag to refer to.
   * @memberof Mocha
   * @private
   */
  this.isWorker = Boolean(options.isWorker);

  this.globalSetup(options.globalSetup)
    .globalTeardown(options.globalTeardown)
    .enableGlobalSetup(options.enableGlobalSetup)
    .enableGlobalTeardown(options.enableGlobalTeardown);

  if (
    options.parallel &&
    (typeof options.jobs === 'undefined' || options.jobs > 1)
  ) {
    debug('attempting to enable parallel mode');
    this.parallelMode(true);
  }
}

/**
 * Enables or disables bailing on the first failure.
 *
 * @public
 * @see [CLI option](../#-bail-b)
 * @param {boolean} [bail=true] - Whether to bail on first error.
 * @returns {Mocha} this
 * @chainable
 */
Mocha.prototype.bail = function (bail) {
  this.suite.bail(bail !== false);
  return this;
};

/**
 * @summary
 * Adds `file` to be loaded for execution.
 *
 * @description
 * Useful for generic setup code that must be included within test suite.
 *
 * @public
 * @see [CLI option](../#-file-filedirectoryglob)
 * @param {string} file - Pathname of file to be loaded.
 * @returns {Mocha} this
 * @chainable
 */
Mocha.prototype.addFile = function (file) {
  this.files.push(file);
  return this;
};

/**
 * Sets reporter to `reporter`, defaults to "spec".
 *
 * @public
 * @see [CLI option](../#-reporter-name-r-name)
 * @see [Reporters](../#reporters)
 * @param {String|Function} reporterName - Reporter name or constructor.
 * @param {Object} [reporterOptions] - Options used to configure the reporter.
 * @returns {Mocha} this
 * @chainable
 * @throws {Error} if requested reporter cannot be loaded
 * @example
 *
 * // Use XUnit reporter and direct its output to file
 * mocha.reporter('xunit', { output: '/path/to/testspec.xunit.xml' });
 */
Mocha.prototype.reporter = function (reporterName, reporterOptions) {
  if (typeof reporterName === 'function') {
    this._reporter = reporterName;
  } else {
    reporterName = reporterName || 'spec';
    var reporter;
    // Try to load a built-in reporter.
    if (builtinReporters[reporterName]) {
      reporter = builtinReporters[reporterName];
    }
    // Try to load reporters from process.cwd() and node_modules
    if (!reporter) {
      let foundReporter;
      try {
        foundReporter = /*require.resolve*/(__webpack_require__("./node_modules/mocha/lib sync recursive").resolve(reporterName));
        reporter = __webpack_require__("./node_modules/mocha/lib sync recursive")(foundReporter);
      } catch (err) {
        if (foundReporter) {
          throw createInvalidReporterError(err.message, foundReporter);
        }
        // Try to load reporters from a cwd-relative path
        try {
          reporter = __webpack_require__("./node_modules/mocha/lib sync recursive")(path.resolve(reporterName));
        } catch (e) {
          throw createInvalidReporterError(e.message, reporterName);
        }
      }
    }
    this._reporter = reporter;
  }
  this.options.reporterOption = reporterOptions;
  // alias option name is used in built-in reporters xunit/tap/progress
  this.options.reporterOptions = reporterOptions;
  return this;
};

/**
 * Sets test UI `name`, defaults to "bdd".
 *
 * @public
 * @see [CLI option](../#-ui-name-u-name)
 * @see [Interface DSLs](../#interfaces)
 * @param {string|Function} [ui=bdd] - Interface name or class.
 * @returns {Mocha} this
 * @chainable
 * @throws {Error} if requested interface cannot be loaded
 */
Mocha.prototype.ui = function (ui) {
  var bindInterface;
  if (typeof ui === 'function') {
    bindInterface = ui;
  } else {
    ui = ui || 'bdd';
    bindInterface = exports.interfaces[ui];
    if (!bindInterface) {
      try {
        bindInterface = __webpack_require__("./node_modules/mocha/lib sync recursive")(ui);
      } catch (err) {
        throw createInvalidInterfaceError(`invalid interface '${ui}'`, ui);
      }
    }
  }
  bindInterface(this.suite);

  this.suite.on(EVENT_FILE_PRE_REQUIRE, function (context) {
    currentContext = context;
  });

  return this;
};

/**
 * Loads `files` prior to execution. Does not support ES Modules.
 *
 * @description
 * The implementation relies on Node's `require` to execute
 * the test interface functions and will be subject to its cache.
 * Supports only CommonJS modules. To load ES modules, use Mocha#loadFilesAsync.
 *
 * @private
 * @see {@link Mocha#addFile}
 * @see {@link Mocha#run}
 * @see {@link Mocha#unloadFiles}
 * @see {@link Mocha#loadFilesAsync}
 * @param {Function} [fn] - Callback invoked upon completion.
 */
Mocha.prototype.loadFiles = function (fn) {
  var self = this;
  var suite = this.suite;
  this.files.forEach(function (file) {
    file = path.resolve(file);
    suite.emit(EVENT_FILE_PRE_REQUIRE, global, file, self);
    suite.emit(EVENT_FILE_REQUIRE, __webpack_require__("./node_modules/mocha/lib sync recursive")(file), file, self);
    suite.emit(EVENT_FILE_POST_REQUIRE, global, file, self);
  });
  fn && fn();
};

/**
 * Loads `files` prior to execution. Supports Node ES Modules.
 *
 * @description
 * The implementation relies on Node's `require` and `import` to execute
 * the test interface functions and will be subject to its cache.
 * Supports both CJS and ESM modules.
 *
 * @public
 * @see {@link Mocha#addFile}
 * @see {@link Mocha#run}
 * @see {@link Mocha#unloadFiles}
 * @returns {Promise}
 * @example
 *
 * // loads ESM (and CJS) test files asynchronously, then runs root suite
 * mocha.loadFilesAsync()
 *   .then(() => mocha.run(failures => process.exitCode = failures ? 1 : 0))
 *   .catch(() => process.exitCode = 1);
 */
Mocha.prototype.loadFilesAsync = function () {
  var self = this;
  var suite = this.suite;
  this.lazyLoadFiles(true);

  return esmUtils.loadFilesAsync(
    this.files,
    function (file) {
      suite.emit(EVENT_FILE_PRE_REQUIRE, global, file, self);
    },
    function (file, resultModule) {
      suite.emit(EVENT_FILE_REQUIRE, resultModule, file, self);
      suite.emit(EVENT_FILE_POST_REQUIRE, global, file, self);
    }
  );
};

/**
 * Removes a previously loaded file from Node's `require` cache.
 *
 * @private
 * @static
 * @see {@link Mocha#unloadFiles}
 * @param {string} file - Pathname of file to be unloaded.
 */
Mocha.unloadFile = function (file) {
  if (utils.isBrowser()) {
    throw createUnsupportedError(
      'unloadFile() is only supported in a Node.js environment'
    );
  }
  return __webpack_require__(/*! ./nodejs/file-unloader */ 7).unloadFile(file);
};

/**
 * Unloads `files` from Node's `require` cache.
 *
 * @description
 * This allows required files to be "freshly" reloaded, providing the ability
 * to reuse a Mocha instance programmatically.
 * Note: does not clear ESM module files from the cache
 *
 * <strong>Intended for consumers &mdash; not used internally</strong>
 *
 * @public
 * @see {@link Mocha#run}
 * @returns {Mocha} this
 * @chainable
 */
Mocha.prototype.unloadFiles = function () {
  if (this._state === mochaStates.DISPOSED) {
    throw createMochaInstanceAlreadyDisposedError(
      'Mocha instance is already disposed, it cannot be used again.',
      this._cleanReferencesAfterRun,
      this
    );
  }

  this.files.forEach(function (file) {
    Mocha.unloadFile(file);
  });
  this._state = mochaStates.INIT;
  return this;
};

/**
 * Sets `grep` filter after escaping RegExp special characters.
 *
 * @public
 * @see {@link Mocha#grep}
 * @param {string} str - Value to be converted to a regexp.
 * @returns {Mocha} this
 * @chainable
 * @example
 *
 * // Select tests whose full title begins with `"foo"` followed by a period
 * mocha.fgrep('foo.');
 */
Mocha.prototype.fgrep = function (str) {
  if (!str) {
    return this;
  }
  return this.grep(new RegExp(escapeRe(str)));
};

/**
 * @summary
 * Sets `grep` filter used to select specific tests for execution.
 *
 * @description
 * If `re` is a regexp-like string, it will be converted to regexp.
 * The regexp is tested against the full title of each test (i.e., the
 * name of the test preceded by titles of each its ancestral suites).
 * As such, using an <em>exact-match</em> fixed pattern against the
 * test name itself will not yield any matches.
 * <br>
 * <strong>Previous filter value will be overwritten on each call!</strong>
 *
 * @public
 * @see [CLI option](../#-grep-regexp-g-regexp)
 * @see {@link Mocha#fgrep}
 * @see {@link Mocha#invert}
 * @param {RegExp|String} re - Regular expression used to select tests.
 * @return {Mocha} this
 * @chainable
 * @example
 *
 * // Select tests whose full title contains `"match"`, ignoring case
 * mocha.grep(/match/i);
 * @example
 *
 * // Same as above but with regexp-like string argument
 * mocha.grep('/match/i');
 * @example
 *
 * // ## Anti-example
 * // Given embedded test `it('only-this-test')`...
 * mocha.grep('/^only-this-test$/');    // NO! Use `.only()` to do this!
 */
Mocha.prototype.grep = function (re) {
  if (utils.isString(re)) {
    // extract args if it's regex-like, i.e: [string, pattern, flag]
    var arg = re.match(/^\/(.*)\/([gimy]{0,4})$|.*/);
    this.options.grep = new RegExp(arg[1] || arg[0], arg[2]);
  } else {
    this.options.grep = re;
  }
  return this;
};

/**
 * Inverts `grep` matches.
 *
 * @public
 * @see {@link Mocha#grep}
 * @return {Mocha} this
 * @chainable
 * @example
 *
 * // Select tests whose full title does *not* contain `"match"`, ignoring case
 * mocha.grep(/match/i).invert();
 */
Mocha.prototype.invert = function () {
  this.options.invert = true;
  return this;
};

/**
 * Enables or disables checking for global variables leaked while running tests.
 *
 * @public
 * @see [CLI option](../#-check-leaks)
 * @param {boolean} [checkLeaks=true] - Whether to check for global variable leaks.
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.checkLeaks = function (checkLeaks) {
  this.options.checkLeaks = checkLeaks !== false;
  return this;
};

/**
 * Enables or disables whether or not to dispose after each test run.
 * Disable this to ensure you can run the test suite multiple times.
 * If disabled, be sure to dispose mocha when you're done to prevent memory leaks.
 * @public
 * @see {@link Mocha#dispose}
 * @param {boolean} cleanReferencesAfterRun
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.cleanReferencesAfterRun = function (cleanReferencesAfterRun) {
  this._cleanReferencesAfterRun = cleanReferencesAfterRun !== false;
  return this;
};

/**
 * Manually dispose this mocha instance. Mark this instance as `disposed` and unable to run more tests.
 * It also removes function references to tests functions and hooks, so variables trapped in closures can be cleaned by the garbage collector.
 * @public
 */
Mocha.prototype.dispose = function () {
  if (this._state === mochaStates.RUNNING) {
    throw createMochaInstanceAlreadyRunningError(
      'Cannot dispose while the mocha instance is still running tests.'
    );
  }
  this.unloadFiles();
  this._previousRunner && this._previousRunner.dispose();
  this.suite.dispose();
  this._state = mochaStates.DISPOSED;
};

/**
 * Displays full stack trace upon test failure.
 *
 * @public
 * @see [CLI option](../#-full-trace)
 * @param {boolean} [fullTrace=true] - Whether to print full stacktrace upon failure.
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.fullTrace = function (fullTrace) {
  this.options.fullTrace = fullTrace !== false;
  return this;
};

/**
 * Specifies whitelist of variable names to be expected in global scope.
 *
 * @public
 * @see [CLI option](../#-global-variable-name)
 * @see {@link Mocha#checkLeaks}
 * @param {String[]|String} global - Accepted global variable name(s).
 * @return {Mocha} this
 * @chainable
 * @example
 *
 * // Specify variables to be expected in global scope
 * mocha.global(['jQuery', 'MyLib']);
 */
Mocha.prototype.global = function (global) {
  this.options.global = (this.options.global || [])
    .concat(global)
    .filter(Boolean)
    .filter(function (elt, idx, arr) {
      return arr.indexOf(elt) === idx;
    });
  return this;
};
// for backwards compatibility, 'globals' is an alias of 'global'
Mocha.prototype.globals = Mocha.prototype.global;

/**
 * Enables or disables TTY color output by screen-oriented reporters.
 *
 * @public
 * @see [CLI option](../#-color-c-colors)
 * @param {boolean} [color=true] - Whether to enable color output.
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.color = function (color) {
  this.options.color = color !== false;
  return this;
};

/**
 * Enables or disables reporter to use inline diffs (rather than +/-)
 * in test failure output.
 *
 * @public
 * @see [CLI option](../#-inline-diffs)
 * @param {boolean} [inlineDiffs=true] - Whether to use inline diffs.
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.inlineDiffs = function (inlineDiffs) {
  this.options.inlineDiffs = inlineDiffs !== false;
  return this;
};

/**
 * Enables or disables reporter to include diff in test failure output.
 *
 * @public
 * @see [CLI option](../#-diff)
 * @param {boolean} [diff=true] - Whether to show diff on failure.
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.diff = function (diff) {
  this.options.diff = diff !== false;
  return this;
};

/**
 * @summary
 * Sets timeout threshold value.
 *
 * @description
 * A string argument can use shorthand (such as "2s") and will be converted.
 * If the value is `0`, timeouts will be disabled.
 *
 * @public
 * @see [CLI option](../#-timeout-ms-t-ms)
 * @see [Timeouts](../#timeouts)
 * @param {number|string} msecs - Timeout threshold value.
 * @return {Mocha} this
 * @chainable
 * @example
 *
 * // Sets timeout to one second
 * mocha.timeout(1000);
 * @example
 *
 * // Same as above but using string argument
 * mocha.timeout('1s');
 */
Mocha.prototype.timeout = function (msecs) {
  this.suite.timeout(msecs);
  return this;
};

/**
 * Sets the number of times to retry failed tests.
 *
 * @public
 * @see [CLI option](../#-retries-n)
 * @see [Retry Tests](../#retry-tests)
 * @param {number} retry - Number of times to retry failed tests.
 * @return {Mocha} this
 * @chainable
 * @example
 *
 * // Allow any failed test to retry one more time
 * mocha.retries(1);
 */
Mocha.prototype.retries = function (retry) {
  this.suite.retries(retry);
  return this;
};

/**
 * Sets slowness threshold value.
 *
 * @public
 * @see [CLI option](../#-slow-ms-s-ms)
 * @param {number} msecs - Slowness threshold value.
 * @return {Mocha} this
 * @chainable
 * @example
 *
 * // Sets "slow" threshold to half a second
 * mocha.slow(500);
 * @example
 *
 * // Same as above but using string argument
 * mocha.slow('0.5s');
 */
Mocha.prototype.slow = function (msecs) {
  this.suite.slow(msecs);
  return this;
};

/**
 * Forces all tests to either accept a `done` callback or return a promise.
 *
 * @public
 * @see [CLI option](../#-async-only-a)
 * @param {boolean} [asyncOnly=true] - Whether to force `done` callback or promise.
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.asyncOnly = function (asyncOnly) {
  this.options.asyncOnly = asyncOnly !== false;
  return this;
};

/**
 * Disables syntax highlighting (in browser).
 *
 * @public
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.noHighlighting = function () {
  this.options.noHighlighting = true;
  return this;
};

/**
 * Enables or disables uncaught errors to propagate.
 *
 * @public
 * @see [CLI option](../#-allow-uncaught)
 * @param {boolean} [allowUncaught=true] - Whether to propagate uncaught errors.
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.allowUncaught = function (allowUncaught) {
  this.options.allowUncaught = allowUncaught !== false;
  return this;
};

/**
 * @summary
 * Delays root suite execution.
 *
 * @description
 * Used to perform async operations before any suites are run.
 *
 * @public
 * @see [delayed root suite](../#delayed-root-suite)
 * @returns {Mocha} this
 * @chainable
 */
Mocha.prototype.delay = function delay() {
  this.options.delay = true;
  return this;
};

/**
 * Enables or disables running tests in dry-run mode.
 *
 * @public
 * @see [CLI option](../#-dry-run)
 * @param {boolean} [dryRun=true] - Whether to activate dry-run mode.
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.dryRun = function (dryRun) {
  this.options.dryRun = dryRun !== false;
  return this;
};

/**
 * Fails test run if no tests encountered with exit-code 1.
 *
 * @public
 * @see [CLI option](../#-fail-zero)
 * @param {boolean} [failZero=true] - Whether to fail test run.
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.failZero = function (failZero) {
  this.options.failZero = failZero !== false;
  return this;
};

/**
 * Causes tests marked `only` to fail the suite.
 *
 * @public
 * @see [CLI option](../#-forbid-only)
 * @param {boolean} [forbidOnly=true] - Whether tests marked `only` fail the suite.
 * @returns {Mocha} this
 * @chainable
 */
Mocha.prototype.forbidOnly = function (forbidOnly) {
  this.options.forbidOnly = forbidOnly !== false;
  return this;
};

/**
 * Causes pending tests and tests marked `skip` to fail the suite.
 *
 * @public
 * @see [CLI option](../#-forbid-pending)
 * @param {boolean} [forbidPending=true] - Whether pending tests fail the suite.
 * @returns {Mocha} this
 * @chainable
 */
Mocha.prototype.forbidPending = function (forbidPending) {
  this.options.forbidPending = forbidPending !== false;
  return this;
};

/**
 * Throws an error if mocha is in the wrong state to be able to transition to a "running" state.
 * @private
 */
Mocha.prototype._guardRunningStateTransition = function () {
  if (this._state === mochaStates.RUNNING) {
    throw createMochaInstanceAlreadyRunningError(
      'Mocha instance is currently running tests, cannot start a next test run until this one is done',
      this
    );
  }
  if (
    this._state === mochaStates.DISPOSED ||
    this._state === mochaStates.REFERENCES_CLEANED
  ) {
    throw createMochaInstanceAlreadyDisposedError(
      'Mocha instance is already disposed, cannot start a new test run. Please create a new mocha instance. Be sure to set disable `cleanReferencesAfterRun` when you want to reuse the same mocha instance for multiple test runs.',
      this._cleanReferencesAfterRun,
      this
    );
  }
};

/**
 * Mocha version as specified by "package.json".
 *
 * @name Mocha#version
 * @type string
 * @readonly
 */
Object.defineProperty(Mocha.prototype, 'version', {
  value: __webpack_require__(/*! ../package.json */ "./node_modules/mocha/package.json").version,
  configurable: false,
  enumerable: true,
  writable: false
});

/**
 * Callback to be invoked when test execution is complete.
 *
 * @private
 * @callback DoneCB
 * @param {number} failures - Number of failures that occurred.
 */

/**
 * Runs root suite and invokes `fn()` when complete.
 *
 * @description
 * To run tests multiple times (or to run tests in files that are
 * already in the `require` cache), make sure to clear them from
 * the cache first!
 *
 * @public
 * @see {@link Mocha#unloadFiles}
 * @see {@link Runner#run}
 * @param {DoneCB} [fn] - Callback invoked when test execution completed.
 * @returns {Runner} runner instance
 * @example
 *
 * // exit with non-zero status if there were test failures
 * mocha.run(failures => process.exitCode = failures ? 1 : 0);
 */
Mocha.prototype.run = function (fn) {
  this._guardRunningStateTransition();
  this._state = mochaStates.RUNNING;
  if (this._previousRunner) {
    this._previousRunner.dispose();
    this.suite.reset();
  }
  if (this.files.length && !this._lazyLoadFiles) {
    this.loadFiles();
  }
  var suite = this.suite;
  var options = this.options;
  options.files = this.files;
  const runner = new this._runnerClass(suite, {
    cleanReferencesAfterRun: this._cleanReferencesAfterRun,
    delay: options.delay,
    dryRun: options.dryRun,
    failZero: options.failZero
  });
  createStatsCollector(runner);
  var reporter = new this._reporter(runner, options);
  runner.checkLeaks = options.checkLeaks === true;
  runner.fullStackTrace = options.fullTrace;
  runner.asyncOnly = options.asyncOnly;
  runner.allowUncaught = options.allowUncaught;
  runner.forbidOnly = options.forbidOnly;
  runner.forbidPending = options.forbidPending;
  if (options.grep) {
    runner.grep(options.grep, options.invert);
  }
  if (options.global) {
    runner.globals(options.global);
  }
  if (options.color !== undefined) {
    exports.reporters.Base.useColors = options.color;
  }
  exports.reporters.Base.inlineDiffs = options.inlineDiffs;
  exports.reporters.Base.hideDiff = !options.diff;

  const done = failures => {
    this._previousRunner = runner;
    this._state = this._cleanReferencesAfterRun
      ? mochaStates.REFERENCES_CLEANED
      : mochaStates.INIT;
    fn = fn || utils.noop;
    if (typeof reporter.done === 'function') {
      reporter.done(failures, fn);
    } else {
      fn(failures);
    }
  };

  const runAsync = async runner => {
    const context =
      this.options.enableGlobalSetup && this.hasGlobalSetupFixtures()
        ? await this.runGlobalSetup(runner)
        : {};
    const failureCount = await runner.runAsync({
      files: this.files,
      options
    });
    if (this.options.enableGlobalTeardown && this.hasGlobalTeardownFixtures()) {
      await this.runGlobalTeardown(runner, {context});
    }
    return failureCount;
  };

  // no "catch" here is intentional. errors coming out of
  // Runner#run are considered uncaught/unhandled and caught
  // by the `process` event listeners.
  // also: returning anything other than `runner` would be a breaking
  // change
  runAsync(runner).then(done);

  return runner;
};

/**
 * Assigns hooks to the root suite
 * @param {MochaRootHookObject} [hooks] - Hooks to assign to root suite
 * @chainable
 */
Mocha.prototype.rootHooks = function rootHooks({
  beforeAll = [],
  beforeEach = [],
  afterAll = [],
  afterEach = []
} = {}) {
  beforeAll = utils.castArray(beforeAll);
  beforeEach = utils.castArray(beforeEach);
  afterAll = utils.castArray(afterAll);
  afterEach = utils.castArray(afterEach);
  beforeAll.forEach(hook => {
    this.suite.beforeAll(hook);
  });
  beforeEach.forEach(hook => {
    this.suite.beforeEach(hook);
  });
  afterAll.forEach(hook => {
    this.suite.afterAll(hook);
  });
  afterEach.forEach(hook => {
    this.suite.afterEach(hook);
  });
  return this;
};

/**
 * Toggles parallel mode.
 *
 * Must be run before calling {@link Mocha#run}. Changes the `Runner` class to
 * use; also enables lazy file loading if not already done so.
 *
 * Warning: when passed `false` and lazy loading has been enabled _via any means_ (including calling `parallelMode(true)`), this method will _not_ disable lazy loading. Lazy loading is a prerequisite for parallel
 * mode, but parallel mode is _not_ a prerequisite for lazy loading!
 * @param {boolean} [enable] - If `true`, enable; otherwise disable.
 * @throws If run in browser
 * @throws If Mocha not in `INIT` state
 * @returns {Mocha}
 * @chainable
 * @public
 */
Mocha.prototype.parallelMode = function parallelMode(enable = true) {
  if (utils.isBrowser()) {
    throw createUnsupportedError('parallel mode is only supported in Node.js');
  }
  const parallel = Boolean(enable);
  if (
    parallel === this.options.parallel &&
    this._lazyLoadFiles &&
    this._runnerClass !== exports.Runner
  ) {
    return this;
  }
  if (this._state !== mochaStates.INIT) {
    throw createUnsupportedError(
      'cannot change parallel mode after having called run()'
    );
  }
  this.options.parallel = parallel;

  // swap Runner class
  this._runnerClass = parallel
    ? __webpack_require__(/*! ./nodejs/parallel-buffered-runner */ 8)
    : exports.Runner;

  // lazyLoadFiles may have been set `true` otherwise (for ESM loading),
  // so keep `true` if so.
  return this.lazyLoadFiles(this._lazyLoadFiles || parallel);
};

/**
 * Disables implicit call to {@link Mocha#loadFiles} in {@link Mocha#run}. This
 * setting is used by watch mode, parallel mode, and for loading ESM files.
 * @todo This should throw if we've already loaded files; such behavior
 * necessitates adding a new state.
 * @param {boolean} [enable] - If `true`, disable eager loading of files in
 * {@link Mocha#run}
 * @chainable
 * @public
 */
Mocha.prototype.lazyLoadFiles = function lazyLoadFiles(enable) {
  this._lazyLoadFiles = enable === true;
  debug('set lazy load to %s', enable);
  return this;
};

/**
 * Configures one or more global setup fixtures.
 *
 * If given no parameters, _unsets_ any previously-set fixtures.
 * @chainable
 * @public
 * @param {MochaGlobalFixture|MochaGlobalFixture[]} [setupFns] - Global setup fixture(s)
 * @returns {Mocha}
 */
Mocha.prototype.globalSetup = function globalSetup(setupFns = []) {
  setupFns = utils.castArray(setupFns);
  this.options.globalSetup = setupFns;
  debug('configured %d global setup functions', setupFns.length);
  return this;
};

/**
 * Configures one or more global teardown fixtures.
 *
 * If given no parameters, _unsets_ any previously-set fixtures.
 * @chainable
 * @public
 * @param {MochaGlobalFixture|MochaGlobalFixture[]} [teardownFns] - Global teardown fixture(s)
 * @returns {Mocha}
 */
Mocha.prototype.globalTeardown = function globalTeardown(teardownFns = []) {
  teardownFns = utils.castArray(teardownFns);
  this.options.globalTeardown = teardownFns;
  debug('configured %d global teardown functions', teardownFns.length);
  return this;
};

/**
 * Run any global setup fixtures sequentially, if any.
 *
 * This is _automatically called_ by {@link Mocha#run} _unless_ the `runGlobalSetup` option is `false`; see {@link Mocha#enableGlobalSetup}.
 *
 * The context object this function resolves with should be consumed by {@link Mocha#runGlobalTeardown}.
 * @param {object} [context] - Context object if already have one
 * @public
 * @returns {Promise<object>} Context object
 */
Mocha.prototype.runGlobalSetup = async function runGlobalSetup(context = {}) {
  const {globalSetup} = this.options;
  if (globalSetup && globalSetup.length) {
    debug('run(): global setup starting');
    await this._runGlobalFixtures(globalSetup, context);
    debug('run(): global setup complete');
  }
  return context;
};

/**
 * Run any global teardown fixtures sequentially, if any.
 *
 * This is _automatically called_ by {@link Mocha#run} _unless_ the `runGlobalTeardown` option is `false`; see {@link Mocha#enableGlobalTeardown}.
 *
 * Should be called with context object returned by {@link Mocha#runGlobalSetup}, if applicable.
 * @param {object} [context] - Context object if already have one
 * @public
 * @returns {Promise<object>} Context object
 */
Mocha.prototype.runGlobalTeardown = async function runGlobalTeardown(
  context = {}
) {
  const {globalTeardown} = this.options;
  if (globalTeardown && globalTeardown.length) {
    debug('run(): global teardown starting');
    await this._runGlobalFixtures(globalTeardown, context);
  }
  debug('run(): global teardown complete');
  return context;
};

/**
 * Run global fixtures sequentially with context `context`
 * @private
 * @param {MochaGlobalFixture[]} [fixtureFns] - Fixtures to run
 * @param {object} [context] - context object
 * @returns {Promise<object>} context object
 */
Mocha.prototype._runGlobalFixtures = async function _runGlobalFixtures(
  fixtureFns = [],
  context = {}
) {
  for await (const fixtureFn of fixtureFns) {
    await fixtureFn.call(context);
  }
  return context;
};

/**
 * Toggle execution of any global setup fixture(s)
 *
 * @chainable
 * @public
 * @param {boolean } [enabled=true] - If `false`, do not run global setup fixture
 * @returns {Mocha}
 */
Mocha.prototype.enableGlobalSetup = function enableGlobalSetup(enabled = true) {
  this.options.enableGlobalSetup = Boolean(enabled);
  return this;
};

/**
 * Toggle execution of any global teardown fixture(s)
 *
 * @chainable
 * @public
 * @param {boolean } [enabled=true] - If `false`, do not run global teardown fixture
 * @returns {Mocha}
 */
Mocha.prototype.enableGlobalTeardown = function enableGlobalTeardown(
  enabled = true
) {
  this.options.enableGlobalTeardown = Boolean(enabled);
  return this;
};

/**
 * Returns `true` if one or more global setup fixtures have been supplied.
 * @public
 * @returns {boolean}
 */
Mocha.prototype.hasGlobalSetupFixtures = function hasGlobalSetupFixtures() {
  return Boolean(this.options.globalSetup.length);
};

/**
 * Returns `true` if one or more global teardown fixtures have been supplied.
 * @public
 * @returns {boolean}
 */
Mocha.prototype.hasGlobalTeardownFixtures =
  function hasGlobalTeardownFixtures() {
    return Boolean(this.options.globalTeardown.length);
  };

/**
 * An alternative way to define root hooks that works with parallel runs.
 * @typedef {Object} MochaRootHookObject
 * @property {Function|Function[]} [beforeAll] - "Before all" hook(s)
 * @property {Function|Function[]} [beforeEach] - "Before each" hook(s)
 * @property {Function|Function[]} [afterAll] - "After all" hook(s)
 * @property {Function|Function[]} [afterEach] - "After each" hook(s)
 */

/**
 * An function that returns a {@link MochaRootHookObject}, either sync or async.
   @callback MochaRootHookFunction
 * @returns {MochaRootHookObject|Promise<MochaRootHookObject>}
 */

/**
 * A function that's invoked _once_ which is either sync or async.
 * Can be a "teardown" or "setup".  These will all share the same context.
 * @callback MochaGlobalFixture
 * @returns {void|Promise<void>}
 */

/**
 * An object making up all necessary parts of a plugin loader and aggregator
 * @typedef {Object} PluginDefinition
 * @property {string} exportName - Named export to use
 * @property {string} [optionName] - Option name for Mocha constructor (use `exportName` if omitted)
 * @property {PluginValidator} [validate] - Validator function
 * @property {PluginFinalizer} [finalize] - Finalizer/aggregator function
 */

/**
 * A (sync) function to assert a user-supplied plugin implementation is valid.
 *
 * Defined in a {@link PluginDefinition}.

 * @callback PluginValidator
 * @param {*} value - Value to check
 * @this {PluginDefinition}
 * @returns {void}
 */

/**
 * A function to finalize plugins impls of a particular ilk
 * @callback PluginFinalizer
 * @param {Array<*>} impls - User-supplied implementations
 * @returns {Promise<*>|*}
 */

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/module.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/mocha/lib/mocharc.json":
/*!*********************************************!*\
  !*** ./node_modules/mocha/lib/mocharc.json ***!
  \*********************************************/
/*! exports provided: diff, extension, package, reporter, slow, timeout, ui, watch-ignore, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"diff\":true,\"extension\":[\"js\",\"cjs\",\"mjs\"],\"package\":\"./package.json\",\"reporter\":\"spec\",\"slow\":75,\"timeout\":2000,\"ui\":\"bdd\",\"watch-ignore\":[\"node_modules\",\".git\"]}");

/***/ }),

/***/ "./node_modules/mocha/lib/pending.js":
/*!*******************************************!*\
  !*** ./node_modules/mocha/lib/pending.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 @module Pending
*/

module.exports = Pending;

/**
 * Initialize a new `Pending` error with the given message.
 *
 * @param {string} message
 */
function Pending(message) {
  this.message = message;
}


/***/ }),

/***/ "./node_modules/mocha/lib/reporters/base.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/base.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {
/**
 * @module Base
 */
/**
 * Module dependencies.
 */

var diff = __webpack_require__(/*! diff */ "./node_modules/diff/dist/diff.js");
var milliseconds = __webpack_require__(/*! ms */ "./node_modules/mocha/node_modules/ms/index.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/mocha/lib/utils.js");
var supportsColor = __webpack_require__(/*! supports-color */ 4);
var symbols = __webpack_require__(/*! log-symbols */ "./node_modules/log-symbols/browser.js");
var constants = __webpack_require__(/*! ../runner */ "./node_modules/mocha/lib/runner.js").constants;
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;

const isBrowser = utils.isBrowser();

function getBrowserWindowSize() {
  if ('innerHeight' in global) {
    return [global.innerHeight, global.innerWidth];
  }
  // In a Web Worker, the DOM Window is not available.
  return [640, 480];
}

/**
 * Expose `Base`.
 */

exports = module.exports = Base;

/**
 * Check if both stdio streams are associated with a tty.
 */

var isatty = isBrowser || (process.stdout.isTTY && process.stderr.isTTY);

/**
 * Save log references to avoid tests interfering (see GH-3604).
 */
var consoleLog = console.log;

/**
 * Enable coloring by default, except in the browser interface.
 */

exports.useColors =
  !isBrowser &&
  (supportsColor.stdout || process.env.MOCHA_COLORS !== undefined);

/**
 * Inline diffs instead of +/-
 */

exports.inlineDiffs = false;

/**
 * Truncate diffs longer than this value to avoid slow performance
 */
exports.maxDiffSize = 8192;

/**
 * Default color map.
 */

exports.colors = {
  pass: 90,
  fail: 31,
  'bright pass': 92,
  'bright fail': 91,
  'bright yellow': 93,
  pending: 36,
  suite: 0,
  'error title': 0,
  'error message': 31,
  'error stack': 90,
  checkmark: 32,
  fast: 90,
  medium: 33,
  slow: 31,
  green: 32,
  light: 90,
  'diff gutter': 90,
  'diff added': 32,
  'diff removed': 31,
  'diff added inline': '30;42',
  'diff removed inline': '30;41'
};

/**
 * Default symbol map.
 */

exports.symbols = {
  ok: symbols.success,
  err: symbols.error,
  dot: '.',
  comma: ',',
  bang: '!'
};

/**
 * Color `str` with the given `type`,
 * allowing colors to be disabled,
 * as well as user-defined color
 * schemes.
 *
 * @private
 * @param {string} type
 * @param {string} str
 * @return {string}
 */
var color = (exports.color = function (type, str) {
  if (!exports.useColors) {
    return String(str);
  }
  return '\u001b[' + exports.colors[type] + 'm' + str + '\u001b[0m';
});

/**
 * Expose term window size, with some defaults for when stderr is not a tty.
 */

exports.window = {
  width: 75
};

if (isatty) {
  if (isBrowser) {
    exports.window.width = getBrowserWindowSize()[1];
  } else {
    exports.window.width = process.stdout.getWindowSize(1)[0];
  }
}

/**
 * Expose some basic cursor interactions that are common among reporters.
 */

exports.cursor = {
  hide: function () {
    isatty && process.stdout.write('\u001b[?25l');
  },

  show: function () {
    isatty && process.stdout.write('\u001b[?25h');
  },

  deleteLine: function () {
    isatty && process.stdout.write('\u001b[2K');
  },

  beginningOfLine: function () {
    isatty && process.stdout.write('\u001b[0G');
  },

  CR: function () {
    if (isatty) {
      exports.cursor.deleteLine();
      exports.cursor.beginningOfLine();
    } else {
      process.stdout.write('\r');
    }
  }
};

var showDiff = (exports.showDiff = function (err) {
  return (
    err &&
    err.showDiff !== false &&
    sameType(err.actual, err.expected) &&
    err.expected !== undefined
  );
});

function stringifyDiffObjs(err) {
  if (!utils.isString(err.actual) || !utils.isString(err.expected)) {
    err.actual = utils.stringify(err.actual);
    err.expected = utils.stringify(err.expected);
  }
}

/**
 * Returns a diff between 2 strings with coloured ANSI output.
 *
 * @description
 * The diff will be either inline or unified dependent on the value
 * of `Base.inlineDiff`.
 *
 * @param {string} actual
 * @param {string} expected
 * @return {string} Diff
 */

var generateDiff = (exports.generateDiff = function (actual, expected) {
  try {
    var maxLen = exports.maxDiffSize;
    var skipped = 0;
    if (maxLen > 0) {
      skipped = Math.max(actual.length - maxLen, expected.length - maxLen);
      actual = actual.slice(0, maxLen);
      expected = expected.slice(0, maxLen);
    }
    let result = exports.inlineDiffs
      ? inlineDiff(actual, expected)
      : unifiedDiff(actual, expected);
    if (skipped > 0) {
      result = `${result}\n      [mocha] output truncated to ${maxLen} characters, see "maxDiffSize" reporter-option\n`;
    }
    return result;
  } catch (err) {
    var msg =
      '\n      ' +
      color('diff added', '+ expected') +
      ' ' +
      color('diff removed', '- actual:  failed to generate Mocha diff') +
      '\n';
    return msg;
  }
});

/**
 * Outputs the given `failures` as a list.
 *
 * @public
 * @memberof Mocha.reporters.Base
 * @variation 1
 * @param {Object[]} failures - Each is Test instance with corresponding
 *     Error property
 */
exports.list = function (failures) {
  var multipleErr, multipleTest;
  Base.consoleLog();
  failures.forEach(function (test, i) {
    // format
    var fmt =
      color('error title', '  %s) %s:\n') +
      color('error message', '     %s') +
      color('error stack', '\n%s\n');

    // msg
    var msg;
    var err;
    if (test.err && test.err.multiple) {
      if (multipleTest !== test) {
        multipleTest = test;
        multipleErr = [test.err].concat(test.err.multiple);
      }
      err = multipleErr.shift();
    } else {
      err = test.err;
    }
    var message;
    if (typeof err.inspect === 'function') {
      message = err.inspect() + '';
    } else if (err.message && typeof err.message.toString === 'function') {
      message = err.message + '';
    } else {
      message = '';
    }
    var stack = err.stack || message;
    var index = message ? stack.indexOf(message) : -1;

    if (index === -1) {
      msg = message;
    } else {
      index += message.length;
      msg = stack.slice(0, index);
      // remove msg from stack
      stack = stack.slice(index + 1);
    }

    // uncaught
    if (err.uncaught) {
      msg = 'Uncaught ' + msg;
    }
    // explicitly show diff
    if (!exports.hideDiff && showDiff(err)) {
      stringifyDiffObjs(err);
      fmt =
        color('error title', '  %s) %s:\n%s') + color('error stack', '\n%s\n');
      var match = message.match(/^([^:]+): expected/);
      msg = '\n      ' + color('error message', match ? match[1] : msg);

      msg += generateDiff(err.actual, err.expected);
    }

    // indent stack trace
    stack = stack.replace(/^/gm, '  ');

    // indented test title
    var testTitle = '';
    test.titlePath().forEach(function (str, index) {
      if (index !== 0) {
        testTitle += '\n     ';
      }
      for (var i = 0; i < index; i++) {
        testTitle += '  ';
      }
      testTitle += str;
    });

    Base.consoleLog(fmt, i + 1, testTitle, msg, stack);
  });
};

/**
 * Constructs a new `Base` reporter instance.
 *
 * @description
 * All other reporters generally inherit from this reporter.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function Base(runner, options) {
  var failures = (this.failures = []);

  if (!runner) {
    throw new TypeError('Missing runner argument');
  }
  this.options = options || {};
  this.runner = runner;
  this.stats = runner.stats; // assigned so Reporters keep a closer reference

  var maxDiffSizeOpt =
    this.options.reporterOption && this.options.reporterOption.maxDiffSize;
  if (maxDiffSizeOpt !== undefined && !isNaN(Number(maxDiffSizeOpt))) {
    exports.maxDiffSize = Number(maxDiffSizeOpt);
  }

  runner.on(EVENT_TEST_PASS, function (test) {
    if (test.duration > test.slow()) {
      test.speed = 'slow';
    } else if (test.duration > test.slow() / 2) {
      test.speed = 'medium';
    } else {
      test.speed = 'fast';
    }
  });

  runner.on(EVENT_TEST_FAIL, function (test, err) {
    if (showDiff(err)) {
      stringifyDiffObjs(err);
    }
    // more than one error per test
    if (test.err && err instanceof Error) {
      test.err.multiple = (test.err.multiple || []).concat(err);
    } else {
      test.err = err;
    }
    failures.push(test);
  });
}

/**
 * Outputs common epilogue used by many of the bundled reporters.
 *
 * @public
 * @memberof Mocha.reporters
 */
Base.prototype.epilogue = function () {
  var stats = this.stats;
  var fmt;

  Base.consoleLog();

  // passes
  fmt =
    color('bright pass', ' ') +
    color('green', ' %d passing') +
    color('light', ' (%s)');

  Base.consoleLog(fmt, stats.passes || 0, milliseconds(stats.duration));

  // pending
  if (stats.pending) {
    fmt = color('pending', ' ') + color('pending', ' %d pending');

    Base.consoleLog(fmt, stats.pending);
  }

  // failures
  if (stats.failures) {
    fmt = color('fail', '  %d failing');

    Base.consoleLog(fmt, stats.failures);

    Base.list(this.failures);
    Base.consoleLog();
  }

  Base.consoleLog();
};

/**
 * Pads the given `str` to `len`.
 *
 * @private
 * @param {string} str
 * @param {string} len
 * @return {string}
 */
function pad(str, len) {
  str = String(str);
  return Array(len - str.length + 1).join(' ') + str;
}

/**
 * Returns inline diff between 2 strings with coloured ANSI output.
 *
 * @private
 * @param {String} actual
 * @param {String} expected
 * @return {string} Diff
 */
function inlineDiff(actual, expected) {
  var msg = errorDiff(actual, expected);

  // linenos
  var lines = msg.split('\n');
  if (lines.length > 4) {
    var width = String(lines.length).length;
    msg = lines
      .map(function (str, i) {
        return pad(++i, width) + ' |' + ' ' + str;
      })
      .join('\n');
  }

  // legend
  msg =
    '\n' +
    color('diff removed inline', 'actual') +
    ' ' +
    color('diff added inline', 'expected') +
    '\n\n' +
    msg +
    '\n';

  // indent
  msg = msg.replace(/^/gm, '      ');
  return msg;
}

/**
 * Returns unified diff between two strings with coloured ANSI output.
 *
 * @private
 * @param {String} actual
 * @param {String} expected
 * @return {string} The diff.
 */
function unifiedDiff(actual, expected) {
  var indent = '      ';
  function cleanUp(line) {
    if (line[0] === '+') {
      return indent + colorLines('diff added', line);
    }
    if (line[0] === '-') {
      return indent + colorLines('diff removed', line);
    }
    if (line.match(/@@/)) {
      return '--';
    }
    if (line.match(/\\ No newline/)) {
      return null;
    }
    return indent + line;
  }
  function notBlank(line) {
    return typeof line !== 'undefined' && line !== null;
  }
  var msg = diff.createPatch('string', actual, expected);
  var lines = msg.split('\n').splice(5);
  return (
    '\n      ' +
    colorLines('diff added', '+ expected') +
    ' ' +
    colorLines('diff removed', '- actual') +
    '\n\n' +
    lines.map(cleanUp).filter(notBlank).join('\n')
  );
}

/**
 * Returns character diff for `err`.
 *
 * @private
 * @param {String} actual
 * @param {String} expected
 * @return {string} the diff
 */
function errorDiff(actual, expected) {
  return diff
    .diffWordsWithSpace(actual, expected)
    .map(function (str) {
      if (str.added) {
        return colorLines('diff added inline', str.value);
      }
      if (str.removed) {
        return colorLines('diff removed inline', str.value);
      }
      return str.value;
    })
    .join('');
}

/**
 * Colors lines for `str`, using the color `name`.
 *
 * @private
 * @param {string} name
 * @param {string} str
 * @return {string}
 */
function colorLines(name, str) {
  return str
    .split('\n')
    .map(function (str) {
      return color(name, str);
    })
    .join('\n');
}

/**
 * Object#toString reference.
 */
var objToString = Object.prototype.toString;

/**
 * Checks that a / b have the same type.
 *
 * @private
 * @param {Object} a
 * @param {Object} b
 * @return {boolean}
 */
function sameType(a, b) {
  return objToString.call(a) === objToString.call(b);
}

Base.consoleLog = consoleLog;

Base.abstract = true;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/doc.js":
/*!*************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/doc.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @module Doc
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "./node_modules/mocha/lib/reporters/base.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/mocha/lib/utils.js");
var constants = __webpack_require__(/*! ../runner */ "./node_modules/mocha/lib/runner.js").constants;
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
var EVENT_SUITE_END = constants.EVENT_SUITE_END;

/**
 * Expose `Doc`.
 */

exports = module.exports = Doc;

/**
 * Constructs a new `Doc` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function Doc(runner, options) {
  Base.call(this, runner, options);

  var indents = 2;

  function indent() {
    return Array(indents).join('  ');
  }

  runner.on(EVENT_SUITE_BEGIN, function (suite) {
    if (suite.root) {
      return;
    }
    ++indents;
    Base.consoleLog('%s<section class="suite">', indent());
    ++indents;
    Base.consoleLog('%s<h1>%s</h1>', indent(), utils.escape(suite.title));
    Base.consoleLog('%s<dl>', indent());
  });

  runner.on(EVENT_SUITE_END, function (suite) {
    if (suite.root) {
      return;
    }
    Base.consoleLog('%s</dl>', indent());
    --indents;
    Base.consoleLog('%s</section>', indent());
    --indents;
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    Base.consoleLog('%s  <dt>%s</dt>', indent(), utils.escape(test.title));
    Base.consoleLog('%s  <dt>%s</dt>', indent(), utils.escape(test.file));
    var code = utils.escape(utils.clean(test.body));
    Base.consoleLog('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);
  });

  runner.on(EVENT_TEST_FAIL, function (test, err) {
    Base.consoleLog(
      '%s  <dt class="error">%s</dt>',
      indent(),
      utils.escape(test.title)
    );
    Base.consoleLog(
      '%s  <dt class="error">%s</dt>',
      indent(),
      utils.escape(test.file)
    );
    var code = utils.escape(utils.clean(test.body));
    Base.consoleLog(
      '%s  <dd class="error"><pre><code>%s</code></pre></dd>',
      indent(),
      code
    );
    Base.consoleLog(
      '%s  <dd class="error">%s</dd>',
      indent(),
      utils.escape(err)
    );
  });
}

Doc.description = 'HTML documentation';


/***/ }),

/***/ "./node_modules/mocha/lib/reporters/dot.js":
/*!*************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/dot.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
/**
 * @module Dot
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "./node_modules/mocha/lib/reporters/base.js");
var inherits = __webpack_require__(/*! ../utils */ "./node_modules/mocha/lib/utils.js").inherits;
var constants = __webpack_require__(/*! ../runner */ "./node_modules/mocha/lib/runner.js").constants;
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
var EVENT_RUN_END = constants.EVENT_RUN_END;

/**
 * Expose `Dot`.
 */

exports = module.exports = Dot;

/**
 * Constructs a new `Dot` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function Dot(runner, options) {
  Base.call(this, runner, options);

  var self = this;
  var width = (Base.window.width * 0.75) | 0;
  var n = -1;

  runner.on(EVENT_RUN_BEGIN, function () {
    process.stdout.write('\n');
  });

  runner.on(EVENT_TEST_PENDING, function () {
    if (++n % width === 0) {
      process.stdout.write('\n  ');
    }
    process.stdout.write(Base.color('pending', Base.symbols.comma));
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    if (++n % width === 0) {
      process.stdout.write('\n  ');
    }
    if (test.speed === 'slow') {
      process.stdout.write(Base.color('bright yellow', Base.symbols.dot));
    } else {
      process.stdout.write(Base.color(test.speed, Base.symbols.dot));
    }
  });

  runner.on(EVENT_TEST_FAIL, function () {
    if (++n % width === 0) {
      process.stdout.write('\n  ');
    }
    process.stdout.write(Base.color('fail', Base.symbols.bang));
  });

  runner.once(EVENT_RUN_END, function () {
    process.stdout.write('\n');
    self.epilogue();
  });
}

/**
 * Inherit from `Base.prototype`.
 */
inherits(Dot, Base);

Dot.description = 'dot matrix representation';

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/html.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/html.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

/* eslint-env browser */
/**
 * @module HTML
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "./node_modules/mocha/lib/reporters/base.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/mocha/lib/utils.js");
var Progress = __webpack_require__(/*! ../browser/progress */ "./node_modules/mocha/lib/browser/progress.js");
var escapeRe = __webpack_require__(/*! escape-string-regexp */ "./node_modules/mocha/node_modules/escape-string-regexp/index.js");
var constants = __webpack_require__(/*! ../runner */ "./node_modules/mocha/lib/runner.js").constants;
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
var EVENT_SUITE_END = constants.EVENT_SUITE_END;
var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
var escape = utils.escape;

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 */

var Date = global.Date;

/**
 * Expose `HTML`.
 */

exports = module.exports = HTML;

/**
 * Stats template.
 */

var statsTemplate =
  '<ul id="mocha-stats">' +
  '<li class="progress"><canvas width="40" height="40"></canvas></li>' +
  '<li class="passes"><a href="javascript:void(0);">passes:</a> <em>0</em></li>' +
  '<li class="failures"><a href="javascript:void(0);">failures:</a> <em>0</em></li>' +
  '<li class="duration">duration: <em>0</em>s</li>' +
  '</ul>';

var playIcon = '&#x2023;';

/**
 * Constructs a new `HTML` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function HTML(runner, options) {
  Base.call(this, runner, options);

  var self = this;
  var stats = this.stats;
  var stat = fragment(statsTemplate);
  var items = stat.getElementsByTagName('li');
  var passes = items[1].getElementsByTagName('em')[0];
  var passesLink = items[1].getElementsByTagName('a')[0];
  var failures = items[2].getElementsByTagName('em')[0];
  var failuresLink = items[2].getElementsByTagName('a')[0];
  var duration = items[3].getElementsByTagName('em')[0];
  var canvas = stat.getElementsByTagName('canvas')[0];
  var report = fragment('<ul id="mocha-report"></ul>');
  var stack = [report];
  var progress;
  var ctx;
  var root = document.getElementById('mocha');

  if (canvas.getContext) {
    var ratio = window.devicePixelRatio || 1;
    canvas.style.width = canvas.width;
    canvas.style.height = canvas.height;
    canvas.width *= ratio;
    canvas.height *= ratio;
    ctx = canvas.getContext('2d');
    ctx.scale(ratio, ratio);
    progress = new Progress();
  }

  if (!root) {
    return error('#mocha div missing, add it to your document');
  }

  // pass toggle
  on(passesLink, 'click', function (evt) {
    evt.preventDefault();
    unhide();
    var name = /pass/.test(report.className) ? '' : ' pass';
    report.className = report.className.replace(/fail|pass/g, '') + name;
    if (report.className.trim()) {
      hideSuitesWithout('test pass');
    }
  });

  // failure toggle
  on(failuresLink, 'click', function (evt) {
    evt.preventDefault();
    unhide();
    var name = /fail/.test(report.className) ? '' : ' fail';
    report.className = report.className.replace(/fail|pass/g, '') + name;
    if (report.className.trim()) {
      hideSuitesWithout('test fail');
    }
  });

  root.appendChild(stat);
  root.appendChild(report);

  if (progress) {
    progress.size(40);
  }

  runner.on(EVENT_SUITE_BEGIN, function (suite) {
    if (suite.root) {
      return;
    }

    // suite
    var url = self.suiteURL(suite);
    var el = fragment(
      '<li class="suite"><h1><a href="%s">%s</a></h1></li>',
      url,
      escape(suite.title)
    );

    // container
    stack[0].appendChild(el);
    stack.unshift(document.createElement('ul'));
    el.appendChild(stack[0]);
  });

  runner.on(EVENT_SUITE_END, function (suite) {
    if (suite.root) {
      updateStats();
      return;
    }
    stack.shift();
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    var url = self.testURL(test);
    var markup =
      '<li class="test pass %e"><h2>%e<span class="duration">%ems</span> ' +
      '<a href="%s" class="replay">' +
      playIcon +
      '</a></h2></li>';
    var el = fragment(markup, test.speed, test.title, test.duration, url);
    self.addCodeToggle(el, test.body);
    appendToStack(el);
    updateStats();
  });

  runner.on(EVENT_TEST_FAIL, function (test) {
    var el = fragment(
      '<li class="test fail"><h2>%e <a href="%e" class="replay">' +
        playIcon +
        '</a></h2></li>',
      test.title,
      self.testURL(test)
    );
    var stackString; // Note: Includes leading newline
    var message = test.err.toString();

    // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we
    // check for the result of the stringifying.
    if (message === '[object Error]') {
      message = test.err.message;
    }

    if (test.err.stack) {
      var indexOfMessage = test.err.stack.indexOf(test.err.message);
      if (indexOfMessage === -1) {
        stackString = test.err.stack;
      } else {
        stackString = test.err.stack.slice(
          test.err.message.length + indexOfMessage
        );
      }
    } else if (test.err.sourceURL && test.err.line !== undefined) {
      // Safari doesn't give you a stack. Let's at least provide a source line.
      stackString = '\n(' + test.err.sourceURL + ':' + test.err.line + ')';
    }

    stackString = stackString || '';

    if (test.err.htmlMessage && stackString) {
      el.appendChild(
        fragment(
          '<div class="html-error">%s\n<pre class="error">%e</pre></div>',
          test.err.htmlMessage,
          stackString
        )
      );
    } else if (test.err.htmlMessage) {
      el.appendChild(
        fragment('<div class="html-error">%s</div>', test.err.htmlMessage)
      );
    } else {
      el.appendChild(
        fragment('<pre class="error">%e%e</pre>', message, stackString)
      );
    }

    self.addCodeToggle(el, test.body);
    appendToStack(el);
    updateStats();
  });

  runner.on(EVENT_TEST_PENDING, function (test) {
    var el = fragment(
      '<li class="test pass pending"><h2>%e</h2></li>',
      test.title
    );
    appendToStack(el);
    updateStats();
  });

  function appendToStack(el) {
    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.
    if (stack[0]) {
      stack[0].appendChild(el);
    }
  }

  function updateStats() {
    // TODO: add to stats
    var percent = ((stats.tests / runner.total) * 100) | 0;
    if (progress) {
      progress.update(percent).draw(ctx);
    }

    // update stats
    var ms = new Date() - stats.start;
    text(passes, stats.passes);
    text(failures, stats.failures);
    text(duration, (ms / 1000).toFixed(2));
  }
}

/**
 * Makes a URL, preserving querystring ("search") parameters.
 *
 * @param {string} s
 * @return {string} A new URL.
 */
function makeUrl(s) {
  var search = window.location.search;

  // Remove previous grep query parameter if present
  if (search) {
    search = search.replace(/[?&]grep=[^&\s]*/g, '').replace(/^&/, '?');
  }

  return (
    window.location.pathname +
    (search ? search + '&' : '?') +
    'grep=' +
    encodeURIComponent(escapeRe(s))
  );
}

/**
 * Provide suite URL.
 *
 * @param {Object} [suite]
 */
HTML.prototype.suiteURL = function (suite) {
  return makeUrl(suite.fullTitle());
};

/**
 * Provide test URL.
 *
 * @param {Object} [test]
 */
HTML.prototype.testURL = function (test) {
  return makeUrl(test.fullTitle());
};

/**
 * Adds code toggle functionality for the provided test's list element.
 *
 * @param {HTMLLIElement} el
 * @param {string} contents
 */
HTML.prototype.addCodeToggle = function (el, contents) {
  var h2 = el.getElementsByTagName('h2')[0];

  on(h2, 'click', function () {
    pre.style.display = pre.style.display === 'none' ? 'block' : 'none';
  });

  var pre = fragment('<pre><code>%e</code></pre>', utils.clean(contents));
  el.appendChild(pre);
  pre.style.display = 'none';
};

/**
 * Display error `msg`.
 *
 * @param {string} msg
 */
function error(msg) {
  document.body.appendChild(fragment('<div id="mocha-error">%s</div>', msg));
}

/**
 * Return a DOM fragment from `html`.
 *
 * @param {string} html
 */
function fragment(html) {
  var args = arguments;
  var div = document.createElement('div');
  var i = 1;

  div.innerHTML = html.replace(/%([se])/g, function (_, type) {
    switch (type) {
      case 's':
        return String(args[i++]);
      case 'e':
        return escape(args[i++]);
      // no default
    }
  });

  return div.firstChild;
}

/**
 * Check for suites that do not have elements
 * with `classname`, and hide them.
 *
 * @param {text} classname
 */
function hideSuitesWithout(classname) {
  var suites = document.getElementsByClassName('suite');
  for (var i = 0; i < suites.length; i++) {
    var els = suites[i].getElementsByClassName(classname);
    if (!els.length) {
      suites[i].className += ' hidden';
    }
  }
}

/**
 * Unhide .hidden suites.
 */
function unhide() {
  var els = document.getElementsByClassName('suite hidden');
  while (els.length > 0) {
    els[0].className = els[0].className.replace('suite hidden', 'suite');
  }
}

/**
 * Set an element's text contents.
 *
 * @param {HTMLElement} el
 * @param {string} contents
 */
function text(el, contents) {
  if (el.textContent) {
    el.textContent = contents;
  } else {
    el.innerText = contents;
  }
}

/**
 * Listen on `event` with callback `fn`.
 */
function on(el, event, fn) {
  if (el.addEventListener) {
    el.addEventListener(event, fn, false);
  } else {
    el.attachEvent('on' + event, fn);
  }
}

HTML.browserOnly = true;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/index.js":
/*!***************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Alias exports to a their normalized format Mocha#reporter to prevent a need
// for dynamic (try/catch) requires, which Browserify doesn't handle.
exports.Base = exports.base = __webpack_require__(/*! ./base */ "./node_modules/mocha/lib/reporters/base.js");
exports.Dot = exports.dot = __webpack_require__(/*! ./dot */ "./node_modules/mocha/lib/reporters/dot.js");
exports.Doc = exports.doc = __webpack_require__(/*! ./doc */ "./node_modules/mocha/lib/reporters/doc.js");
exports.TAP = exports.tap = __webpack_require__(/*! ./tap */ "./node_modules/mocha/lib/reporters/tap.js");
exports.JSON = exports.json = __webpack_require__(/*! ./json */ "./node_modules/mocha/lib/reporters/json.js");
exports.HTML = exports.html = __webpack_require__(/*! ./html */ "./node_modules/mocha/lib/reporters/html.js");
exports.List = exports.list = __webpack_require__(/*! ./list */ "./node_modules/mocha/lib/reporters/list.js");
exports.Min = exports.min = __webpack_require__(/*! ./min */ "./node_modules/mocha/lib/reporters/min.js");
exports.Spec = exports.spec = __webpack_require__(/*! ./spec */ "./node_modules/mocha/lib/reporters/spec.js");
exports.Nyan = exports.nyan = __webpack_require__(/*! ./nyan */ "./node_modules/mocha/lib/reporters/nyan.js");
exports.XUnit = exports.xunit = __webpack_require__(/*! ./xunit */ "./node_modules/mocha/lib/reporters/xunit.js");
exports.Markdown = exports.markdown = __webpack_require__(/*! ./markdown */ "./node_modules/mocha/lib/reporters/markdown.js");
exports.Progress = exports.progress = __webpack_require__(/*! ./progress */ "./node_modules/mocha/lib/reporters/progress.js");
exports.Landing = exports.landing = __webpack_require__(/*! ./landing */ "./node_modules/mocha/lib/reporters/landing.js");
exports.JSONStream = exports['json-stream'] = __webpack_require__(/*! ./json-stream */ "./node_modules/mocha/lib/reporters/json-stream.js");


/***/ }),

/***/ "./node_modules/mocha/lib/reporters/json-stream.js":
/*!*********************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/json-stream.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
/**
 * @module JSONStream
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "./node_modules/mocha/lib/reporters/base.js");
var constants = __webpack_require__(/*! ../runner */ "./node_modules/mocha/lib/runner.js").constants;
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
var EVENT_RUN_END = constants.EVENT_RUN_END;

/**
 * Expose `JSONStream`.
 */

exports = module.exports = JSONStream;

/**
 * Constructs a new `JSONStream` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function JSONStream(runner, options) {
  Base.call(this, runner, options);

  var self = this;
  var total = runner.total;

  runner.once(EVENT_RUN_BEGIN, function () {
    writeEvent(['start', {total: total}]);
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    writeEvent(['pass', clean(test)]);
  });

  runner.on(EVENT_TEST_FAIL, function (test, err) {
    test = clean(test);
    test.err = err.message;
    test.stack = err.stack || null;
    writeEvent(['fail', test]);
  });

  runner.once(EVENT_RUN_END, function () {
    writeEvent(['end', self.stats]);
  });
}

/**
 * Mocha event to be written to the output stream.
 * @typedef {Array} JSONStream~MochaEvent
 */

/**
 * Writes Mocha event to reporter output stream.
 *
 * @private
 * @param {JSONStream~MochaEvent} event - Mocha event to be output.
 */
function writeEvent(event) {
  process.stdout.write(JSON.stringify(event) + '\n');
}

/**
 * Returns an object literal representation of `test`
 * free of cyclic properties, etc.
 *
 * @private
 * @param {Test} test - Instance used as data source.
 * @return {Object} object containing pared-down test instance data
 */
function clean(test) {
  return {
    title: test.title,
    fullTitle: test.fullTitle(),
    file: test.file,
    duration: test.duration,
    currentRetry: test.currentRetry(),
    speed: test.speed
  };
}

JSONStream.description = 'newline delimited JSON events';

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/json.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/json.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
/**
 * @module JSON
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "./node_modules/mocha/lib/reporters/base.js");
var fs = __webpack_require__(/*! fs */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/@packages/server/node_modules/@cypress/webpack-batteries-included-preprocessor/empty.js");
var path = __webpack_require__(/*! path */ 5);
const createUnsupportedError = __webpack_require__(/*! ../errors */ "./node_modules/mocha/lib/errors.js").createUnsupportedError;
const utils = __webpack_require__(/*! ../utils */ "./node_modules/mocha/lib/utils.js");
var constants = __webpack_require__(/*! ../runner */ "./node_modules/mocha/lib/runner.js").constants;
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_TEST_END = constants.EVENT_TEST_END;
var EVENT_RUN_END = constants.EVENT_RUN_END;

/**
 * Expose `JSON`.
 */

exports = module.exports = JSONReporter;

/**
 * Constructs a new `JSON` reporter instance.
 *
 * @public
 * @class JSON
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function JSONReporter(runner, options = {}) {
  Base.call(this, runner, options);

  var self = this;
  var tests = [];
  var pending = [];
  var failures = [];
  var passes = [];
  var output;

  if (options.reporterOption && options.reporterOption.output) {
    if (utils.isBrowser()) {
      throw createUnsupportedError('file output not supported in browser');
    }
    output = options.reporterOption.output;
  }

  runner.on(EVENT_TEST_END, function (test) {
    tests.push(test);
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    passes.push(test);
  });

  runner.on(EVENT_TEST_FAIL, function (test) {
    failures.push(test);
  });

  runner.on(EVENT_TEST_PENDING, function (test) {
    pending.push(test);
  });

  runner.once(EVENT_RUN_END, function () {
    var obj = {
      stats: self.stats,
      tests: tests.map(clean),
      pending: pending.map(clean),
      failures: failures.map(clean),
      passes: passes.map(clean)
    };

    runner.testResults = obj;

    var json = JSON.stringify(obj, null, 2);
    if (output) {
      try {
        fs.mkdirSync(path.dirname(output), {recursive: true});
        fs.writeFileSync(output, json);
      } catch (err) {
        console.error(
          `${Base.symbols.err} [mocha] writing output to "${output}" failed: ${err.message}\n`
        );
        process.stdout.write(json);
      }
    } else {
      process.stdout.write(json);
    }
  });
}

/**
 * Return a plain-object representation of `test`
 * free of cyclic properties etc.
 *
 * @private
 * @param {Object} test
 * @return {Object}
 */
function clean(test) {
  var err = test.err || {};
  if (err instanceof Error) {
    err = errorJSON(err);
  }

  return {
    title: test.title,
    fullTitle: test.fullTitle(),
    file: test.file,
    duration: test.duration,
    currentRetry: test.currentRetry(),
    speed: test.speed,
    err: cleanCycles(err)
  };
}

/**
 * Replaces any circular references inside `obj` with '[object Object]'
 *
 * @private
 * @param {Object} obj
 * @return {Object}
 */
function cleanCycles(obj) {
  var cache = [];
  return JSON.parse(
    JSON.stringify(obj, function (key, value) {
      if (typeof value === 'object' && value !== null) {
        if (cache.indexOf(value) !== -1) {
          // Instead of going in a circle, we'll print [object Object]
          return '' + value;
        }
        cache.push(value);
      }

      return value;
    })
  );
}

/**
 * Transform an Error object into a JSON object.
 *
 * @private
 * @param {Error} err
 * @return {Object}
 */
function errorJSON(err) {
  var res = {};
  Object.getOwnPropertyNames(err).forEach(function (key) {
    res[key] = err[key];
  }, err);
  return res;
}

JSONReporter.description = 'single JSON object';

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/landing.js":
/*!*****************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/landing.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
/**
 * @module Landing
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "./node_modules/mocha/lib/reporters/base.js");
var inherits = __webpack_require__(/*! ../utils */ "./node_modules/mocha/lib/utils.js").inherits;
var constants = __webpack_require__(/*! ../runner */ "./node_modules/mocha/lib/runner.js").constants;
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
var EVENT_RUN_END = constants.EVENT_RUN_END;
var EVENT_TEST_END = constants.EVENT_TEST_END;
var STATE_FAILED = __webpack_require__(/*! ../runnable */ "./node_modules/mocha/lib/runnable.js").constants.STATE_FAILED;

var cursor = Base.cursor;
var color = Base.color;

/**
 * Expose `Landing`.
 */

exports = module.exports = Landing;

/**
 * Airplane color.
 */

Base.colors.plane = 0;

/**
 * Airplane crash color.
 */

Base.colors['plane crash'] = 31;

/**
 * Runway color.
 */

Base.colors.runway = 90;

/**
 * Constructs a new `Landing` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function Landing(runner, options) {
  Base.call(this, runner, options);

  var self = this;
  var width = (Base.window.width * 0.75) | 0;
  var stream = process.stdout;

  var plane = color('plane', '');
  var crashed = -1;
  var n = 0;
  var total = 0;

  function runway() {
    var buf = Array(width).join('-');
    return '  ' + color('runway', buf);
  }

  runner.on(EVENT_RUN_BEGIN, function () {
    stream.write('\n\n\n  ');
    cursor.hide();
  });

  runner.on(EVENT_TEST_END, function (test) {
    // check if the plane crashed
    var col = crashed === -1 ? ((width * ++n) / ++total) | 0 : crashed;
    // show the crash
    if (test.state === STATE_FAILED) {
      plane = color('plane crash', '');
      crashed = col;
    }

    // render landing strip
    stream.write('\u001b[' + (width + 1) + 'D\u001b[2A');
    stream.write(runway());
    stream.write('\n  ');
    stream.write(color('runway', Array(col).join('')));
    stream.write(plane);
    stream.write(color('runway', Array(width - col).join('') + '\n'));
    stream.write(runway());
    stream.write('\u001b[0m');
  });

  runner.once(EVENT_RUN_END, function () {
    cursor.show();
    process.stdout.write('\n');
    self.epilogue();
  });

  // if cursor is hidden when we ctrl-C, then it will remain hidden unless...
  process.once('SIGINT', function () {
    cursor.show();
    process.nextTick(function () {
      process.kill(process.pid, 'SIGINT');
    });
  });
}

/**
 * Inherit from `Base.prototype`.
 */
inherits(Landing, Base);

Landing.description = 'Unicode landing strip';

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/list.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/list.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
/**
 * @module List
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "./node_modules/mocha/lib/reporters/base.js");
var inherits = __webpack_require__(/*! ../utils */ "./node_modules/mocha/lib/utils.js").inherits;
var constants = __webpack_require__(/*! ../runner */ "./node_modules/mocha/lib/runner.js").constants;
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
var EVENT_RUN_END = constants.EVENT_RUN_END;
var EVENT_TEST_BEGIN = constants.EVENT_TEST_BEGIN;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
var color = Base.color;
var cursor = Base.cursor;

/**
 * Expose `List`.
 */

exports = module.exports = List;

/**
 * Constructs a new `List` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function List(runner, options) {
  Base.call(this, runner, options);

  var self = this;
  var n = 0;

  runner.on(EVENT_RUN_BEGIN, function () {
    Base.consoleLog();
  });

  runner.on(EVENT_TEST_BEGIN, function (test) {
    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));
  });

  runner.on(EVENT_TEST_PENDING, function (test) {
    var fmt = color('checkmark', '  -') + color('pending', ' %s');
    Base.consoleLog(fmt, test.fullTitle());
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    var fmt =
      color('checkmark', '  ' + Base.symbols.ok) +
      color('pass', ' %s: ') +
      color(test.speed, '%dms');
    cursor.CR();
    Base.consoleLog(fmt, test.fullTitle(), test.duration);
  });

  runner.on(EVENT_TEST_FAIL, function (test) {
    cursor.CR();
    Base.consoleLog(color('fail', '  %d) %s'), ++n, test.fullTitle());
  });

  runner.once(EVENT_RUN_END, self.epilogue.bind(self));
}

/**
 * Inherit from `Base.prototype`.
 */
inherits(List, Base);

List.description = 'like "spec" reporter but flat';

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/markdown.js":
/*!******************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/markdown.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
/**
 * @module Markdown
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "./node_modules/mocha/lib/reporters/base.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/mocha/lib/utils.js");
var constants = __webpack_require__(/*! ../runner */ "./node_modules/mocha/lib/runner.js").constants;
var EVENT_RUN_END = constants.EVENT_RUN_END;
var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
var EVENT_SUITE_END = constants.EVENT_SUITE_END;
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;

/**
 * Constants
 */

var SUITE_PREFIX = '$';

/**
 * Expose `Markdown`.
 */

exports = module.exports = Markdown;

/**
 * Constructs a new `Markdown` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function Markdown(runner, options) {
  Base.call(this, runner, options);

  var level = 0;
  var buf = '';

  function title(str) {
    return Array(level).join('#') + ' ' + str;
  }

  function mapTOC(suite, obj) {
    var ret = obj;
    var key = SUITE_PREFIX + suite.title;

    obj = obj[key] = obj[key] || {suite: suite};
    suite.suites.forEach(function (suite) {
      mapTOC(suite, obj);
    });

    return ret;
  }

  function stringifyTOC(obj, level) {
    ++level;
    var buf = '';
    var link;
    for (var key in obj) {
      if (key === 'suite') {
        continue;
      }
      if (key !== SUITE_PREFIX) {
        link = ' - [' + key.substring(1) + ']';
        link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\n';
        buf += Array(level).join('  ') + link;
      }
      buf += stringifyTOC(obj[key], level);
    }
    return buf;
  }

  function generateTOC(suite) {
    var obj = mapTOC(suite, {});
    return stringifyTOC(obj, 0);
  }

  generateTOC(runner.suite);

  runner.on(EVENT_SUITE_BEGIN, function (suite) {
    ++level;
    var slug = utils.slug(suite.fullTitle());
    buf += '<a name="' + slug + '"></a>' + '\n';
    buf += title(suite.title) + '\n';
  });

  runner.on(EVENT_SUITE_END, function () {
    --level;
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    var code = utils.clean(test.body);
    buf += test.title + '.\n';
    buf += '\n```js\n';
    buf += code + '\n';
    buf += '```\n\n';
  });

  runner.once(EVENT_RUN_END, function () {
    process.stdout.write('# TOC\n');
    process.stdout.write(generateTOC(runner.suite));
    process.stdout.write(buf);
  });
}

Markdown.description = 'GitHub Flavored Markdown';

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/min.js":
/*!*************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/min.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
/**
 * @module Min
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "./node_modules/mocha/lib/reporters/base.js");
var inherits = __webpack_require__(/*! ../utils */ "./node_modules/mocha/lib/utils.js").inherits;
var constants = __webpack_require__(/*! ../runner */ "./node_modules/mocha/lib/runner.js").constants;
var EVENT_RUN_END = constants.EVENT_RUN_END;
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;

/**
 * Expose `Min`.
 */

exports = module.exports = Min;

/**
 * Constructs a new `Min` reporter instance.
 *
 * @description
 * This minimal test reporter is best used with '--watch'.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function Min(runner, options) {
  Base.call(this, runner, options);

  runner.on(EVENT_RUN_BEGIN, function () {
    // clear screen
    process.stdout.write('\u001b[2J');
    // set cursor position
    process.stdout.write('\u001b[1;3H');
  });

  runner.once(EVENT_RUN_END, this.epilogue.bind(this));
}

/**
 * Inherit from `Base.prototype`.
 */
inherits(Min, Base);

Min.description = 'essentially just a summary';

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/nyan.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/nyan.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
/**
 * @module Nyan
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "./node_modules/mocha/lib/reporters/base.js");
var constants = __webpack_require__(/*! ../runner */ "./node_modules/mocha/lib/runner.js").constants;
var inherits = __webpack_require__(/*! ../utils */ "./node_modules/mocha/lib/utils.js").inherits;
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_RUN_END = constants.EVENT_RUN_END;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;

/**
 * Expose `Dot`.
 */

exports = module.exports = NyanCat;

/**
 * Constructs a new `Nyan` reporter instance.
 *
 * @public
 * @class Nyan
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function NyanCat(runner, options) {
  Base.call(this, runner, options);

  var self = this;
  var width = (Base.window.width * 0.75) | 0;
  var nyanCatWidth = (this.nyanCatWidth = 11);

  this.colorIndex = 0;
  this.numberOfLines = 4;
  this.rainbowColors = self.generateColors();
  this.scoreboardWidth = 5;
  this.tick = 0;
  this.trajectories = [[], [], [], []];
  this.trajectoryWidthMax = width - nyanCatWidth;

  runner.on(EVENT_RUN_BEGIN, function () {
    Base.cursor.hide();
    self.draw();
  });

  runner.on(EVENT_TEST_PENDING, function () {
    self.draw();
  });

  runner.on(EVENT_TEST_PASS, function () {
    self.draw();
  });

  runner.on(EVENT_TEST_FAIL, function () {
    self.draw();
  });

  runner.once(EVENT_RUN_END, function () {
    Base.cursor.show();
    for (var i = 0; i < self.numberOfLines; i++) {
      write('\n');
    }
    self.epilogue();
  });
}

/**
 * Inherit from `Base.prototype`.
 */
inherits(NyanCat, Base);

/**
 * Draw the nyan cat
 *
 * @private
 */

NyanCat.prototype.draw = function () {
  this.appendRainbow();
  this.drawScoreboard();
  this.drawRainbow();
  this.drawNyanCat();
  this.tick = !this.tick;
};

/**
 * Draw the "scoreboard" showing the number
 * of passes, failures and pending tests.
 *
 * @private
 */

NyanCat.prototype.drawScoreboard = function () {
  var stats = this.stats;

  function draw(type, n) {
    write(' ');
    write(Base.color(type, n));
    write('\n');
  }

  draw('green', stats.passes);
  draw('fail', stats.failures);
  draw('pending', stats.pending);
  write('\n');

  this.cursorUp(this.numberOfLines);
};

/**
 * Append the rainbow.
 *
 * @private
 */

NyanCat.prototype.appendRainbow = function () {
  var segment = this.tick ? '_' : '-';
  var rainbowified = this.rainbowify(segment);

  for (var index = 0; index < this.numberOfLines; index++) {
    var trajectory = this.trajectories[index];
    if (trajectory.length >= this.trajectoryWidthMax) {
      trajectory.shift();
    }
    trajectory.push(rainbowified);
  }
};

/**
 * Draw the rainbow.
 *
 * @private
 */

NyanCat.prototype.drawRainbow = function () {
  var self = this;

  this.trajectories.forEach(function (line) {
    write('\u001b[' + self.scoreboardWidth + 'C');
    write(line.join(''));
    write('\n');
  });

  this.cursorUp(this.numberOfLines);
};

/**
 * Draw the nyan cat
 *
 * @private
 */
NyanCat.prototype.drawNyanCat = function () {
  var self = this;
  var startWidth = this.scoreboardWidth + this.trajectories[0].length;
  var dist = '\u001b[' + startWidth + 'C';
  var padding = '';

  write(dist);
  write('_,------,');
  write('\n');

  write(dist);
  padding = self.tick ? '  ' : '   ';
  write('_|' + padding + '/\\_/\\ ');
  write('\n');

  write(dist);
  padding = self.tick ? '_' : '__';
  var tail = self.tick ? '~' : '^';
  write(tail + '|' + padding + this.face() + ' ');
  write('\n');

  write(dist);
  padding = self.tick ? ' ' : '  ';
  write(padding + '""  "" ');
  write('\n');

  this.cursorUp(this.numberOfLines);
};

/**
 * Draw nyan cat face.
 *
 * @private
 * @return {string}
 */

NyanCat.prototype.face = function () {
  var stats = this.stats;
  if (stats.failures) {
    return '( x .x)';
  } else if (stats.pending) {
    return '( o .o)';
  } else if (stats.passes) {
    return '( ^ .^)';
  }
  return '( - .-)';
};

/**
 * Move cursor up `n`.
 *
 * @private
 * @param {number} n
 */

NyanCat.prototype.cursorUp = function (n) {
  write('\u001b[' + n + 'A');
};

/**
 * Move cursor down `n`.
 *
 * @private
 * @param {number} n
 */

NyanCat.prototype.cursorDown = function (n) {
  write('\u001b[' + n + 'B');
};

/**
 * Generate rainbow colors.
 *
 * @private
 * @return {Array}
 */
NyanCat.prototype.generateColors = function () {
  var colors = [];

  for (var i = 0; i < 6 * 7; i++) {
    var pi3 = Math.floor(Math.PI / 3);
    var n = i * (1.0 / 6);
    var r = Math.floor(3 * Math.sin(n) + 3);
    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);
    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);
    colors.push(36 * r + 6 * g + b + 16);
  }

  return colors;
};

/**
 * Apply rainbow to the given `str`.
 *
 * @private
 * @param {string} str
 * @return {string}
 */
NyanCat.prototype.rainbowify = function (str) {
  if (!Base.useColors) {
    return str;
  }
  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];
  this.colorIndex += 1;
  return '\u001b[38;5;' + color + 'm' + str + '\u001b[0m';
};

/**
 * Stdout helper.
 *
 * @param {string} string A message to write to stdout.
 */
function write(string) {
  process.stdout.write(string);
}

NyanCat.description = '"nyan cat"';

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/progress.js":
/*!******************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/progress.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
/**
 * @module Progress
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "./node_modules/mocha/lib/reporters/base.js");
var constants = __webpack_require__(/*! ../runner */ "./node_modules/mocha/lib/runner.js").constants;
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
var EVENT_TEST_END = constants.EVENT_TEST_END;
var EVENT_RUN_END = constants.EVENT_RUN_END;
var inherits = __webpack_require__(/*! ../utils */ "./node_modules/mocha/lib/utils.js").inherits;
var color = Base.color;
var cursor = Base.cursor;

/**
 * Expose `Progress`.
 */

exports = module.exports = Progress;

/**
 * General progress bar color.
 */

Base.colors.progress = 90;

/**
 * Constructs a new `Progress` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function Progress(runner, options) {
  Base.call(this, runner, options);

  var self = this;
  var width = (Base.window.width * 0.5) | 0;
  var total = runner.total;
  var complete = 0;
  var lastN = -1;

  // default chars
  options = options || {};
  var reporterOptions = options.reporterOptions || {};

  options.open = reporterOptions.open || '[';
  options.complete = reporterOptions.complete || '';
  options.incomplete = reporterOptions.incomplete || Base.symbols.dot;
  options.close = reporterOptions.close || ']';
  options.verbose = reporterOptions.verbose || false;

  // tests started
  runner.on(EVENT_RUN_BEGIN, function () {
    process.stdout.write('\n');
    cursor.hide();
  });

  // tests complete
  runner.on(EVENT_TEST_END, function () {
    complete++;

    var percent = complete / total;
    var n = (width * percent) | 0;
    var i = width - n;

    if (n === lastN && !options.verbose) {
      // Don't re-render the line if it hasn't changed
      return;
    }
    lastN = n;

    cursor.CR();
    process.stdout.write('\u001b[J');
    process.stdout.write(color('progress', '  ' + options.open));
    process.stdout.write(Array(n).join(options.complete));
    process.stdout.write(Array(i).join(options.incomplete));
    process.stdout.write(color('progress', options.close));
    if (options.verbose) {
      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));
    }
  });

  // tests are complete, output some stats
  // and the failures if any
  runner.once(EVENT_RUN_END, function () {
    cursor.show();
    process.stdout.write('\n');
    self.epilogue();
  });
}

/**
 * Inherit from `Base.prototype`.
 */
inherits(Progress, Base);

Progress.description = 'a progress bar';

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/spec.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/spec.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @module Spec
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "./node_modules/mocha/lib/reporters/base.js");
var constants = __webpack_require__(/*! ../runner */ "./node_modules/mocha/lib/runner.js").constants;
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
var EVENT_RUN_END = constants.EVENT_RUN_END;
var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
var EVENT_SUITE_END = constants.EVENT_SUITE_END;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
var inherits = __webpack_require__(/*! ../utils */ "./node_modules/mocha/lib/utils.js").inherits;
var color = Base.color;

/**
 * Expose `Spec`.
 */

exports = module.exports = Spec;

/**
 * Constructs a new `Spec` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function Spec(runner, options) {
  Base.call(this, runner, options);

  var self = this;
  var indents = 0;
  var n = 0;

  function indent() {
    return Array(indents).join('  ');
  }

  runner.on(EVENT_RUN_BEGIN, function () {
    Base.consoleLog();
  });

  runner.on(EVENT_SUITE_BEGIN, function (suite) {
    ++indents;
    Base.consoleLog(color('suite', '%s%s'), indent(), suite.title);
  });

  runner.on(EVENT_SUITE_END, function () {
    --indents;
    if (indents === 1) {
      Base.consoleLog();
    }
  });

  runner.on(EVENT_TEST_PENDING, function (test) {
    var fmt = indent() + color('pending', '  - %s');
    Base.consoleLog(fmt, test.title);
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    var fmt;
    if (test.speed === 'fast') {
      fmt =
        indent() +
        color('checkmark', '  ' + Base.symbols.ok) +
        color('pass', ' %s');
      Base.consoleLog(fmt, test.title);
    } else {
      fmt =
        indent() +
        color('checkmark', '  ' + Base.symbols.ok) +
        color('pass', ' %s') +
        color(test.speed, ' (%dms)');
      Base.consoleLog(fmt, test.title, test.duration);
    }
  });

  runner.on(EVENT_TEST_FAIL, function (test) {
    Base.consoleLog(indent() + color('fail', '  %d) %s'), ++n, test.title);
  });

  runner.once(EVENT_RUN_END, self.epilogue.bind(self));
}

/**
 * Inherit from `Base.prototype`.
 */
inherits(Spec, Base);

Spec.description = 'hierarchical & verbose [default]';


/***/ }),

/***/ "./node_modules/mocha/lib/reporters/tap.js":
/*!*************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/tap.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
/**
 * @module TAP
 */
/**
 * Module dependencies.
 */

var util = __webpack_require__(/*! util */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/util/util.js");
var Base = __webpack_require__(/*! ./base */ "./node_modules/mocha/lib/reporters/base.js");
var constants = __webpack_require__(/*! ../runner */ "./node_modules/mocha/lib/runner.js").constants;
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
var EVENT_RUN_END = constants.EVENT_RUN_END;
var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
var EVENT_TEST_END = constants.EVENT_TEST_END;
var inherits = __webpack_require__(/*! ../utils */ "./node_modules/mocha/lib/utils.js").inherits;
var sprintf = util.format;

/**
 * Expose `TAP`.
 */

exports = module.exports = TAP;

/**
 * Constructs a new `TAP` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function TAP(runner, options) {
  Base.call(this, runner, options);

  var self = this;
  var n = 1;

  var tapVersion = '12';
  if (options && options.reporterOptions) {
    if (options.reporterOptions.tapVersion) {
      tapVersion = options.reporterOptions.tapVersion.toString();
    }
  }

  this._producer = createProducer(tapVersion);

  runner.once(EVENT_RUN_BEGIN, function () {
    self._producer.writeVersion();
  });

  runner.on(EVENT_TEST_END, function () {
    ++n;
  });

  runner.on(EVENT_TEST_PENDING, function (test) {
    self._producer.writePending(n, test);
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    self._producer.writePass(n, test);
  });

  runner.on(EVENT_TEST_FAIL, function (test, err) {
    self._producer.writeFail(n, test, err);
  });

  runner.once(EVENT_RUN_END, function () {
    self._producer.writeEpilogue(runner.stats);
  });
}

/**
 * Inherit from `Base.prototype`.
 */
inherits(TAP, Base);

/**
 * Returns a TAP-safe title of `test`.
 *
 * @private
 * @param {Test} test - Test instance.
 * @return {String} title with any hash character removed
 */
function title(test) {
  return test.fullTitle().replace(/#/g, '');
}

/**
 * Writes newline-terminated formatted string to reporter output stream.
 *
 * @private
 * @param {string} format - `printf`-like format string
 * @param {...*} [varArgs] - Format string arguments
 */
function println(format, varArgs) {
  var vargs = Array.from(arguments);
  vargs[0] += '\n';
  process.stdout.write(sprintf.apply(null, vargs));
}

/**
 * Returns a `tapVersion`-appropriate TAP producer instance, if possible.
 *
 * @private
 * @param {string} tapVersion - Version of TAP specification to produce.
 * @returns {TAPProducer} specification-appropriate instance
 * @throws {Error} if specification version has no associated producer.
 */
function createProducer(tapVersion) {
  var producers = {
    12: new TAP12Producer(),
    13: new TAP13Producer()
  };
  var producer = producers[tapVersion];

  if (!producer) {
    throw new Error(
      'invalid or unsupported TAP version: ' + JSON.stringify(tapVersion)
    );
  }

  return producer;
}

/**
 * @summary
 * Constructs a new TAPProducer.
 *
 * @description
 * <em>Only</em> to be used as an abstract base class.
 *
 * @private
 * @constructor
 */
function TAPProducer() {}

/**
 * Writes the TAP version to reporter output stream.
 *
 * @abstract
 */
TAPProducer.prototype.writeVersion = function () {};

/**
 * Writes the plan to reporter output stream.
 *
 * @abstract
 * @param {number} ntests - Number of tests that are planned to run.
 */
TAPProducer.prototype.writePlan = function (ntests) {
  println('%d..%d', 1, ntests);
};

/**
 * Writes that test passed to reporter output stream.
 *
 * @abstract
 * @param {number} n - Index of test that passed.
 * @param {Test} test - Instance containing test information.
 */
TAPProducer.prototype.writePass = function (n, test) {
  println('ok %d %s', n, title(test));
};

/**
 * Writes that test was skipped to reporter output stream.
 *
 * @abstract
 * @param {number} n - Index of test that was skipped.
 * @param {Test} test - Instance containing test information.
 */
TAPProducer.prototype.writePending = function (n, test) {
  println('ok %d %s # SKIP -', n, title(test));
};

/**
 * Writes that test failed to reporter output stream.
 *
 * @abstract
 * @param {number} n - Index of test that failed.
 * @param {Test} test - Instance containing test information.
 * @param {Error} err - Reason the test failed.
 */
TAPProducer.prototype.writeFail = function (n, test, err) {
  println('not ok %d %s', n, title(test));
};

/**
 * Writes the summary epilogue to reporter output stream.
 *
 * @abstract
 * @param {Object} stats - Object containing run statistics.
 */
TAPProducer.prototype.writeEpilogue = function (stats) {
  // :TBD: Why is this not counting pending tests?
  println('# tests ' + (stats.passes + stats.failures));
  println('# pass ' + stats.passes);
  // :TBD: Why are we not showing pending results?
  println('# fail ' + stats.failures);
  this.writePlan(stats.passes + stats.failures + stats.pending);
};

/**
 * @summary
 * Constructs a new TAP12Producer.
 *
 * @description
 * Produces output conforming to the TAP12 specification.
 *
 * @private
 * @constructor
 * @extends TAPProducer
 * @see {@link https://testanything.org/tap-specification.html|Specification}
 */
function TAP12Producer() {
  /**
   * Writes that test failed to reporter output stream, with error formatting.
   * @override
   */
  this.writeFail = function (n, test, err) {
    TAPProducer.prototype.writeFail.call(this, n, test, err);
    if (err.message) {
      println(err.message.replace(/^/gm, '  '));
    }
    if (err.stack) {
      println(err.stack.replace(/^/gm, '  '));
    }
  };
}

/**
 * Inherit from `TAPProducer.prototype`.
 */
inherits(TAP12Producer, TAPProducer);

/**
 * @summary
 * Constructs a new TAP13Producer.
 *
 * @description
 * Produces output conforming to the TAP13 specification.
 *
 * @private
 * @constructor
 * @extends TAPProducer
 * @see {@link https://testanything.org/tap-version-13-specification.html|Specification}
 */
function TAP13Producer() {
  /**
   * Writes the TAP version to reporter output stream.
   * @override
   */
  this.writeVersion = function () {
    println('TAP version 13');
  };

  /**
   * Writes that test failed to reporter output stream, with error formatting.
   * @override
   */
  this.writeFail = function (n, test, err) {
    TAPProducer.prototype.writeFail.call(this, n, test, err);
    var emitYamlBlock = err.message != null || err.stack != null;
    if (emitYamlBlock) {
      println(indent(1) + '---');
      if (err.message) {
        println(indent(2) + 'message: |-');
        println(err.message.replace(/^/gm, indent(3)));
      }
      if (err.stack) {
        println(indent(2) + 'stack: |-');
        println(err.stack.replace(/^/gm, indent(3)));
      }
      println(indent(1) + '...');
    }
  };

  function indent(level) {
    return Array(level + 1).join('  ');
  }
}

/**
 * Inherit from `TAPProducer.prototype`.
 */
inherits(TAP13Producer, TAPProducer);

TAP.description = 'TAP-compatible output';

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/xunit.js":
/*!***************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/xunit.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {
/**
 * @module XUnit
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "./node_modules/mocha/lib/reporters/base.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/mocha/lib/utils.js");
var fs = __webpack_require__(/*! fs */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/@packages/server/node_modules/@cypress/webpack-batteries-included-preprocessor/empty.js");
var path = __webpack_require__(/*! path */ 5);
var errors = __webpack_require__(/*! ../errors */ "./node_modules/mocha/lib/errors.js");
var createUnsupportedError = errors.createUnsupportedError;
var constants = __webpack_require__(/*! ../runner */ "./node_modules/mocha/lib/runner.js").constants;
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_RUN_END = constants.EVENT_RUN_END;
var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
var STATE_FAILED = __webpack_require__(/*! ../runnable */ "./node_modules/mocha/lib/runnable.js").constants.STATE_FAILED;
var inherits = utils.inherits;
var escape = utils.escape;

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 */
var Date = global.Date;

/**
 * Expose `XUnit`.
 */

exports = module.exports = XUnit;

/**
 * Constructs a new `XUnit` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function XUnit(runner, options) {
  Base.call(this, runner, options);

  var stats = this.stats;
  var tests = [];
  var self = this;

  // the name of the test suite, as it will appear in the resulting XML file
  var suiteName;

  // the default name of the test suite if none is provided
  var DEFAULT_SUITE_NAME = 'Mocha Tests';

  if (options && options.reporterOptions) {
    if (options.reporterOptions.output) {
      if (!fs.createWriteStream) {
        throw createUnsupportedError('file output not supported in browser');
      }

      fs.mkdirSync(path.dirname(options.reporterOptions.output), {
        recursive: true
      });
      self.fileStream = fs.createWriteStream(options.reporterOptions.output);
    }

    // get the suite name from the reporter options (if provided)
    suiteName = options.reporterOptions.suiteName;
  }

  // fall back to the default suite name
  suiteName = suiteName || DEFAULT_SUITE_NAME;

  runner.on(EVENT_TEST_PENDING, function (test) {
    tests.push(test);
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    tests.push(test);
  });

  runner.on(EVENT_TEST_FAIL, function (test) {
    tests.push(test);
  });

  runner.once(EVENT_RUN_END, function () {
    self.write(
      tag(
        'testsuite',
        {
          name: suiteName,
          tests: stats.tests,
          failures: 0,
          errors: stats.failures,
          skipped: stats.tests - stats.failures - stats.passes,
          timestamp: new Date().toUTCString(),
          time: stats.duration / 1000 || 0
        },
        false
      )
    );

    tests.forEach(function (t) {
      self.test(t);
    });

    self.write('</testsuite>');
  });
}

/**
 * Inherit from `Base.prototype`.
 */
inherits(XUnit, Base);

/**
 * Override done to close the stream (if it's a file).
 *
 * @param failures
 * @param {Function} fn
 */
XUnit.prototype.done = function (failures, fn) {
  if (this.fileStream) {
    this.fileStream.end(function () {
      fn(failures);
    });
  } else {
    fn(failures);
  }
};

/**
 * Write out the given line.
 *
 * @param {string} line
 */
XUnit.prototype.write = function (line) {
  if (this.fileStream) {
    this.fileStream.write(line + '\n');
  } else if (typeof process === 'object' && process.stdout) {
    process.stdout.write(line + '\n');
  } else {
    Base.consoleLog(line);
  }
};

/**
 * Output tag for the given `test.`
 *
 * @param {Test} test
 */
XUnit.prototype.test = function (test) {
  Base.useColors = false;

  var attrs = {
    classname: test.parent.fullTitle(),
    name: test.title,
    time: test.duration / 1000 || 0
  };

  if (test.state === STATE_FAILED) {
    var err = test.err;
    var diff =
      !Base.hideDiff && Base.showDiff(err)
        ? '\n' + Base.generateDiff(err.actual, err.expected)
        : '';
    this.write(
      tag(
        'testcase',
        attrs,
        false,
        tag(
          'failure',
          {},
          false,
          escape(err.message) + escape(diff) + '\n' + escape(err.stack)
        )
      )
    );
  } else if (test.isPending()) {
    this.write(tag('testcase', attrs, false, tag('skipped', {}, true)));
  } else {
    this.write(tag('testcase', attrs, true));
  }
};

/**
 * HTML tag helper.
 *
 * @param name
 * @param attrs
 * @param close
 * @param content
 * @return {string}
 */
function tag(name, attrs, close, content) {
  var end = close ? '/>' : '>';
  var pairs = [];
  var tag;

  for (var key in attrs) {
    if (Object.prototype.hasOwnProperty.call(attrs, key)) {
      pairs.push(key + '="' + escape(attrs[key]) + '"');
    }
  }

  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;
  if (content) {
    tag += content + '</' + name + end;
  }
  return tag;
}

XUnit.description = 'XUnit-compatible XML output';

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mocha/lib/runnable.js":
/*!********************************************!*\
  !*** ./node_modules/mocha/lib/runnable.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var EventEmitter = __webpack_require__(/*! events */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/events/events.js").EventEmitter;
var Pending = __webpack_require__(/*! ./pending */ "./node_modules/mocha/lib/pending.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('mocha:runnable');
var milliseconds = __webpack_require__(/*! ms */ "./node_modules/mocha/node_modules/ms/index.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/mocha/lib/utils.js");
const {
  createInvalidExceptionError,
  createMultipleDoneError,
  createTimeoutError
} = __webpack_require__(/*! ./errors */ "./node_modules/mocha/lib/errors.js");

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 * @private
 */
var Date = global.Date;
var setTimeout = global.setTimeout;
var clearTimeout = global.clearTimeout;
var toString = Object.prototype.toString;

module.exports = Runnable;

/**
 * Initialize a new `Runnable` with the given `title` and callback `fn`.
 *
 * @class
 * @extends external:EventEmitter
 * @public
 * @param {String} title
 * @param {Function} fn
 */
function Runnable(title, fn) {
  this.title = title;
  this.fn = fn;
  this.body = (fn || '').toString();
  this.async = fn && fn.length;
  this.sync = !this.async;
  this._timeout = 2000;
  this._slow = 75;
  this._retries = -1;
  utils.assignNewMochaID(this);
  Object.defineProperty(this, 'id', {
    get() {
      return utils.getMochaID(this);
    }
  });
  this.reset();
}

/**
 * Inherit from `EventEmitter.prototype`.
 */
utils.inherits(Runnable, EventEmitter);

/**
 * Resets the state initially or for a next run.
 */
Runnable.prototype.reset = function () {
  this.timedOut = false;
  this._currentRetry = 0;
  this.pending = false;
  delete this.state;
  delete this.err;
};

/**
 * Get current timeout value in msecs.
 *
 * @private
 * @returns {number} current timeout threshold value
 */
/**
 * @summary
 * Set timeout threshold value (msecs).
 *
 * @description
 * A string argument can use shorthand (e.g., "2s") and will be converted.
 * The value will be clamped to range [<code>0</code>, <code>2^<sup>31</sup>-1</code>].
 * If clamped value matches either range endpoint, timeouts will be disabled.
 *
 * @private
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout#Maximum_delay_value}
 * @param {number|string} ms - Timeout threshold value.
 * @returns {Runnable} this
 * @chainable
 */
Runnable.prototype.timeout = function (ms) {
  if (!arguments.length) {
    return this._timeout;
  }
  if (typeof ms === 'string') {
    ms = milliseconds(ms);
  }

  // Clamp to range
  var INT_MAX = Math.pow(2, 31) - 1;
  var range = [0, INT_MAX];
  ms = utils.clamp(ms, range);

  // see #1652 for reasoning
  if (ms === range[0] || ms === range[1]) {
    this._timeout = 0;
  } else {
    this._timeout = ms;
  }
  debug('timeout %d', this._timeout);

  if (this.timer) {
    this.resetTimeout();
  }
  return this;
};

/**
 * Set or get slow `ms`.
 *
 * @private
 * @param {number|string} ms
 * @return {Runnable|number} ms or Runnable instance.
 */
Runnable.prototype.slow = function (ms) {
  if (!arguments.length || typeof ms === 'undefined') {
    return this._slow;
  }
  if (typeof ms === 'string') {
    ms = milliseconds(ms);
  }
  debug('slow %d', ms);
  this._slow = ms;
  return this;
};

/**
 * Halt and mark as pending.
 *
 * @memberof Mocha.Runnable
 * @public
 */
Runnable.prototype.skip = function () {
  this.pending = true;
  throw new Pending('sync skip; aborting execution');
};

/**
 * Check if this runnable or its parent suite is marked as pending.
 *
 * @private
 */
Runnable.prototype.isPending = function () {
  return this.pending || (this.parent && this.parent.isPending());
};

/**
 * Return `true` if this Runnable has failed.
 * @return {boolean}
 * @private
 */
Runnable.prototype.isFailed = function () {
  return !this.isPending() && this.state === constants.STATE_FAILED;
};

/**
 * Return `true` if this Runnable has passed.
 * @return {boolean}
 * @private
 */
Runnable.prototype.isPassed = function () {
  return !this.isPending() && this.state === constants.STATE_PASSED;
};

/**
 * Set or get number of retries.
 *
 * @private
 */
Runnable.prototype.retries = function (n) {
  if (!arguments.length) {
    return this._retries;
  }
  this._retries = n;
};

/**
 * Set or get current retry
 *
 * @private
 */
Runnable.prototype.currentRetry = function (n) {
  if (!arguments.length) {
    return this._currentRetry;
  }
  this._currentRetry = n;
};

/**
 * Return the full title generated by recursively concatenating the parent's
 * full title.
 *
 * @memberof Mocha.Runnable
 * @public
 * @return {string}
 */
Runnable.prototype.fullTitle = function () {
  return this.titlePath().join(' ');
};

/**
 * Return the title path generated by concatenating the parent's title path with the title.
 *
 * @memberof Mocha.Runnable
 * @public
 * @return {string}
 */
Runnable.prototype.titlePath = function () {
  return this.parent.titlePath().concat([this.title]);
};

/**
 * Clear the timeout.
 *
 * @private
 */
Runnable.prototype.clearTimeout = function () {
  clearTimeout(this.timer);
};

/**
 * Reset the timeout.
 *
 * @private
 */
Runnable.prototype.resetTimeout = function () {
  var self = this;
  var ms = this.timeout();

  if (ms === 0) {
    return;
  }
  this.clearTimeout();
  this.timer = setTimeout(function () {
    if (self.timeout() === 0) {
      return;
    }
    self.callback(self._timeoutError(ms));
    self.timedOut = true;
  }, ms);
};

/**
 * Set or get a list of whitelisted globals for this test run.
 *
 * @private
 * @param {string[]} globals
 */
Runnable.prototype.globals = function (globals) {
  if (!arguments.length) {
    return this._allowedGlobals;
  }
  this._allowedGlobals = globals;
};

/**
 * Run the test and invoke `fn(err)`.
 *
 * @param {Function} fn
 * @private
 */
Runnable.prototype.run = function (fn) {
  var self = this;
  var start = new Date();
  var ctx = this.ctx;
  var finished;
  var errorWasHandled = false;

  if (this.isPending()) return fn();

  // Sometimes the ctx exists, but it is not runnable
  if (ctx && ctx.runnable) {
    ctx.runnable(this);
  }

  // called multiple times
  function multiple(err) {
    if (errorWasHandled) {
      return;
    }
    errorWasHandled = true;
    self.emit('error', createMultipleDoneError(self, err));
  }

  // finished
  function done(err) {
    var ms = self.timeout();
    if (self.timedOut) {
      return;
    }

    if (finished) {
      return multiple(err);
    }

    self.clearTimeout();
    self.duration = new Date() - start;
    finished = true;
    if (!err && self.duration > ms && ms > 0) {
      err = self._timeoutError(ms);
    }
    fn(err);
  }

  // for .resetTimeout() and Runner#uncaught()
  this.callback = done;

  if (this.fn && typeof this.fn.call !== 'function') {
    done(
      new TypeError(
        'A runnable must be passed a function as its second argument.'
      )
    );
    return;
  }

  // explicit async with `done` argument
  if (this.async) {
    this.resetTimeout();

    // allows skip() to be used in an explicit async context
    this.skip = function asyncSkip() {
      this.pending = true;
      done();
      // halt execution, the uncaught handler will ignore the failure.
      throw new Pending('async skip; aborting execution');
    };

    try {
      callFnAsync(this.fn);
    } catch (err) {
      // handles async runnables which actually run synchronously
      errorWasHandled = true;
      if (err instanceof Pending) {
        return; // done() is already called in this.skip()
      } else if (this.allowUncaught) {
        throw err;
      }
      done(Runnable.toValueOrError(err));
    }
    return;
  }

  // sync or promise-returning
  try {
    callFn(this.fn);
  } catch (err) {
    errorWasHandled = true;
    if (err instanceof Pending) {
      return done();
    } else if (this.allowUncaught) {
      throw err;
    }
    done(Runnable.toValueOrError(err));
  }

  function callFn(fn) {
    var result = fn.call(ctx);
    if (result && typeof result.then === 'function') {
      self.resetTimeout();
      result.then(
        function () {
          done();
          // Return null so libraries like bluebird do not warn about
          // subsequently constructed Promises.
          return null;
        },
        function (reason) {
          done(reason || new Error('Promise rejected with no or falsy reason'));
        }
      );
    } else {
      if (self.asyncOnly) {
        return done(
          new Error(
            '--async-only option in use without declaring `done()` or returning a promise'
          )
        );
      }

      done();
    }
  }

  function callFnAsync(fn) {
    var result = fn.call(ctx, function (err) {
      if (err instanceof Error || toString.call(err) === '[object Error]') {
        return done(err);
      }
      if (err) {
        if (Object.prototype.toString.call(err) === '[object Object]') {
          return done(
            new Error('done() invoked with non-Error: ' + JSON.stringify(err))
          );
        }
        return done(new Error('done() invoked with non-Error: ' + err));
      }
      if (result && utils.isPromise(result)) {
        return done(
          new Error(
            'Resolution method is overspecified. Specify a callback *or* return a Promise; not both.'
          )
        );
      }

      done();
    });
  }
};

/**
 * Instantiates a "timeout" error
 *
 * @param {number} ms - Timeout (in milliseconds)
 * @returns {Error} a "timeout" error
 * @private
 */
Runnable.prototype._timeoutError = function (ms) {
  let msg = `Timeout of ${ms}ms exceeded. For async tests and hooks, ensure "done()" is called; if returning a Promise, ensure it resolves.`;
  if (this.file) {
    msg += ' (' + this.file + ')';
  }
  return createTimeoutError(msg, ms, this.file);
};

var constants = utils.defineConstants(
  /**
   * {@link Runnable}-related constants.
   * @public
   * @memberof Runnable
   * @readonly
   * @static
   * @alias constants
   * @enum {string}
   */
  {
    /**
     * Value of `state` prop when a `Runnable` has failed
     */
    STATE_FAILED: 'failed',
    /**
     * Value of `state` prop when a `Runnable` has passed
     */
    STATE_PASSED: 'passed',
    /**
     * Value of `state` prop when a `Runnable` has been skipped by user
     */
    STATE_PENDING: 'pending'
  }
);

/**
 * Given `value`, return identity if truthy, otherwise create an "invalid exception" error and return that.
 * @param {*} [value] - Value to return, if present
 * @returns {*|Error} `value`, otherwise an `Error`
 * @private
 */
Runnable.toValueOrError = function (value) {
  return (
    value ||
    createInvalidExceptionError(
      'Runnable failed with falsy or undefined exception. Please throw an Error instead.',
      value
    )
  );
};

Runnable.constants = constants;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/mocha/lib/runner.js":
/*!******************************************!*\
  !*** ./node_modules/mocha/lib/runner.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global) {

/**
 * Module dependencies.
 * @private
 */
var EventEmitter = __webpack_require__(/*! events */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/events/events.js").EventEmitter;
var Pending = __webpack_require__(/*! ./pending */ "./node_modules/mocha/lib/pending.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/mocha/lib/utils.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('mocha:runner');
var Runnable = __webpack_require__(/*! ./runnable */ "./node_modules/mocha/lib/runnable.js");
var Suite = __webpack_require__(/*! ./suite */ "./node_modules/mocha/lib/suite.js");
var HOOK_TYPE_BEFORE_EACH = Suite.constants.HOOK_TYPE_BEFORE_EACH;
var HOOK_TYPE_AFTER_EACH = Suite.constants.HOOK_TYPE_AFTER_EACH;
var HOOK_TYPE_AFTER_ALL = Suite.constants.HOOK_TYPE_AFTER_ALL;
var HOOK_TYPE_BEFORE_ALL = Suite.constants.HOOK_TYPE_BEFORE_ALL;
var EVENT_ROOT_SUITE_RUN = Suite.constants.EVENT_ROOT_SUITE_RUN;
var STATE_FAILED = Runnable.constants.STATE_FAILED;
var STATE_PASSED = Runnable.constants.STATE_PASSED;
var STATE_PENDING = Runnable.constants.STATE_PENDING;
var stackFilter = utils.stackTraceFilter();
var stringify = utils.stringify;

const {
  createInvalidExceptionError,
  createUnsupportedError,
  createFatalError,
  isMochaError,
  constants: errorConstants
} = __webpack_require__(/*! ./errors */ "./node_modules/mocha/lib/errors.js");

/**
 * Non-enumerable globals.
 * @private
 * @readonly
 */
var globals = [
  'setTimeout',
  'clearTimeout',
  'setInterval',
  'clearInterval',
  'XMLHttpRequest',
  'Date',
  'setImmediate',
  'clearImmediate'
];

var constants = utils.defineConstants(
  /**
   * {@link Runner}-related constants.
   * @public
   * @memberof Runner
   * @readonly
   * @alias constants
   * @static
   * @enum {string}
   */
  {
    /**
     * Emitted when {@link Hook} execution begins
     */
    EVENT_HOOK_BEGIN: 'hook',
    /**
     * Emitted when {@link Hook} execution ends
     */
    EVENT_HOOK_END: 'hook end',
    /**
     * Emitted when Root {@link Suite} execution begins (all files have been parsed and hooks/tests are ready for execution)
     */
    EVENT_RUN_BEGIN: 'start',
    /**
     * Emitted when Root {@link Suite} execution has been delayed via `delay` option
     */
    EVENT_DELAY_BEGIN: 'waiting',
    /**
     * Emitted when delayed Root {@link Suite} execution is triggered by user via `global.run()`
     */
    EVENT_DELAY_END: 'ready',
    /**
     * Emitted when Root {@link Suite} execution ends
     */
    EVENT_RUN_END: 'end',
    /**
     * Emitted when {@link Suite} execution begins
     */
    EVENT_SUITE_BEGIN: 'suite',
    /**
     * Emitted when {@link Suite} execution ends
     */
    EVENT_SUITE_END: 'suite end',
    /**
     * Emitted when {@link Test} execution begins
     */
    EVENT_TEST_BEGIN: 'test',
    /**
     * Emitted when {@link Test} execution ends
     */
    EVENT_TEST_END: 'test end',
    /**
     * Emitted when {@link Test} execution fails
     */
    EVENT_TEST_FAIL: 'fail',
    /**
     * Emitted when {@link Test} execution succeeds
     */
    EVENT_TEST_PASS: 'pass',
    /**
     * Emitted when {@link Test} becomes pending
     */
    EVENT_TEST_PENDING: 'pending',
    /**
     * Emitted when {@link Test} execution has failed, but will retry
     */
    EVENT_TEST_RETRY: 'retry',
    /**
     * Initial state of Runner
     */
    STATE_IDLE: 'idle',
    /**
     * State set to this value when the Runner has started running
     */
    STATE_RUNNING: 'running',
    /**
     * State set to this value when the Runner has stopped
     */
    STATE_STOPPED: 'stopped'
  }
);

class Runner extends EventEmitter {
  /**
   * Initialize a `Runner` at the Root {@link Suite}, which represents a hierarchy of {@link Suite|Suites} and {@link Test|Tests}.
   *
   * @extends external:EventEmitter
   * @public
   * @class
   * @param {Suite} suite - Root suite
   * @param {Object} [opts] - Settings object
   * @param {boolean} [opts.cleanReferencesAfterRun] - Whether to clean references to test fns and hooks when a suite is done.
   * @param {boolean} [opts.delay] - Whether to delay execution of root suite until ready.
   * @param {boolean} [opts.dryRun] - Whether to report tests without running them.
   * @param {boolean} [opts.failZero] - Whether to fail test run if zero tests encountered.
   */
  constructor(suite, opts = {}) {
    super();

    var self = this;
    this._globals = [];
    this._abort = false;
    this.suite = suite;
    this._opts = opts;
    this.state = constants.STATE_IDLE;
    this.total = suite.total();
    this.failures = 0;
    /**
     * @type {Map<EventEmitter,Map<string,Set<EventListener>>>}
     */
    this._eventListeners = new Map();
    this.on(constants.EVENT_TEST_END, function (test) {
      if (test.type === 'test' && test.retriedTest() && test.parent) {
        var idx =
          test.parent.tests && test.parent.tests.indexOf(test.retriedTest());
        if (idx > -1) test.parent.tests[idx] = test;
      }
      self.checkGlobals(test);
    });
    this.on(constants.EVENT_HOOK_END, function (hook) {
      self.checkGlobals(hook);
    });
    this._defaultGrep = /.*/;
    this.grep(this._defaultGrep);
    this.globals(this.globalProps());

    this.uncaught = this._uncaught.bind(this);
    this.unhandled = (reason, promise) => {
      if (isMochaError(reason)) {
        debug(
          'trapped unhandled rejection coming out of Mocha; forwarding to uncaught handler:',
          reason
        );
        this.uncaught(reason);
      } else {
        debug(
          'trapped unhandled rejection from (probably) user code; re-emitting on process'
        );
        this._removeEventListener(
          process,
          'unhandledRejection',
          this.unhandled
        );
        try {
          process.emit('unhandledRejection', reason, promise);
        } finally {
          this._addEventListener(process, 'unhandledRejection', this.unhandled);
        }
      }
    };
  }
}

/**
 * Wrapper for setImmediate, process.nextTick, or browser polyfill.
 *
 * @param {Function} fn
 * @private
 */
Runner.immediately = global.setImmediate || process.nextTick;

/**
 * Replacement for `target.on(eventName, listener)` that does bookkeeping to remove them when this runner instance is disposed.
 * @param {EventEmitter} target - The `EventEmitter`
 * @param {string} eventName - The event name
 * @param {string} fn - Listener function
 * @private
 */
Runner.prototype._addEventListener = function (target, eventName, listener) {
  debug(
    '_addEventListener(): adding for event %s; %d current listeners',
    eventName,
    target.listenerCount(eventName)
  );
  /* istanbul ignore next */
  if (
    this._eventListeners.has(target) &&
    this._eventListeners.get(target).has(eventName) &&
    this._eventListeners.get(target).get(eventName).has(listener)
  ) {
    debug(
      'warning: tried to attach duplicate event listener for %s',
      eventName
    );
    return;
  }
  target.on(eventName, listener);
  const targetListeners = this._eventListeners.has(target)
    ? this._eventListeners.get(target)
    : new Map();
  const targetEventListeners = targetListeners.has(eventName)
    ? targetListeners.get(eventName)
    : new Set();
  targetEventListeners.add(listener);
  targetListeners.set(eventName, targetEventListeners);
  this._eventListeners.set(target, targetListeners);
};

/**
 * Replacement for `target.removeListener(eventName, listener)` that also updates the bookkeeping.
 * @param {EventEmitter} target - The `EventEmitter`
 * @param {string} eventName - The event name
 * @param {function} listener - Listener function
 * @private
 */
Runner.prototype._removeEventListener = function (target, eventName, listener) {
  target.removeListener(eventName, listener);

  if (this._eventListeners.has(target)) {
    const targetListeners = this._eventListeners.get(target);
    if (targetListeners.has(eventName)) {
      const targetEventListeners = targetListeners.get(eventName);
      targetEventListeners.delete(listener);
      if (!targetEventListeners.size) {
        targetListeners.delete(eventName);
      }
    }
    if (!targetListeners.size) {
      this._eventListeners.delete(target);
    }
  } else {
    debug('trying to remove listener for untracked object %s', target);
  }
};

/**
 * Removes all event handlers set during a run on this instance.
 * Remark: this does _not_ clean/dispose the tests or suites themselves.
 */
Runner.prototype.dispose = function () {
  this.removeAllListeners();
  this._eventListeners.forEach((targetListeners, target) => {
    targetListeners.forEach((targetEventListeners, eventName) => {
      targetEventListeners.forEach(listener => {
        target.removeListener(eventName, listener);
      });
    });
  });
  this._eventListeners.clear();
};

/**
 * Run tests with full titles matching `re`. Updates runner.total
 * with number of tests matched.
 *
 * @public
 * @memberof Runner
 * @param {RegExp} re
 * @param {boolean} invert
 * @return {Runner} Runner instance.
 */
Runner.prototype.grep = function (re, invert) {
  debug('grep(): setting to %s', re);
  this._grep = re;
  this._invert = invert;
  this.total = this.grepTotal(this.suite);
  return this;
};

/**
 * Returns the number of tests matching the grep search for the
 * given suite.
 *
 * @memberof Runner
 * @public
 * @param {Suite} suite
 * @return {number}
 */
Runner.prototype.grepTotal = function (suite) {
  var self = this;
  var total = 0;

  suite.eachTest(function (test) {
    var match = self._grep.test(test.fullTitle());
    if (self._invert) {
      match = !match;
    }
    if (match) {
      total++;
    }
  });

  return total;
};

/**
 * Return a list of global properties.
 *
 * @return {Array}
 * @private
 */
Runner.prototype.globalProps = function () {
  var props = Object.keys(global);

  // non-enumerables
  for (var i = 0; i < globals.length; ++i) {
    if (~props.indexOf(globals[i])) {
      continue;
    }
    props.push(globals[i]);
  }

  return props;
};

/**
 * Allow the given `arr` of globals.
 *
 * @public
 * @memberof Runner
 * @param {Array} arr
 * @return {Runner} Runner instance.
 */
Runner.prototype.globals = function (arr) {
  if (!arguments.length) {
    return this._globals;
  }
  debug('globals(): setting to %O', arr);
  this._globals = this._globals.concat(arr);
  return this;
};

/**
 * Check for global variable leaks.
 *
 * @private
 */
Runner.prototype.checkGlobals = function (test) {
  if (!this.checkLeaks) {
    return;
  }
  var ok = this._globals;

  var globals = this.globalProps();
  var leaks;

  if (test) {
    ok = ok.concat(test._allowedGlobals || []);
  }

  if (this.prevGlobalsLength === globals.length) {
    return;
  }
  this.prevGlobalsLength = globals.length;

  leaks = filterLeaks(ok, globals);
  this._globals = this._globals.concat(leaks);

  if (leaks.length) {
    var msg = `global leak(s) detected: ${leaks.map(e => `'${e}'`).join(', ')}`;
    this.fail(test, new Error(msg));
  }
};

/**
 * Fail the given `test`.
 *
 * If `test` is a hook, failures work in the following pattern:
 * - If bail, run corresponding `after each` and `after` hooks,
 *   then exit
 * - Failed `before` hook skips all tests in a suite and subsuites,
 *   but jumps to corresponding `after` hook
 * - Failed `before each` hook skips remaining tests in a
 *   suite and jumps to corresponding `after each` hook,
 *   which is run only once
 * - Failed `after` hook does not alter execution order
 * - Failed `after each` hook skips remaining tests in a
 *   suite and subsuites, but executes other `after each`
 *   hooks
 *
 * @private
 * @param {Runnable} test
 * @param {Error} err
 * @param {boolean} [force=false] - Whether to fail a pending test.
 */
Runner.prototype.fail = function (test, err, force) {
  force = force === true;
  if (test.isPending() && !force) {
    return;
  }
  if (this.state === constants.STATE_STOPPED) {
    if (err.code === errorConstants.MULTIPLE_DONE) {
      throw err;
    }
    throw createFatalError(
      'Test failed after root suite execution completed!',
      err
    );
  }

  ++this.failures;
  debug('total number of failures: %d', this.failures);
  test.state = STATE_FAILED;

  if (!isError(err)) {
    err = thrown2Error(err);
  }

  try {
    err.stack =
      this.fullStackTrace || !err.stack ? err.stack : stackFilter(err.stack);
  } catch (ignore) {
    // some environments do not take kindly to monkeying with the stack
  }

  this.emit(constants.EVENT_TEST_FAIL, test, err);
};

/**
 * Run hook `name` callbacks and then invoke `fn()`.
 *
 * @private
 * @param {string} name
 * @param {Function} fn
 */

Runner.prototype.hook = function (name, fn) {
  if (this._opts.dryRun) return fn();

  var suite = this.suite;
  var hooks = suite.getHooks(name);
  var self = this;

  function next(i) {
    var hook = hooks[i];
    if (!hook) {
      return fn();
    }
    self.currentRunnable = hook;

    if (name === HOOK_TYPE_BEFORE_ALL) {
      hook.ctx.currentTest = hook.parent.tests[0];
    } else if (name === HOOK_TYPE_AFTER_ALL) {
      hook.ctx.currentTest = hook.parent.tests[hook.parent.tests.length - 1];
    } else {
      hook.ctx.currentTest = self.test;
    }

    setHookTitle(hook);

    hook.allowUncaught = self.allowUncaught;

    self.emit(constants.EVENT_HOOK_BEGIN, hook);

    if (!hook.listeners('error').length) {
      self._addEventListener(hook, 'error', function (err) {
        self.fail(hook, err);
      });
    }

    hook.run(function cbHookRun(err) {
      var testError = hook.error();
      if (testError) {
        self.fail(self.test, testError);
      }
      // conditional skip
      if (hook.pending) {
        if (name === HOOK_TYPE_AFTER_EACH) {
          // TODO define and implement use case
          if (self.test) {
            self.test.pending = true;
          }
        } else if (name === HOOK_TYPE_BEFORE_EACH) {
          if (self.test) {
            self.test.pending = true;
          }
          self.emit(constants.EVENT_HOOK_END, hook);
          hook.pending = false; // activates hook for next test
          return fn(new Error('abort hookDown'));
        } else if (name === HOOK_TYPE_BEFORE_ALL) {
          suite.tests.forEach(function (test) {
            test.pending = true;
          });
          suite.suites.forEach(function (suite) {
            suite.pending = true;
          });
          hooks = [];
        } else {
          hook.pending = false;
          var errForbid = createUnsupportedError('`this.skip` forbidden');
          self.fail(hook, errForbid);
          return fn(errForbid);
        }
      } else if (err) {
        self.fail(hook, err);
        // stop executing hooks, notify callee of hook err
        return fn(err);
      }
      self.emit(constants.EVENT_HOOK_END, hook);
      delete hook.ctx.currentTest;
      setHookTitle(hook);
      next(++i);
    });

    function setHookTitle(hook) {
      hook.originalTitle = hook.originalTitle || hook.title;
      if (hook.ctx && hook.ctx.currentTest) {
        hook.title = `${hook.originalTitle} for "${hook.ctx.currentTest.title}"`;
      } else {
        var parentTitle;
        if (hook.parent.title) {
          parentTitle = hook.parent.title;
        } else {
          parentTitle = hook.parent.root ? '{root}' : '';
        }
        hook.title = `${hook.originalTitle} in "${parentTitle}"`;
      }
    }
  }

  Runner.immediately(function () {
    next(0);
  });
};

/**
 * Run hook `name` for the given array of `suites`
 * in order, and callback `fn(err, errSuite)`.
 *
 * @private
 * @param {string} name
 * @param {Array} suites
 * @param {Function} fn
 */
Runner.prototype.hooks = function (name, suites, fn) {
  var self = this;
  var orig = this.suite;

  function next(suite) {
    self.suite = suite;

    if (!suite) {
      self.suite = orig;
      return fn();
    }

    self.hook(name, function (err) {
      if (err) {
        var errSuite = self.suite;
        self.suite = orig;
        return fn(err, errSuite);
      }

      next(suites.pop());
    });
  }

  next(suites.pop());
};

/**
 * Run 'afterEach' hooks from bottom up.
 *
 * @param {String} name
 * @param {Function} fn
 * @private
 */
Runner.prototype.hookUp = function (name, fn) {
  var suites = [this.suite].concat(this.parents()).reverse();
  this.hooks(name, suites, fn);
};

/**
 * Run 'beforeEach' hooks from top level down.
 *
 * @param {String} name
 * @param {Function} fn
 * @private
 */
Runner.prototype.hookDown = function (name, fn) {
  var suites = [this.suite].concat(this.parents());
  this.hooks(name, suites, fn);
};

/**
 * Return an array of parent Suites from
 * closest to furthest.
 *
 * @return {Array}
 * @private
 */
Runner.prototype.parents = function () {
  var suite = this.suite;
  var suites = [];
  while (suite.parent) {
    suite = suite.parent;
    suites.push(suite);
  }
  return suites;
};

/**
 * Run the current test and callback `fn(err)`.
 *
 * @param {Function} fn
 * @private
 */
Runner.prototype.runTest = function (fn) {
  if (this._opts.dryRun) return Runner.immediately(fn);

  var self = this;
  var test = this.test;

  if (!test) {
    return;
  }

  if (this.asyncOnly) {
    test.asyncOnly = true;
  }
  this._addEventListener(test, 'error', function (err) {
    self.fail(test, err);
  });
  if (this.allowUncaught) {
    test.allowUncaught = true;
    return test.run(fn);
  }
  try {
    test.run(fn);
  } catch (err) {
    fn(err);
  }
};

/**
 * Run tests in the given `suite` and invoke the callback `fn()` when complete.
 *
 * @private
 * @param {Suite} suite
 * @param {Function} fn
 */
Runner.prototype.runTests = function (suite, fn) {
  var self = this;
  var tests = suite.tests.slice();
  var test;

  function hookErr(_, errSuite, after) {
    // before/after Each hook for errSuite failed:
    var orig = self.suite;

    // for failed 'after each' hook start from errSuite parent,
    // otherwise start from errSuite itself
    self.suite = after ? errSuite.parent : errSuite;

    if (self.suite) {
      self.hookUp(HOOK_TYPE_AFTER_EACH, function (err2, errSuite2) {
        self.suite = orig;
        // some hooks may fail even now
        if (err2) {
          return hookErr(err2, errSuite2, true);
        }
        // report error suite
        fn(errSuite);
      });
    } else {
      // there is no need calling other 'after each' hooks
      self.suite = orig;
      fn(errSuite);
    }
  }

  function next(err, errSuite) {
    // if we bail after first err
    if (self.failures && suite._bail) {
      tests = [];
    }

    if (self._abort) {
      return fn();
    }

    if (err) {
      return hookErr(err, errSuite, true);
    }

    // next test
    test = tests.shift();

    // all done
    if (!test) {
      return fn();
    }

    // grep
    var match = self._grep.test(test.fullTitle());
    if (self._invert) {
      match = !match;
    }
    if (!match) {
      // Run immediately only if we have defined a grep. When we
      // define a grep  It can cause maximum callstack error if
      // the grep is doing a large recursive loop by neglecting
      // all tests. The run immediately function also comes with
      // a performance cost. So we don't want to run immediately
      // if we run the whole test suite, because running the whole
      // test suite don't do any immediate recursive loops. Thus,
      // allowing a JS runtime to breathe.
      if (self._grep !== self._defaultGrep) {
        Runner.immediately(next);
      } else {
        next();
      }
      return;
    }

    // static skip, no hooks are executed
    if (test.isPending()) {
      if (self.forbidPending) {
        self.fail(test, new Error('Pending test forbidden'), true);
      } else {
        test.state = STATE_PENDING;
        self.emit(constants.EVENT_TEST_PENDING, test);
      }
      self.emit(constants.EVENT_TEST_END, test);
      return next();
    }

    // execute test and hook(s)
    self.emit(constants.EVENT_TEST_BEGIN, (self.test = test));
    self.hookDown(HOOK_TYPE_BEFORE_EACH, function (err, errSuite) {
      // conditional skip within beforeEach
      if (test.isPending()) {
        if (self.forbidPending) {
          self.fail(test, new Error('Pending test forbidden'), true);
        } else {
          test.state = STATE_PENDING;
          self.emit(constants.EVENT_TEST_PENDING, test);
        }
        self.emit(constants.EVENT_TEST_END, test);
        // skip inner afterEach hooks below errSuite level
        var origSuite = self.suite;
        self.suite = errSuite || self.suite;
        return self.hookUp(HOOK_TYPE_AFTER_EACH, function (e, eSuite) {
          self.suite = origSuite;
          next(e, eSuite);
        });
      }
      if (err) {
        return hookErr(err, errSuite, false);
      }
      self.currentRunnable = self.test;
      self.runTest(function (err) {
        test = self.test;
        // conditional skip within it
        if (test.pending) {
          if (self.forbidPending) {
            self.fail(test, new Error('Pending test forbidden'), true);
          } else {
            test.state = STATE_PENDING;
            self.emit(constants.EVENT_TEST_PENDING, test);
          }
          self.emit(constants.EVENT_TEST_END, test);
          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);
        } else if (err) {
          var retry = test.currentRetry();
          if (retry < test.retries()) {
            var clonedTest = test.clone();
            clonedTest.currentRetry(retry + 1);
            tests.unshift(clonedTest);

            self.emit(constants.EVENT_TEST_RETRY, test, err);

            // Early return + hook trigger so that it doesn't
            // increment the count wrong
            return self.hookUp(HOOK_TYPE_AFTER_EACH, next);
          } else {
            self.fail(test, err);
          }
          self.emit(constants.EVENT_TEST_END, test);
          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);
        }

        test.state = STATE_PASSED;
        self.emit(constants.EVENT_TEST_PASS, test);
        self.emit(constants.EVENT_TEST_END, test);
        self.hookUp(HOOK_TYPE_AFTER_EACH, next);
      });
    });
  }

  this.next = next;
  this.hookErr = hookErr;
  next();
};

/**
 * Run the given `suite` and invoke the callback `fn()` when complete.
 *
 * @private
 * @param {Suite} suite
 * @param {Function} fn
 */
Runner.prototype.runSuite = function (suite, fn) {
  var i = 0;
  var self = this;
  var total = this.grepTotal(suite);

  debug('runSuite(): running %s', suite.fullTitle());

  if (!total || (self.failures && suite._bail)) {
    debug('runSuite(): bailing');
    return fn();
  }

  this.emit(constants.EVENT_SUITE_BEGIN, (this.suite = suite));

  function next(errSuite) {
    if (errSuite) {
      // current suite failed on a hook from errSuite
      if (errSuite === suite) {
        // if errSuite is current suite
        // continue to the next sibling suite
        return done();
      }
      // errSuite is among the parents of current suite
      // stop execution of errSuite and all sub-suites
      return done(errSuite);
    }

    if (self._abort) {
      return done();
    }

    var curr = suite.suites[i++];
    if (!curr) {
      return done();
    }

    // Avoid grep neglecting large number of tests causing a
    // huge recursive loop and thus a maximum call stack error.
    // See comment in `this.runTests()` for more information.
    if (self._grep !== self._defaultGrep) {
      Runner.immediately(function () {
        self.runSuite(curr, next);
      });
    } else {
      self.runSuite(curr, next);
    }
  }

  function done(errSuite) {
    self.suite = suite;
    self.nextSuite = next;

    // remove reference to test
    delete self.test;

    self.hook(HOOK_TYPE_AFTER_ALL, function () {
      self.emit(constants.EVENT_SUITE_END, suite);
      fn(errSuite);
    });
  }

  this.nextSuite = next;

  this.hook(HOOK_TYPE_BEFORE_ALL, function (err) {
    if (err) {
      return done();
    }
    self.runTests(suite, next);
  });
};

/**
 * Handle uncaught exceptions within runner.
 *
 * This function is bound to the instance as `Runner#uncaught` at instantiation
 * time. It's intended to be listening on the `Process.uncaughtException` event.
 * In order to not leak EE listeners, we need to ensure no more than a single
 * `uncaughtException` listener exists per `Runner`.  The only way to do
 * this--because this function needs the context (and we don't have lambdas)--is
 * to use `Function.prototype.bind`. We need strict equality to unregister and
 * _only_ unregister the _one_ listener we set from the
 * `Process.uncaughtException` event; would be poor form to just remove
 * everything. See {@link Runner#run} for where the event listener is registered
 * and unregistered.
 * @param {Error} err - Some uncaught error
 * @private
 */
Runner.prototype._uncaught = function (err) {
  // this is defensive to prevent future developers from mis-calling this function.
  // it's more likely that it'd be called with the incorrect context--say, the global
  // `process` object--than it would to be called with a context that is not a "subclass"
  // of `Runner`.
  if (!(this instanceof Runner)) {
    throw createFatalError(
      'Runner#uncaught() called with invalid context',
      this
    );
  }
  if (err instanceof Pending) {
    debug('uncaught(): caught a Pending');
    return;
  }
  // browser does not exit script when throwing in global.onerror()
  if (this.allowUncaught && !utils.isBrowser()) {
    debug('uncaught(): bubbling exception due to --allow-uncaught');
    throw err;
  }

  if (this.state === constants.STATE_STOPPED) {
    debug('uncaught(): throwing after run has completed!');
    throw err;
  }

  if (err) {
    debug('uncaught(): got truthy exception %O', err);
  } else {
    debug('uncaught(): undefined/falsy exception');
    err = createInvalidExceptionError(
      'Caught falsy/undefined exception which would otherwise be uncaught. No stack trace found; try a debugger',
      err
    );
  }

  if (!isError(err)) {
    err = thrown2Error(err);
    debug('uncaught(): converted "error" %o to Error', err);
  }
  err.uncaught = true;

  var runnable = this.currentRunnable;

  if (!runnable) {
    runnable = new Runnable('Uncaught error outside test suite');
    debug('uncaught(): no current Runnable; created a phony one');
    runnable.parent = this.suite;

    if (this.state === constants.STATE_RUNNING) {
      debug('uncaught(): failing gracefully');
      this.fail(runnable, err);
    } else {
      // Can't recover from this failure
      debug('uncaught(): test run has not yet started; unrecoverable');
      this.emit(constants.EVENT_RUN_BEGIN);
      this.fail(runnable, err);
      this.emit(constants.EVENT_RUN_END);
    }

    return;
  }

  runnable.clearTimeout();

  if (runnable.isFailed()) {
    debug('uncaught(): Runnable has already failed');
    // Ignore error if already failed
    return;
  } else if (runnable.isPending()) {
    debug('uncaught(): pending Runnable wound up failing!');
    // report 'pending test' retrospectively as failed
    this.fail(runnable, err, true);
    return;
  }

  // we cannot recover gracefully if a Runnable has already passed
  // then fails asynchronously
  if (runnable.isPassed()) {
    debug('uncaught(): Runnable has already passed; bailing gracefully');
    this.fail(runnable, err);
    this.abort();
  } else {
    debug('uncaught(): forcing Runnable to complete with Error');
    return runnable.callback(err);
  }
};

/**
 * Run the root suite and invoke `fn(failures)`
 * on completion.
 *
 * @public
 * @memberof Runner
 * @param {Function} fn - Callback when finished
 * @param {Object} [opts] - For subclasses
 * @param {string[]} opts.files - Files to run
 * @param {Options} opts.options - command-line options
 * @returns {Runner} Runner instance.
 */
Runner.prototype.run = function (fn, opts = {}) {
  var rootSuite = this.suite;
  var options = opts.options || {};

  debug('run(): got options: %O', options);
  fn = fn || function () {};

  const end = () => {
    if (!this.total && this._opts.failZero) this.failures = 1;

    debug('run(): root suite completed; emitting %s', constants.EVENT_RUN_END);
    this.emit(constants.EVENT_RUN_END);
  };

  const begin = () => {
    debug('run(): emitting %s', constants.EVENT_RUN_BEGIN);
    this.emit(constants.EVENT_RUN_BEGIN);
    debug('run(): emitted %s', constants.EVENT_RUN_BEGIN);

    this.runSuite(rootSuite, end);
  };

  const prepare = () => {
    debug('run(): starting');
    // If there is an `only` filter
    if (rootSuite.hasOnly()) {
      rootSuite.filterOnly();
      debug('run(): filtered exclusive Runnables');
    }
    this.state = constants.STATE_RUNNING;
    if (this._opts.delay) {
      this.emit(constants.EVENT_DELAY_END);
      debug('run(): "delay" ended');
    }

    return begin();
  };

  // references cleanup to avoid memory leaks
  if (this._opts.cleanReferencesAfterRun) {
    this.on(constants.EVENT_SUITE_END, suite => {
      suite.cleanReferences();
    });
  }

  // callback
  this.on(constants.EVENT_RUN_END, function () {
    this.state = constants.STATE_STOPPED;
    debug('run(): emitted %s', constants.EVENT_RUN_END);
    fn(this.failures);
  });

  this._removeEventListener(process, 'uncaughtException', this.uncaught);
  this._removeEventListener(process, 'unhandledRejection', this.unhandled);
  this._addEventListener(process, 'uncaughtException', this.uncaught);
  this._addEventListener(process, 'unhandledRejection', this.unhandled);

  if (this._opts.delay) {
    // for reporters, I guess.
    // might be nice to debounce some dots while we wait.
    this.emit(constants.EVENT_DELAY_BEGIN, rootSuite);
    rootSuite.once(EVENT_ROOT_SUITE_RUN, prepare);
    debug('run(): waiting for green light due to --delay');
  } else {
    Runner.immediately(prepare);
  }

  return this;
};

/**
 * Toggle partial object linking behavior; used for building object references from
 * unique ID's. Does nothing in serial mode, because the object references already exist.
 * Subclasses can implement this (e.g., `ParallelBufferedRunner`)
 * @abstract
 * @param {boolean} [value] - If `true`, enable partial object linking, otherwise disable
 * @returns {Runner}
 * @chainable
 * @public
 * @example
 * // this reporter needs proper object references when run in parallel mode
 * class MyReporter() {
 *   constructor(runner) {
 *     this.runner.linkPartialObjects(true)
 *       .on(EVENT_SUITE_BEGIN, suite => {
           // this Suite may be the same object...
 *       })
 *       .on(EVENT_TEST_BEGIN, test => {
 *         // ...as the `test.parent` property
 *       });
 *   }
 * }
 */
Runner.prototype.linkPartialObjects = function (value) {
  return this;
};

/*
 * Like {@link Runner#run}, but does not accept a callback and returns a `Promise` instead of a `Runner`.
 * This function cannot reject; an `unhandledRejection` event will bubble up to the `process` object instead.
 * @public
 * @memberof Runner
 * @param {Object} [opts] - Options for {@link Runner#run}
 * @returns {Promise<number>} Failure count
 */
Runner.prototype.runAsync = async function runAsync(opts = {}) {
  return new Promise(resolve => {
    this.run(resolve, opts);
  });
};

/**
 * Cleanly abort execution.
 *
 * @memberof Runner
 * @public
 * @return {Runner} Runner instance.
 */
Runner.prototype.abort = function () {
  debug('abort(): aborting');
  this._abort = true;

  return this;
};

/**
 * Returns `true` if Mocha is running in parallel mode.  For reporters.
 *
 * Subclasses should return an appropriate value.
 * @public
 * @returns {false}
 */
Runner.prototype.isParallelMode = function isParallelMode() {
  return false;
};

/**
 * Configures an alternate reporter for worker processes to use. Subclasses
 * using worker processes should implement this.
 * @public
 * @param {string} path - Absolute path to alternate reporter for worker processes to use
 * @returns {Runner}
 * @throws When in serial mode
 * @chainable
 * @abstract
 */
Runner.prototype.workerReporter = function () {
  throw createUnsupportedError('workerReporter() not supported in serial mode');
};

/**
 * Filter leaks with the given globals flagged as `ok`.
 *
 * @private
 * @param {Array} ok
 * @param {Array} globals
 * @return {Array}
 */
function filterLeaks(ok, globals) {
  return globals.filter(function (key) {
    // Firefox and Chrome exposes iframes as index inside the window object
    if (/^\d+/.test(key)) {
      return false;
    }

    // in firefox
    // if runner runs in an iframe, this iframe's window.getInterface method
    // not init at first it is assigned in some seconds
    if (global.navigator && /^getInterface/.test(key)) {
      return false;
    }

    // an iframe could be approached by window[iframeIndex]
    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak
    if (global.navigator && /^\d+/.test(key)) {
      return false;
    }

    // Opera and IE expose global variables for HTML element IDs (issue #243)
    if (/^mocha-/.test(key)) {
      return false;
    }

    var matched = ok.filter(function (ok) {
      if (~ok.indexOf('*')) {
        return key.indexOf(ok.split('*')[0]) === 0;
      }
      return key === ok;
    });
    return !matched.length && (!global.navigator || key !== 'onerror');
  });
}

/**
 * Check if argument is an instance of Error object or a duck-typed equivalent.
 *
 * @private
 * @param {Object} err - object to check
 * @param {string} err.message - error message
 * @returns {boolean}
 */
function isError(err) {
  return err instanceof Error || (err && typeof err.message === 'string');
}

/**
 *
 * Converts thrown non-extensible type into proper Error.
 *
 * @private
 * @param {*} thrown - Non-extensible type thrown by code
 * @return {Error}
 */
function thrown2Error(err) {
  return new Error(
    `the ${utils.canonicalType(err)} ${stringify(
      err
    )} was thrown, throw an Error :)`
  );
}

Runner.constants = constants;

/**
 * Node.js' `EventEmitter`
 * @external EventEmitter
 * @see {@link https://nodejs.org/api/events.html#events_class_eventemitter}
 */

module.exports = Runner;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/mocha/lib/stats-collector.js":
/*!***************************************************!*\
  !*** ./node_modules/mocha/lib/stats-collector.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

/**
 * Provides a factory function for a {@link StatsCollector} object.
 * @module
 */

var constants = __webpack_require__(/*! ./runner */ "./node_modules/mocha/lib/runner.js").constants;
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
var EVENT_RUN_END = constants.EVENT_RUN_END;
var EVENT_TEST_END = constants.EVENT_TEST_END;

/**
 * Test statistics collector.
 *
 * @public
 * @typedef {Object} StatsCollector
 * @property {number} suites - integer count of suites run.
 * @property {number} tests - integer count of tests run.
 * @property {number} passes - integer count of passing tests.
 * @property {number} pending - integer count of pending tests.
 * @property {number} failures - integer count of failed tests.
 * @property {Date} start - time when testing began.
 * @property {Date} end - time when testing concluded.
 * @property {number} duration - number of msecs that testing took.
 */

var Date = global.Date;

/**
 * Provides stats such as test duration, number of tests passed / failed etc., by listening for events emitted by `runner`.
 *
 * @private
 * @param {Runner} runner - Runner instance
 * @throws {TypeError} If falsy `runner`
 */
function createStatsCollector(runner) {
  /**
   * @type StatsCollector
   */
  var stats = {
    suites: 0,
    tests: 0,
    passes: 0,
    pending: 0,
    failures: 0
  };

  if (!runner) {
    throw new TypeError('Missing runner argument');
  }

  runner.stats = stats;

  runner.once(EVENT_RUN_BEGIN, function () {
    stats.start = new Date();
  });
  runner.on(EVENT_SUITE_BEGIN, function (suite) {
    suite.root || stats.suites++;
  });
  runner.on(EVENT_TEST_PASS, function () {
    stats.passes++;
  });
  runner.on(EVENT_TEST_FAIL, function () {
    stats.failures++;
  });
  runner.on(EVENT_TEST_PENDING, function () {
    stats.pending++;
  });
  runner.on(EVENT_TEST_END, function () {
    stats.tests++;
  });
  runner.once(EVENT_RUN_END, function () {
    stats.end = new Date();
    stats.duration = stats.end - stats.start;
  });
}

module.exports = createStatsCollector;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/mocha/lib/suite.js":
/*!*****************************************!*\
  !*** ./node_modules/mocha/lib/suite.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 * @private
 */
const {EventEmitter} = __webpack_require__(/*! events */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/events/events.js");
const Hook = __webpack_require__(/*! ./hook */ "./node_modules/mocha/lib/hook.js");
var {
  assignNewMochaID,
  clamp,
  constants: utilsConstants,
  defineConstants,
  getMochaID,
  inherits,
  isString
} = __webpack_require__(/*! ./utils */ "./node_modules/mocha/lib/utils.js");
const debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('mocha:suite');
const milliseconds = __webpack_require__(/*! ms */ "./node_modules/mocha/node_modules/ms/index.js");
const errors = __webpack_require__(/*! ./errors */ "./node_modules/mocha/lib/errors.js");

const {MOCHA_ID_PROP_NAME} = utilsConstants;

/**
 * Expose `Suite`.
 */

exports = module.exports = Suite;

/**
 * Create a new `Suite` with the given `title` and parent `Suite`.
 *
 * @public
 * @param {Suite} parent - Parent suite (required!)
 * @param {string} title - Title
 * @return {Suite}
 */
Suite.create = function (parent, title) {
  var suite = new Suite(title, parent.ctx);
  suite.parent = parent;
  title = suite.fullTitle();
  parent.addSuite(suite);
  return suite;
};

/**
 * Constructs a new `Suite` instance with the given `title`, `ctx`, and `isRoot`.
 *
 * @public
 * @class
 * @extends EventEmitter
 * @see {@link https://nodejs.org/api/events.html#events_class_eventemitter|EventEmitter}
 * @param {string} title - Suite title.
 * @param {Context} parentContext - Parent context instance.
 * @param {boolean} [isRoot=false] - Whether this is the root suite.
 */
function Suite(title, parentContext, isRoot) {
  if (!isString(title)) {
    throw errors.createInvalidArgumentTypeError(
      'Suite argument "title" must be a string. Received type "' +
        typeof title +
        '"',
      'title',
      'string'
    );
  }
  this.title = title;
  function Context() {}
  Context.prototype = parentContext;
  this.ctx = new Context();
  this.suites = [];
  this.tests = [];
  this.root = isRoot === true;
  this.pending = false;
  this._retries = -1;
  this._beforeEach = [];
  this._beforeAll = [];
  this._afterEach = [];
  this._afterAll = [];
  this._timeout = 2000;
  this._slow = 75;
  this._bail = false;
  this._onlyTests = [];
  this._onlySuites = [];
  assignNewMochaID(this);

  Object.defineProperty(this, 'id', {
    get() {
      return getMochaID(this);
    }
  });

  this.reset();
}

/**
 * Inherit from `EventEmitter.prototype`.
 */
inherits(Suite, EventEmitter);

/**
 * Resets the state initially or for a next run.
 */
Suite.prototype.reset = function () {
  this.delayed = false;
  function doReset(thingToReset) {
    thingToReset.reset();
  }
  this.suites.forEach(doReset);
  this.tests.forEach(doReset);
  this._beforeEach.forEach(doReset);
  this._afterEach.forEach(doReset);
  this._beforeAll.forEach(doReset);
  this._afterAll.forEach(doReset);
};

/**
 * Return a clone of this `Suite`.
 *
 * @private
 * @return {Suite}
 */
Suite.prototype.clone = function () {
  var suite = new Suite(this.title);
  debug('clone');
  suite.ctx = this.ctx;
  suite.root = this.root;
  suite.timeout(this.timeout());
  suite.retries(this.retries());
  suite.slow(this.slow());
  suite.bail(this.bail());
  return suite;
};

/**
 * Set or get timeout `ms` or short-hand such as "2s".
 *
 * @private
 * @todo Do not attempt to set value if `ms` is undefined
 * @param {number|string} ms
 * @return {Suite|number} for chaining
 */
Suite.prototype.timeout = function (ms) {
  if (!arguments.length) {
    return this._timeout;
  }
  if (typeof ms === 'string') {
    ms = milliseconds(ms);
  }

  // Clamp to range
  var INT_MAX = Math.pow(2, 31) - 1;
  var range = [0, INT_MAX];
  ms = clamp(ms, range);

  debug('timeout %d', ms);
  this._timeout = parseInt(ms, 10);
  return this;
};

/**
 * Set or get number of times to retry a failed test.
 *
 * @private
 * @param {number|string} n
 * @return {Suite|number} for chaining
 */
Suite.prototype.retries = function (n) {
  if (!arguments.length) {
    return this._retries;
  }
  debug('retries %d', n);
  this._retries = parseInt(n, 10) || 0;
  return this;
};

/**
 * Set or get slow `ms` or short-hand such as "2s".
 *
 * @private
 * @param {number|string} ms
 * @return {Suite|number} for chaining
 */
Suite.prototype.slow = function (ms) {
  if (!arguments.length) {
    return this._slow;
  }
  if (typeof ms === 'string') {
    ms = milliseconds(ms);
  }
  debug('slow %d', ms);
  this._slow = ms;
  return this;
};

/**
 * Set or get whether to bail after first error.
 *
 * @private
 * @param {boolean} bail
 * @return {Suite|number} for chaining
 */
Suite.prototype.bail = function (bail) {
  if (!arguments.length) {
    return this._bail;
  }
  debug('bail %s', bail);
  this._bail = bail;
  return this;
};

/**
 * Check if this suite or its parent suite is marked as pending.
 *
 * @private
 */
Suite.prototype.isPending = function () {
  return this.pending || (this.parent && this.parent.isPending());
};

/**
 * Generic hook-creator.
 * @private
 * @param {string} title - Title of hook
 * @param {Function} fn - Hook callback
 * @returns {Hook} A new hook
 */
Suite.prototype._createHook = function (title, fn) {
  var hook = new Hook(title, fn);
  hook.parent = this;
  hook.timeout(this.timeout());
  hook.retries(this.retries());
  hook.slow(this.slow());
  hook.ctx = this.ctx;
  hook.file = this.file;
  return hook;
};

/**
 * Run `fn(test[, done])` before running tests.
 *
 * @private
 * @param {string} title
 * @param {Function} fn
 * @return {Suite} for chaining
 */
Suite.prototype.beforeAll = function (title, fn) {
  if (this.isPending()) {
    return this;
  }
  if (typeof title === 'function') {
    fn = title;
    title = fn.name;
  }
  title = '"before all" hook' + (title ? ': ' + title : '');

  var hook = this._createHook(title, fn);
  this._beforeAll.push(hook);
  this.emit(constants.EVENT_SUITE_ADD_HOOK_BEFORE_ALL, hook);
  return this;
};

/**
 * Run `fn(test[, done])` after running tests.
 *
 * @private
 * @param {string} title
 * @param {Function} fn
 * @return {Suite} for chaining
 */
Suite.prototype.afterAll = function (title, fn) {
  if (this.isPending()) {
    return this;
  }
  if (typeof title === 'function') {
    fn = title;
    title = fn.name;
  }
  title = '"after all" hook' + (title ? ': ' + title : '');

  var hook = this._createHook(title, fn);
  this._afterAll.push(hook);
  this.emit(constants.EVENT_SUITE_ADD_HOOK_AFTER_ALL, hook);
  return this;
};

/**
 * Run `fn(test[, done])` before each test case.
 *
 * @private
 * @param {string} title
 * @param {Function} fn
 * @return {Suite} for chaining
 */
Suite.prototype.beforeEach = function (title, fn) {
  if (this.isPending()) {
    return this;
  }
  if (typeof title === 'function') {
    fn = title;
    title = fn.name;
  }
  title = '"before each" hook' + (title ? ': ' + title : '');

  var hook = this._createHook(title, fn);
  this._beforeEach.push(hook);
  this.emit(constants.EVENT_SUITE_ADD_HOOK_BEFORE_EACH, hook);
  return this;
};

/**
 * Run `fn(test[, done])` after each test case.
 *
 * @private
 * @param {string} title
 * @param {Function} fn
 * @return {Suite} for chaining
 */
Suite.prototype.afterEach = function (title, fn) {
  if (this.isPending()) {
    return this;
  }
  if (typeof title === 'function') {
    fn = title;
    title = fn.name;
  }
  title = '"after each" hook' + (title ? ': ' + title : '');

  var hook = this._createHook(title, fn);
  this._afterEach.push(hook);
  this.emit(constants.EVENT_SUITE_ADD_HOOK_AFTER_EACH, hook);
  return this;
};

/**
 * Add a test `suite`.
 *
 * @private
 * @param {Suite} suite
 * @return {Suite} for chaining
 */
Suite.prototype.addSuite = function (suite) {
  suite.parent = this;
  suite.root = false;
  suite.timeout(this.timeout());
  suite.retries(this.retries());
  suite.slow(this.slow());
  suite.bail(this.bail());
  this.suites.push(suite);
  this.emit(constants.EVENT_SUITE_ADD_SUITE, suite);
  return this;
};

/**
 * Add a `test` to this suite.
 *
 * @private
 * @param {Test} test
 * @return {Suite} for chaining
 */
Suite.prototype.addTest = function (test) {
  test.parent = this;
  test.timeout(this.timeout());
  test.retries(this.retries());
  test.slow(this.slow());
  test.ctx = this.ctx;
  this.tests.push(test);
  this.emit(constants.EVENT_SUITE_ADD_TEST, test);
  return this;
};

/**
 * Return the full title generated by recursively concatenating the parent's
 * full title.
 *
 * @memberof Suite
 * @public
 * @return {string}
 */
Suite.prototype.fullTitle = function () {
  return this.titlePath().join(' ');
};

/**
 * Return the title path generated by recursively concatenating the parent's
 * title path.
 *
 * @memberof Suite
 * @public
 * @return {string}
 */
Suite.prototype.titlePath = function () {
  var result = [];
  if (this.parent) {
    result = result.concat(this.parent.titlePath());
  }
  if (!this.root) {
    result.push(this.title);
  }
  return result;
};

/**
 * Return the total number of tests.
 *
 * @memberof Suite
 * @public
 * @return {number}
 */
Suite.prototype.total = function () {
  return (
    this.suites.reduce(function (sum, suite) {
      return sum + suite.total();
    }, 0) + this.tests.length
  );
};

/**
 * Iterates through each suite recursively to find all tests. Applies a
 * function in the format `fn(test)`.
 *
 * @private
 * @param {Function} fn
 * @return {Suite}
 */
Suite.prototype.eachTest = function (fn) {
  this.tests.forEach(fn);
  this.suites.forEach(function (suite) {
    suite.eachTest(fn);
  });
  return this;
};

/**
 * This will run the root suite if we happen to be running in delayed mode.
 * @private
 */
Suite.prototype.run = function run() {
  if (this.root) {
    this.emit(constants.EVENT_ROOT_SUITE_RUN);
  }
};

/**
 * Determines whether a suite has an `only` test or suite as a descendant.
 *
 * @private
 * @returns {Boolean}
 */
Suite.prototype.hasOnly = function hasOnly() {
  return (
    this._onlyTests.length > 0 ||
    this._onlySuites.length > 0 ||
    this.suites.some(function (suite) {
      return suite.hasOnly();
    })
  );
};

/**
 * Filter suites based on `isOnly` logic.
 *
 * @private
 * @returns {Boolean}
 */
Suite.prototype.filterOnly = function filterOnly() {
  if (this._onlyTests.length) {
    // If the suite contains `only` tests, run those and ignore any nested suites.
    this.tests = this._onlyTests;
    this.suites = [];
  } else {
    // Otherwise, do not run any of the tests in this suite.
    this.tests = [];
    this._onlySuites.forEach(function (onlySuite) {
      // If there are other `only` tests/suites nested in the current `only` suite, then filter that `only` suite.
      // Otherwise, all of the tests on this `only` suite should be run, so don't filter it.
      if (onlySuite.hasOnly()) {
        onlySuite.filterOnly();
      }
    });
    // Run the `only` suites, as well as any other suites that have `only` tests/suites as descendants.
    var onlySuites = this._onlySuites;
    this.suites = this.suites.filter(function (childSuite) {
      return onlySuites.indexOf(childSuite) !== -1 || childSuite.filterOnly();
    });
  }
  // Keep the suite only if there is something to run
  return this.tests.length > 0 || this.suites.length > 0;
};

/**
 * Adds a suite to the list of subsuites marked `only`.
 *
 * @private
 * @param {Suite} suite
 */
Suite.prototype.appendOnlySuite = function (suite) {
  this._onlySuites.push(suite);
};

/**
 * Marks a suite to be `only`.
 *
 * @private
 */
Suite.prototype.markOnly = function () {
  this.parent && this.parent.appendOnlySuite(this);
};

/**
 * Adds a test to the list of tests marked `only`.
 *
 * @private
 * @param {Test} test
 */
Suite.prototype.appendOnlyTest = function (test) {
  this._onlyTests.push(test);
};

/**
 * Returns the array of hooks by hook name; see `HOOK_TYPE_*` constants.
 * @private
 */
Suite.prototype.getHooks = function getHooks(name) {
  return this['_' + name];
};

/**
 * cleans all references from this suite and all child suites.
 */
Suite.prototype.dispose = function () {
  this.suites.forEach(function (suite) {
    suite.dispose();
  });
  this.cleanReferences();
};

/**
 * Cleans up the references to all the deferred functions
 * (before/after/beforeEach/afterEach) and tests of a Suite.
 * These must be deleted otherwise a memory leak can happen,
 * as those functions may reference variables from closures,
 * thus those variables can never be garbage collected as long
 * as the deferred functions exist.
 *
 * @private
 */
Suite.prototype.cleanReferences = function cleanReferences() {
  function cleanArrReferences(arr) {
    for (var i = 0; i < arr.length; i++) {
      delete arr[i].fn;
    }
  }

  if (Array.isArray(this._beforeAll)) {
    cleanArrReferences(this._beforeAll);
  }

  if (Array.isArray(this._beforeEach)) {
    cleanArrReferences(this._beforeEach);
  }

  if (Array.isArray(this._afterAll)) {
    cleanArrReferences(this._afterAll);
  }

  if (Array.isArray(this._afterEach)) {
    cleanArrReferences(this._afterEach);
  }

  for (var i = 0; i < this.tests.length; i++) {
    delete this.tests[i].fn;
  }
};

/**
 * Returns an object suitable for IPC.
 * Functions are represented by keys beginning with `$$`.
 * @private
 * @returns {Object}
 */
Suite.prototype.serialize = function serialize() {
  return {
    _bail: this._bail,
    $$fullTitle: this.fullTitle(),
    $$isPending: Boolean(this.isPending()),
    root: this.root,
    title: this.title,
    [MOCHA_ID_PROP_NAME]: this.id,
    parent: this.parent ? {[MOCHA_ID_PROP_NAME]: this.parent.id} : null
  };
};

var constants = defineConstants(
  /**
   * {@link Suite}-related constants.
   * @public
   * @memberof Suite
   * @alias constants
   * @readonly
   * @static
   * @enum {string}
   */
  {
    /**
     * Event emitted after a test file has been loaded. Not emitted in browser.
     */
    EVENT_FILE_POST_REQUIRE: 'post-require',
    /**
     * Event emitted before a test file has been loaded. In browser, this is emitted once an interface has been selected.
     */
    EVENT_FILE_PRE_REQUIRE: 'pre-require',
    /**
     * Event emitted immediately after a test file has been loaded. Not emitted in browser.
     */
    EVENT_FILE_REQUIRE: 'require',
    /**
     * Event emitted when `global.run()` is called (use with `delay` option).
     */
    EVENT_ROOT_SUITE_RUN: 'run',

    /**
     * Namespace for collection of a `Suite`'s "after all" hooks.
     */
    HOOK_TYPE_AFTER_ALL: 'afterAll',
    /**
     * Namespace for collection of a `Suite`'s "after each" hooks.
     */
    HOOK_TYPE_AFTER_EACH: 'afterEach',
    /**
     * Namespace for collection of a `Suite`'s "before all" hooks.
     */
    HOOK_TYPE_BEFORE_ALL: 'beforeAll',
    /**
     * Namespace for collection of a `Suite`'s "before each" hooks.
     */
    HOOK_TYPE_BEFORE_EACH: 'beforeEach',

    /**
     * Emitted after a child `Suite` has been added to a `Suite`.
     */
    EVENT_SUITE_ADD_SUITE: 'suite',
    /**
     * Emitted after an "after all" `Hook` has been added to a `Suite`.
     */
    EVENT_SUITE_ADD_HOOK_AFTER_ALL: 'afterAll',
    /**
     * Emitted after an "after each" `Hook` has been added to a `Suite`.
     */
    EVENT_SUITE_ADD_HOOK_AFTER_EACH: 'afterEach',
    /**
     * Emitted after an "before all" `Hook` has been added to a `Suite`.
     */
    EVENT_SUITE_ADD_HOOK_BEFORE_ALL: 'beforeAll',
    /**
     * Emitted after an "before each" `Hook` has been added to a `Suite`.
     */
    EVENT_SUITE_ADD_HOOK_BEFORE_EACH: 'beforeEach',
    /**
     * Emitted after a `Test` has been added to a `Suite`.
     */
    EVENT_SUITE_ADD_TEST: 'test'
  }
);

Suite.constants = constants;


/***/ }),

/***/ "./node_modules/mocha/lib/test.js":
/*!****************************************!*\
  !*** ./node_modules/mocha/lib/test.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Runnable = __webpack_require__(/*! ./runnable */ "./node_modules/mocha/lib/runnable.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/mocha/lib/utils.js");
var errors = __webpack_require__(/*! ./errors */ "./node_modules/mocha/lib/errors.js");
var createInvalidArgumentTypeError = errors.createInvalidArgumentTypeError;
var isString = utils.isString;

const {MOCHA_ID_PROP_NAME} = utils.constants;

module.exports = Test;

/**
 * Initialize a new `Test` with the given `title` and callback `fn`.
 *
 * @public
 * @class
 * @extends Runnable
 * @param {String} title - Test title (required)
 * @param {Function} [fn] - Test callback.  If omitted, the Test is considered "pending"
 */
function Test(title, fn) {
  if (!isString(title)) {
    throw createInvalidArgumentTypeError(
      'Test argument "title" should be a string. Received type "' +
        typeof title +
        '"',
      'title',
      'string'
    );
  }
  this.type = 'test';
  Runnable.call(this, title, fn);
  this.reset();
}

/**
 * Inherit from `Runnable.prototype`.
 */
utils.inherits(Test, Runnable);

/**
 * Resets the state initially or for a next run.
 */
Test.prototype.reset = function () {
  Runnable.prototype.reset.call(this);
  this.pending = !this.fn;
  delete this.state;
};

/**
 * Set or get retried test
 *
 * @private
 */
Test.prototype.retriedTest = function (n) {
  if (!arguments.length) {
    return this._retriedTest;
  }
  this._retriedTest = n;
};

/**
 * Add test to the list of tests marked `only`.
 *
 * @private
 */
Test.prototype.markOnly = function () {
  this.parent.appendOnlyTest(this);
};

Test.prototype.clone = function () {
  var test = new Test(this.title, this.fn);
  test.timeout(this.timeout());
  test.slow(this.slow());
  test.retries(this.retries());
  test.currentRetry(this.currentRetry());
  test.retriedTest(this.retriedTest() || this);
  test.globals(this.globals());
  test.parent = this.parent;
  test.file = this.file;
  test.ctx = this.ctx;
  return test;
};

/**
 * Returns an minimal object suitable for transmission over IPC.
 * Functions are represented by keys beginning with `$$`.
 * @private
 * @returns {Object}
 */
Test.prototype.serialize = function serialize() {
  return {
    $$currentRetry: this._currentRetry,
    $$fullTitle: this.fullTitle(),
    $$isPending: Boolean(this.pending),
    $$retriedTest: this._retriedTest || null,
    $$slow: this._slow,
    $$titlePath: this.titlePath(),
    body: this.body,
    duration: this.duration,
    err: this.err,
    parent: {
      $$fullTitle: this.parent.fullTitle(),
      [MOCHA_ID_PROP_NAME]: this.parent.id
    },
    speed: this.speed,
    state: this.state,
    title: this.title,
    type: this.type,
    file: this.file,
    [MOCHA_ID_PROP_NAME]: this.id
  };
};


/***/ }),

/***/ "./node_modules/mocha/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/mocha/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer, process) {

/**
 * Various utility functions used throughout Mocha's codebase.
 * @module utils
 */

/**
 * Module dependencies.
 */

const {nanoid} = __webpack_require__(/*! nanoid/non-secure */ "./node_modules/nanoid/non-secure/index.js");
var path = __webpack_require__(/*! path */ 3);
var util = __webpack_require__(/*! util */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/util/util.js");
var he = __webpack_require__(/*! he */ "./node_modules/he/he.js");

const MOCHA_ID_PROP_NAME = '__mocha_id__';

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * @param {function} ctor - Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor - Constructor function to inherit prototype from.
 * @throws {TypeError} if either constructor is null, or if super constructor
 *     lacks a prototype.
 */
exports.inherits = util.inherits;

/**
 * Escape special characters in the given string of html.
 *
 * @private
 * @param  {string} html
 * @return {string}
 */
exports.escape = function (html) {
  return he.encode(String(html), {useNamedReferences: false});
};

/**
 * Test if the given obj is type of string.
 *
 * @private
 * @param {Object} obj
 * @return {boolean}
 */
exports.isString = function (obj) {
  return typeof obj === 'string';
};

/**
 * Compute a slug from the given `str`.
 *
 * @private
 * @param {string} str
 * @return {string}
 */
exports.slug = function (str) {
  return str
    .toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/[^-\w]/g, '')
    .replace(/-{2,}/g, '-');
};

/**
 * Strip the function definition from `str`, and re-indent for pre whitespace.
 *
 * @param {string} str
 * @return {string}
 */
exports.clean = function (str) {
  str = str
    .replace(/\r\n?|[\n\u2028\u2029]/g, '\n')
    .replace(/^\uFEFF/, '')
    // (traditional)->  space/name     parameters    body     (lambda)-> parameters       body   multi-statement/single          keep body content
    .replace(
      /^function(?:\s*|\s+[^(]*)\([^)]*\)\s*\{((?:.|\n)*?)\s*\}$|^\([^)]*\)\s*=>\s*(?:\{((?:.|\n)*?)\s*\}|((?:.|\n)*))$/,
      '$1$2$3'
    );

  var spaces = str.match(/^\n?( *)/)[1].length;
  var tabs = str.match(/^\n?(\t*)/)[1].length;
  var re = new RegExp(
    '^\n?' + (tabs ? '\t' : ' ') + '{' + (tabs || spaces) + '}',
    'gm'
  );

  str = str.replace(re, '');

  return str.trim();
};

/**
 * If a value could have properties, and has none, this function is called,
 * which returns a string representation of the empty value.
 *
 * Functions w/ no properties return `'[Function]'`
 * Arrays w/ length === 0 return `'[]'`
 * Objects w/ no properties return `'{}'`
 * All else: return result of `value.toString()`
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} typeHint The type of the value
 * @returns {string}
 */
function emptyRepresentation(value, typeHint) {
  switch (typeHint) {
    case 'function':
      return '[Function]';
    case 'object':
      return '{}';
    case 'array':
      return '[]';
    default:
      return value.toString();
  }
}

/**
 * Takes some variable and asks `Object.prototype.toString()` what it thinks it
 * is.
 *
 * @private
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString
 * @param {*} value The value to test.
 * @returns {string} Computed type
 * @example
 * canonicalType({}) // 'object'
 * canonicalType([]) // 'array'
 * canonicalType(1) // 'number'
 * canonicalType(false) // 'boolean'
 * canonicalType(Infinity) // 'number'
 * canonicalType(null) // 'null'
 * canonicalType(new Date()) // 'date'
 * canonicalType(/foo/) // 'regexp'
 * canonicalType('type') // 'string'
 * canonicalType(global) // 'global'
 * canonicalType(new String('foo') // 'object'
 * canonicalType(async function() {}) // 'asyncfunction'
 * canonicalType(await import(name)) // 'module'
 */
var canonicalType = (exports.canonicalType = function canonicalType(value) {
  if (value === undefined) {
    return 'undefined';
  } else if (value === null) {
    return 'null';
  } else if (Buffer.isBuffer(value)) {
    return 'buffer';
  }
  return Object.prototype.toString
    .call(value)
    .replace(/^\[.+\s(.+?)]$/, '$1')
    .toLowerCase();
});

/**
 *
 * Returns a general type or data structure of a variable
 * @private
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures
 * @param {*} value The value to test.
 * @returns {string} One of undefined, boolean, number, string, bigint, symbol, object
 * @example
 * type({}) // 'object'
 * type([]) // 'array'
 * type(1) // 'number'
 * type(false) // 'boolean'
 * type(Infinity) // 'number'
 * type(null) // 'null'
 * type(new Date()) // 'object'
 * type(/foo/) // 'object'
 * type('type') // 'string'
 * type(global) // 'object'
 * type(new String('foo') // 'string'
 */
exports.type = function type(value) {
  // Null is special
  if (value === null) return 'null';
  const primitives = new Set([
    'undefined',
    'boolean',
    'number',
    'string',
    'bigint',
    'symbol'
  ]);
  const _type = typeof value;
  if (_type === 'function') return _type;
  if (primitives.has(_type)) return _type;
  if (value instanceof String) return 'string';
  if (value instanceof Error) return 'error';
  if (Array.isArray(value)) return 'array';

  return _type;
};

/**
 * Stringify `value`. Different behavior depending on type of value:
 *
 * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.
 * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.
 * - If `value` is an *empty* object, function, or array, return result of function
 *   {@link emptyRepresentation}.
 * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of
 *   JSON.stringify().
 *
 * @private
 * @see exports.type
 * @param {*} value
 * @return {string}
 */
exports.stringify = function (value) {
  var typeHint = canonicalType(value);

  if (!~['object', 'array', 'function'].indexOf(typeHint)) {
    if (typeHint === 'buffer') {
      var json = Buffer.prototype.toJSON.call(value);
      // Based on the toJSON result
      return jsonStringify(
        json.data && json.type ? json.data : json,
        2
      ).replace(/,(\n|$)/g, '$1');
    }

    // IE7/IE8 has a bizarre String constructor; needs to be coerced
    // into an array and back to obj.
    if (typeHint === 'string' && typeof value === 'object') {
      value = value.split('').reduce(function (acc, char, idx) {
        acc[idx] = char;
        return acc;
      }, {});
      typeHint = 'object';
    } else {
      return jsonStringify(value);
    }
  }

  for (var prop in value) {
    if (Object.prototype.hasOwnProperty.call(value, prop)) {
      return jsonStringify(
        exports.canonicalize(value, null, typeHint),
        2
      ).replace(/,(\n|$)/g, '$1');
    }
  }

  return emptyRepresentation(value, typeHint);
};

/**
 * like JSON.stringify but more sense.
 *
 * @private
 * @param {Object}  object
 * @param {number=} spaces
 * @param {number=} depth
 * @returns {*}
 */
function jsonStringify(object, spaces, depth) {
  if (typeof spaces === 'undefined') {
    // primitive types
    return _stringify(object);
  }

  depth = depth || 1;
  var space = spaces * depth;
  var str = Array.isArray(object) ? '[' : '{';
  var end = Array.isArray(object) ? ']' : '}';
  var length =
    typeof object.length === 'number'
      ? object.length
      : Object.keys(object).length;
  // `.repeat()` polyfill
  function repeat(s, n) {
    return new Array(n).join(s);
  }

  function _stringify(val) {
    switch (canonicalType(val)) {
      case 'null':
      case 'undefined':
        val = '[' + val + ']';
        break;
      case 'array':
      case 'object':
        val = jsonStringify(val, spaces, depth + 1);
        break;
      case 'boolean':
      case 'regexp':
      case 'symbol':
      case 'number':
        val =
          val === 0 && 1 / val === -Infinity // `-0`
            ? '-0'
            : val.toString();
        break;
      case 'bigint':
        val = val.toString() + 'n';
        break;
      case 'date':
        var sDate = isNaN(val.getTime()) ? val.toString() : val.toISOString();
        val = '[Date: ' + sDate + ']';
        break;
      case 'buffer':
        var json = val.toJSON();
        // Based on the toJSON result
        json = json.data && json.type ? json.data : json;
        val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']';
        break;
      default:
        val =
          val === '[Function]' || val === '[Circular]'
            ? val
            : JSON.stringify(val); // string
    }
    return val;
  }

  for (var i in object) {
    if (!Object.prototype.hasOwnProperty.call(object, i)) {
      continue; // not my business
    }
    --length;
    str +=
      '\n ' +
      repeat(' ', space) +
      (Array.isArray(object) ? '' : '"' + i + '": ') + // key
      _stringify(object[i]) + // value
      (length ? ',' : ''); // comma
  }

  return (
    str +
    // [], {}
    (str.length !== 1 ? '\n' + repeat(' ', --space) + end : end)
  );
}

/**
 * Return a new Thing that has the keys in sorted order. Recursive.
 *
 * If the Thing...
 * - has already been seen, return string `'[Circular]'`
 * - is `undefined`, return string `'[undefined]'`
 * - is `null`, return value `null`
 * - is some other primitive, return the value
 * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method
 * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.
 * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`
 *
 * @private
 * @see {@link exports.stringify}
 * @param {*} value Thing to inspect.  May or may not have properties.
 * @param {Array} [stack=[]] Stack of seen values
 * @param {string} [typeHint] Type hint
 * @return {(Object|Array|Function|string|undefined)}
 */
exports.canonicalize = function canonicalize(value, stack, typeHint) {
  var canonicalizedObj;
  /* eslint-disable no-unused-vars */
  var prop;
  /* eslint-enable no-unused-vars */
  typeHint = typeHint || canonicalType(value);
  function withStack(value, fn) {
    stack.push(value);
    fn();
    stack.pop();
  }

  stack = stack || [];

  if (stack.indexOf(value) !== -1) {
    return '[Circular]';
  }

  switch (typeHint) {
    case 'undefined':
    case 'buffer':
    case 'null':
      canonicalizedObj = value;
      break;
    case 'array':
      withStack(value, function () {
        canonicalizedObj = value.map(function (item) {
          return exports.canonicalize(item, stack);
        });
      });
      break;
    case 'function':
      /* eslint-disable-next-line no-unused-vars, no-unreachable-loop */
      for (prop in value) {
        canonicalizedObj = {};
        break;
      }
      /* eslint-enable guard-for-in */
      if (!canonicalizedObj) {
        canonicalizedObj = emptyRepresentation(value, typeHint);
        break;
      }
    /* falls through */
    case 'object':
      canonicalizedObj = canonicalizedObj || {};
      withStack(value, function () {
        Object.keys(value)
          .sort()
          .forEach(function (key) {
            canonicalizedObj[key] = exports.canonicalize(value[key], stack);
          });
      });
      break;
    case 'date':
    case 'number':
    case 'regexp':
    case 'boolean':
    case 'symbol':
      canonicalizedObj = value;
      break;
    default:
      canonicalizedObj = value + '';
  }

  return canonicalizedObj;
};

/**
 * @summary
 * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)
 * @description
 * When invoking this function you get a filter function that get the Error.stack as an input,
 * and return a prettify output.
 * (i.e: strip Mocha and internal node functions from stack trace).
 * @returns {Function}
 */
exports.stackTraceFilter = function () {
  // TODO: Replace with `process.browser`
  var is = typeof document === 'undefined' ? {node: true} : {browser: true};
  var slash = path.sep;
  var cwd;
  if (is.node) {
    cwd = exports.cwd() + slash;
  } else {
    cwd = (
      typeof location === 'undefined' ? window.location : location
    ).href.replace(/\/[^/]*$/, '/');
    slash = '/';
  }

  function isMochaInternal(line) {
    return (
      ~line.indexOf('node_modules' + slash + 'mocha' + slash) ||
      ~line.indexOf(slash + 'mocha.js') ||
      ~line.indexOf(slash + 'mocha.min.js')
    );
  }

  function isNodeInternal(line) {
    return (
      ~line.indexOf('(timers.js:') ||
      ~line.indexOf('(events.js:') ||
      ~line.indexOf('(node.js:') ||
      ~line.indexOf('(module.js:') ||
      ~line.indexOf('GeneratorFunctionPrototype.next (native)') ||
      false
    );
  }

  return function (stack) {
    stack = stack.split('\n');

    stack = stack.reduce(function (list, line) {
      if (isMochaInternal(line)) {
        return list;
      }

      if (is.node && isNodeInternal(line)) {
        return list;
      }

      // Clean up cwd(absolute)
      if (/:\d+:\d+\)?$/.test(line)) {
        line = line.replace('(' + cwd, '(');
      }

      list.push(line);
      return list;
    }, []);

    return stack.join('\n');
  };
};

/**
 * Crude, but effective.
 * @public
 * @param {*} value
 * @returns {boolean} Whether or not `value` is a Promise
 */
exports.isPromise = function isPromise(value) {
  return (
    typeof value === 'object' &&
    value !== null &&
    typeof value.then === 'function'
  );
};

/**
 * Clamps a numeric value to an inclusive range.
 *
 * @param {number} value - Value to be clamped.
 * @param {number[]} range - Two element array specifying [min, max] range.
 * @returns {number} clamped value
 */
exports.clamp = function clamp(value, range) {
  return Math.min(Math.max(value, range[0]), range[1]);
};

/**
 * It's a noop.
 * @public
 */
exports.noop = function () {};

/**
 * Creates a map-like object.
 *
 * @description
 * A "map" is an object with no prototype, for our purposes. In some cases
 * this would be more appropriate than a `Map`, especially if your environment
 * doesn't support it. Recommended for use in Mocha's public APIs.
 *
 * @public
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Custom_and_Null_objects|MDN:Map}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Custom_and_Null_objects|MDN:Object.create - Custom objects}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Custom_and_Null_objects|MDN:Object.assign}
 * @param {...*} [obj] - Arguments to `Object.assign()`.
 * @returns {Object} An object with no prototype, having `...obj` properties
 */
exports.createMap = function (obj) {
  return Object.assign.apply(
    null,
    [Object.create(null)].concat(Array.prototype.slice.call(arguments))
  );
};

/**
 * Creates a read-only map-like object.
 *
 * @description
 * This differs from {@link module:utils.createMap createMap} only in that
 * the argument must be non-empty, because the result is frozen.
 *
 * @see {@link module:utils.createMap createMap}
 * @param {...*} [obj] - Arguments to `Object.assign()`.
 * @returns {Object} A frozen object with no prototype, having `...obj` properties
 * @throws {TypeError} if argument is not a non-empty object.
 */
exports.defineConstants = function (obj) {
  if (canonicalType(obj) !== 'object' || !Object.keys(obj).length) {
    throw new TypeError('Invalid argument; expected a non-empty object');
  }
  return Object.freeze(exports.createMap(obj));
};

/**
 * Returns current working directory
 *
 * Wrapper around `process.cwd()` for isolation
 * @private
 */
exports.cwd = function cwd() {
  return process.cwd();
};

/**
 * Returns `true` if Mocha is running in a browser.
 * Checks for `process.browser`.
 * @returns {boolean}
 * @private
 */
exports.isBrowser = function isBrowser() {
  return Boolean(process.browser);
};

/*
 * Casts `value` to an array; useful for optionally accepting array parameters
 *
 * It follows these rules, depending on `value`.  If `value` is...
 * 1. `undefined`: return an empty Array
 * 2. `null`: return an array with a single `null` element
 * 3. Any other object: return the value of `Array.from()` _if_ the object is iterable
 * 4. otherwise: return an array with a single element, `value`
 * @param {*} value - Something to cast to an Array
 * @returns {Array<*>}
 */
exports.castArray = function castArray(value) {
  if (value === undefined) {
    return [];
  }
  if (value === null) {
    return [null];
  }
  if (
    typeof value === 'object' &&
    (typeof value[Symbol.iterator] === 'function' || value.length !== undefined)
  ) {
    return Array.from(value);
  }
  return [value];
};

exports.constants = exports.defineConstants({
  MOCHA_ID_PROP_NAME
});

/**
 * Creates a new unique identifier
 * @returns {string} Unique identifier
 */
exports.uniqueID = () => nanoid();

exports.assignNewMochaID = obj => {
  const id = exports.uniqueID();
  Object.defineProperty(obj, MOCHA_ID_PROP_NAME, {
    get() {
      return id;
    }
  });
  return obj;
};

/**
 * Retrieves a Mocha ID from an object, if present.
 * @param {*} [obj] - Object
 * @returns {string|void}
 */
exports.getMochaID = obj =>
  obj && typeof obj === 'object' ? obj[MOCHA_ID_PROP_NAME] : undefined;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../../../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js */ "../../Users/Admin/AppData/Local/Cypress/Cache/10.7.0/Cypress/resources/app/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mocha/node_modules/escape-string-regexp/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mocha/node_modules/escape-string-regexp/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = string => {
	if (typeof string !== 'string') {
		throw new TypeError('Expected a string');
	}

	// Escape characters with special meaning either inside or outside character sets.
	// Use a simple backslash escape when its always valid, and a \unnnn escape when the simpler form would be disallowed by Unicode patterns stricter grammar.
	return string
		.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
		.replace(/-/g, '\\x2d');
};


/***/ }),

/***/ "./node_modules/mocha/node_modules/ms/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mocha/node_modules/ms/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/mocha/package.json":
/*!*****************************************!*\
  !*** ./node_modules/mocha/package.json ***!
  \*****************************************/
/*! exports provided: name, version, type, description, keywords, author, license, repository, bugs, funding, gitter, homepage, logo, notifyLogo, bin, directories, engines, scripts, dependencies, devDependencies, files, browser, prettier, husky, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"mocha\",\"version\":\"10.0.0\",\"type\":\"commonjs\",\"description\":\"simple, flexible, fun test framework\",\"keywords\":[\"mocha\",\"test\",\"bdd\",\"tdd\",\"tap\",\"testing\",\"chai\",\"assertion\",\"ava\",\"jest\",\"tape\",\"jasmine\",\"karma\"],\"author\":\"TJ Holowaychuk <tj@vision-media.ca>\",\"license\":\"MIT\",\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/mochajs/mocha.git\"},\"bugs\":{\"url\":\"https://github.com/mochajs/mocha/issues/\"},\"funding\":{\"type\":\"opencollective\",\"url\":\"https://opencollective.com/mochajs\"},\"gitter\":\"https://gitter.im/mochajs/mocha\",\"homepage\":\"https://mochajs.org/\",\"logo\":\"https://cldup.com/S9uQ-cOLYz.svg\",\"notifyLogo\":\"https://ibin.co/4QuRuGjXvl36.png\",\"bin\":{\"mocha\":\"./bin/mocha.js\",\"_mocha\":\"./bin/_mocha\"},\"directories\":{\"lib\":\"./lib\",\"test\":\"./test\"},\"engines\":{\"node\":\">= 14.0.0\"},\"scripts\":{\"prepublishOnly\":\"nps test clean build\",\"start\":\"nps\",\"test\":\"nps test\",\"version\":\"nps version\",\"test:smoke\":\"node ./bin/mocha --no-config test/smoke/smoke.spec.js\"},\"dependencies\":{\"@ungap/promise-all-settled\":\"1.1.2\",\"ansi-colors\":\"4.1.1\",\"browser-stdout\":\"1.3.1\",\"chokidar\":\"3.5.3\",\"debug\":\"4.3.4\",\"diff\":\"5.0.0\",\"escape-string-regexp\":\"4.0.0\",\"find-up\":\"5.0.0\",\"glob\":\"7.2.0\",\"he\":\"1.2.0\",\"js-yaml\":\"4.1.0\",\"log-symbols\":\"4.1.0\",\"minimatch\":\"5.0.1\",\"ms\":\"2.1.3\",\"nanoid\":\"3.3.3\",\"serialize-javascript\":\"6.0.0\",\"strip-json-comments\":\"3.1.1\",\"supports-color\":\"8.1.1\",\"workerpool\":\"6.2.1\",\"yargs\":\"16.2.0\",\"yargs-parser\":\"20.2.4\",\"yargs-unparser\":\"2.0.0\"},\"devDependencies\":{\"@11ty/eleventy\":\"^1.0.0\",\"@11ty/eleventy-plugin-inclusive-language\":\"^1.0.3\",\"@babel/eslint-parser\":\"^7.16.5\",\"@mocha/docdash\":\"^4.0.1\",\"@rollup/plugin-commonjs\":\"^21.0.2\",\"@rollup/plugin-json\":\"^4.1.0\",\"@rollup/plugin-multi-entry\":\"^4.0.1\",\"@rollup/plugin-node-resolve\":\"^13.1.3\",\"assetgraph-builder\":\"^9.0.0\",\"autoprefixer\":\"^9.8.6\",\"canvas\":\"^2.9.0\",\"chai\":\"^4.3.4\",\"coffeescript\":\"^2.6.1\",\"configstore\":\"^5.0.1\",\"coveralls\":\"^3.1.1\",\"cross-env\":\"^7.0.2\",\"eslint\":\"^7.32.0\",\"eslint-config-prettier\":\"^8.3.0\",\"eslint-config-semistandard\":\"^16.0.0\",\"eslint-config-standard\":\"^16.0.3\",\"eslint-plugin-import\":\"^2.24.2\",\"eslint-plugin-node\":\"^11.1.0\",\"eslint-plugin-prettier\":\"^4.0.0\",\"eslint-plugin-promise\":\"^5.1.0\",\"fail-on-errors-webpack-plugin\":\"^3.0.0\",\"fs-extra\":\"^10.0.0\",\"husky\":\"^4.2.5\",\"hyperlink\":\"^5.0.4\",\"jsdoc\":\"^3.6.7\",\"jsdoc-ts-utils\":\"^2.0.1\",\"karma\":\"^6.3.11\",\"karma-chrome-launcher\":\"^3.1.0\",\"karma-mocha\":\"^2.0.1\",\"karma-mocha-reporter\":\"^2.2.5\",\"karma-sauce-launcher\":\"^4.3.6\",\"lint-staged\":\"^10.2.11\",\"markdown-it\":\"^12.3.2\",\"markdown-it-anchor\":\"^8.4.1\",\"markdown-it-attrs\":\"^4.1.3\",\"markdown-it-emoji\":\"^2.0.0\",\"markdown-it-prism\":\"^2.2.2\",\"markdown-toc\":\"^1.2.0\",\"markdownlint-cli\":\"^0.30.0\",\"needle\":\"^2.5.0\",\"nps\":\"^5.10.0\",\"nyc\":\"^15.1.0\",\"pidtree\":\"^0.5.0\",\"prettier\":\"^2.4.1\",\"remark\":\"^14.0.2\",\"remark-github\":\"^11.2.2\",\"remark-inline-links\":\"^6.0.1\",\"rewiremock\":\"^3.14.3\",\"rimraf\":\"^3.0.2\",\"rollup\":\"^2.70.1\",\"rollup-plugin-node-globals\":\"^1.4.0\",\"rollup-plugin-polyfill-node\":\"^0.8.0\",\"rollup-plugin-visualizer\":\"^5.6.0\",\"sinon\":\"^9.0.3\",\"strip-ansi\":\"^6.0.0\",\"svgo\":\"^1.3.2\",\"through2\":\"^4.0.2\",\"touch\":\"^3.1.0\",\"unexpected\":\"^11.14.0\",\"unexpected-eventemitter\":\"^2.2.0\",\"unexpected-map\":\"^2.0.0\",\"unexpected-set\":\"^3.0.0\",\"unexpected-sinon\":\"^10.11.2\",\"update-notifier\":\"^4.1.0\",\"uslug\":\"^1.0.4\",\"uuid\":\"^8.3.0\",\"watchify\":\"^4.0.0\",\"webpack\":\"^5.67.0\",\"webpack-cli\":\"^4.9.1\"},\"files\":[\"bin/*mocha*\",\"lib/**/*.{js,html,json}\",\"index.js\",\"mocha.css\",\"mocha.js\",\"mocha.js.map\",\"browser-entry.js\"],\"browser\":{\"./index.js\":\"./browser-entry.js\",\"fs\":false,\"path\":false,\"supports-color\":false,\"./lib/nodejs/buffered-worker-pool.js\":false,\"./lib/nodejs/esm-utils.js\":false,\"./lib/nodejs/file-unloader.js\":false,\"./lib/nodejs/parallel-buffered-runner.js\":false,\"./lib/nodejs/serializer.js\":false,\"./lib/nodejs/worker.js\":false,\"./lib/nodejs/reporters/parallel-buffered.js\":false,\"./lib/cli/index.js\":false},\"prettier\":{\"arrowParens\":\"avoid\",\"bracketSpacing\":false,\"endOfLine\":\"auto\",\"singleQuote\":true,\"trailingComma\":\"none\"},\"husky\":{\"hooks\":{\"pre-commit\":\"lint-staged\"}}}");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/nanoid/non-secure/index.js":
/*!*************************************************!*\
  !*** ./node_modules/nanoid/non-secure/index.js ***!
  \*************************************************/
/*! exports provided: nanoid, customAlphabet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nanoid", function() { return nanoid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "customAlphabet", function() { return customAlphabet; });
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'
let customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = ''
    let i = size
    while (i--) {
      id += alphabet[(Math.random() * alphabet.length) | 0]
    }
    return id
  }
}
let nanoid = (size = 21) => {
  let id = ''
  let i = size
  while (i--) {
    id += urlAlphabet[(Math.random() * 64) | 0]
  }
  return id
}



/***/ }),

/***/ 0:
/*!*********************************************!*\
  !*** multi ./cypress/e2e/tests/login.cy.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! C:\Projects\CypressProject\cypress\e2e\tests\login.cy.js */"./cypress/e2e/tests/login.cy.js");


/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 3:
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 4:
/*!********************************!*\
  !*** supports-color (ignored) ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 5:
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 6:
/*!************************************!*\
  !*** ./nodejs/esm-utils (ignored) ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 7:
/*!****************************************!*\
  !*** ./nodejs/file-unloader (ignored) ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 8:
/*!***************************************************!*\
  !*** ./nodejs/parallel-buffered-runner (ignored) ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL0FkbWluL0FwcERhdGEvTG9jYWwvQ3lwcmVzcy9DYWNoZS8xMC43LjAvQ3lwcmVzcy9yZXNvdXJjZXMvYXBwL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL0FkbWluL0FwcERhdGEvTG9jYWwvQ3lwcmVzcy9DYWNoZS8xMC43LjAvQ3lwcmVzcy9yZXNvdXJjZXMvYXBwL25vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL0FkbWluL0FwcERhdGEvTG9jYWwvQ3lwcmVzcy9DYWNoZS8xMC43LjAvQ3lwcmVzcy9yZXNvdXJjZXMvYXBwL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9BZG1pbi9BcHBEYXRhL0xvY2FsL0N5cHJlc3MvQ2FjaGUvMTAuNy4wL0N5cHJlc3MvcmVzb3VyY2VzL2FwcC9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvQWRtaW4vQXBwRGF0YS9Mb2NhbC9DeXByZXNzL0NhY2hlLzEwLjcuMC9DeXByZXNzL3Jlc291cmNlcy9hcHAvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL0FkbWluL0FwcERhdGEvTG9jYWwvQ3lwcmVzcy9DYWNoZS8xMC43LjAvQ3lwcmVzcy9yZXNvdXJjZXMvYXBwL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9BZG1pbi9BcHBEYXRhL0xvY2FsL0N5cHJlc3MvQ2FjaGUvMTAuNy4wL0N5cHJlc3MvcmVzb3VyY2VzL2FwcC9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvQWRtaW4vQXBwRGF0YS9Mb2NhbC9DeXByZXNzL0NhY2hlLzEwLjcuMC9DeXByZXNzL3Jlc291cmNlcy9hcHAvbm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9BZG1pbi9BcHBEYXRhL0xvY2FsL0N5cHJlc3MvQ2FjaGUvMTAuNy4wL0N5cHJlc3MvcmVzb3VyY2VzL2FwcC9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9BZG1pbi9BcHBEYXRhL0xvY2FsL0N5cHJlc3MvQ2FjaGUvMTAuNy4wL0N5cHJlc3MvcmVzb3VyY2VzL2FwcC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9BZG1pbi9BcHBEYXRhL0xvY2FsL0N5cHJlc3MvQ2FjaGUvMTAuNy4wL0N5cHJlc3MvcmVzb3VyY2VzL2FwcC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvQWRtaW4vQXBwRGF0YS9Mb2NhbC9DeXByZXNzL0NhY2hlLzEwLjcuMC9DeXByZXNzL3Jlc291cmNlcy9hcHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvQWRtaW4vQXBwRGF0YS9Mb2NhbC9DeXByZXNzL0NhY2hlLzEwLjcuMC9DeXByZXNzL3Jlc291cmNlcy9hcHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvQWRtaW4vQXBwRGF0YS9Mb2NhbC9DeXByZXNzL0NhY2hlLzEwLjcuMC9DeXByZXNzL3Jlc291cmNlcy9hcHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL0FkbWluL0FwcERhdGEvTG9jYWwvQ3lwcmVzcy9DYWNoZS8xMC43LjAvQ3lwcmVzcy9yZXNvdXJjZXMvYXBwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL0FkbWluL0FwcERhdGEvTG9jYWwvQ3lwcmVzcy9DYWNoZS8xMC43LjAvQ3lwcmVzcy9yZXNvdXJjZXMvYXBwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvQWRtaW4vQXBwRGF0YS9Mb2NhbC9DeXByZXNzL0NhY2hlLzEwLjcuMC9DeXByZXNzL3Jlc291cmNlcy9hcHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9BZG1pbi9BcHBEYXRhL0xvY2FsL0N5cHJlc3MvQ2FjaGUvMTAuNy4wL0N5cHJlc3MvcmVzb3VyY2VzL2FwcC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9BZG1pbi9BcHBEYXRhL0xvY2FsL0N5cHJlc3MvQ2FjaGUvMTAuNy4wL0N5cHJlc3MvcmVzb3VyY2VzL2FwcC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvQWRtaW4vQXBwRGF0YS9Mb2NhbC9DeXByZXNzL0NhY2hlLzEwLjcuMC9DeXByZXNzL3Jlc291cmNlcy9hcHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvQWRtaW4vQXBwRGF0YS9Mb2NhbC9DeXByZXNzL0NhY2hlLzEwLjcuMC9DeXByZXNzL3Jlc291cmNlcy9hcHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9BZG1pbi9BcHBEYXRhL0xvY2FsL0N5cHJlc3MvQ2FjaGUvMTAuNy4wL0N5cHJlc3MvcmVzb3VyY2VzL2FwcC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvQWRtaW4vQXBwRGF0YS9Mb2NhbC9DeXByZXNzL0NhY2hlLzEwLjcuMC9DeXByZXNzL3Jlc291cmNlcy9hcHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS1icm93c2VyLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9BZG1pbi9BcHBEYXRhL0xvY2FsL0N5cHJlc3MvQ2FjaGUvMTAuNy4wL0N5cHJlc3MvcmVzb3VyY2VzL2FwcC9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL0FkbWluL0FwcERhdGEvTG9jYWwvQ3lwcmVzcy9DYWNoZS8xMC43LjAvQ3lwcmVzcy9yZXNvdXJjZXMvYXBwL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9BZG1pbi9BcHBEYXRhL0xvY2FsL0N5cHJlc3MvQ2FjaGUvMTAuNy4wL0N5cHJlc3MvcmVzb3VyY2VzL2FwcC9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL0FkbWluL0FwcERhdGEvTG9jYWwvQ3lwcmVzcy9DYWNoZS8xMC43LjAvQ3lwcmVzcy9yZXNvdXJjZXMvYXBwL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL0FkbWluL0FwcERhdGEvTG9jYWwvQ3lwcmVzcy9DYWNoZS8xMC43LjAvQ3lwcmVzcy9yZXNvdXJjZXMvYXBwL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9BZG1pbi9BcHBEYXRhL0xvY2FsL0N5cHJlc3MvQ2FjaGUvMTAuNy4wL0N5cHJlc3MvcmVzb3VyY2VzL2FwcC9ub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvQWRtaW4vQXBwRGF0YS9Mb2NhbC9DeXByZXNzL0NhY2hlLzEwLjcuMC9DeXByZXNzL3Jlc291cmNlcy9hcHAvbm9kZV9tb2R1bGVzL3V0aWwvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL0FkbWluL0FwcERhdGEvTG9jYWwvQ3lwcmVzcy9DYWNoZS8xMC43LjAvQ3lwcmVzcy9yZXNvdXJjZXMvYXBwL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9BZG1pbi9BcHBEYXRhL0xvY2FsL0N5cHJlc3MvQ2FjaGUvMTAuNy4wL0N5cHJlc3MvcmVzb3VyY2VzL2FwcC9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9jeXByZXNzL2UyZS9iYXNlQ2xhc3MvQmFzZUNsYXNzLmpzIiwid2VicGFjazovLy8uL2N5cHJlc3MvZTJlL3BhZ2VzL2xvZ2luX3BhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vY3lwcmVzcy9lMmUvdGVzdHMvbG9naW4uY3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXItc3Rkb3V0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlmZi9kaXN0L2RpZmYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hlL2hlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2ctc3ltYm9scy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS9icm93c2VyLWVudHJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIgc3luYyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2Jyb3dzZXIvaGlnaGxpZ2h0LXRhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9icm93c2VyL3BhcnNlLXF1ZXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvYnJvd3Nlci9wcm9ncmVzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9ob29rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvaW50ZXJmYWNlcy9iZGQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9pbnRlcmZhY2VzL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2ludGVyZmFjZXMvZXhwb3J0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2ludGVyZmFjZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9pbnRlcmZhY2VzL3F1bml0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvaW50ZXJmYWNlcy90ZGQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9tb2NoYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3BlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9kb2MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvZG90LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvcmVwb3J0ZXJzL2h0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvanNvbi1zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9sYW5kaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvcmVwb3J0ZXJzL2xpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvbWFya2Rvd24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvbWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvcmVwb3J0ZXJzL255YW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvcHJvZ3Jlc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvc3BlYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy90YXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMveHVuaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9ydW5uYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3J1bm5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3N0YXRzLWNvbGxlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3N1aXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvdGVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS9ub2RlX21vZHVsZXMvZXNjYXBlLXN0cmluZy1yZWdleHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25hbm9pZC9ub24tc2VjdXJlL2luZGV4LmpzIiwid2VicGFjazovLy91dGlsIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vdXRpbCAoaWdub3JlZCk/NTY0YiIsIndlYnBhY2s6Ly8vcGF0aCAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vL3N1cHBvcnRzLWNvbG9yIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vcGF0aCAoaWdub3JlZCk/MzY4MiIsIndlYnBhY2s6Ly8vLi9ub2RlanMvZXNtLXV0aWxzIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vLi9ub2RlanMvZmlsZS11bmxvYWRlciAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vLy4vbm9kZWpzL3BhcmFsbGVsLWJ1ZmZlcmVkLXJ1bm5lciAoaWdub3JlZCkiXSwibmFtZXMiOlsiQmFzZUNsYXNzIiwiYnJvd3NlckluaXRpYWxpemF0aW9uIiwiY3kiLCJ2aXNpdCIsIkN5cHJlc3MiLCJvbiIsImVyciIsInJ1bm5hYmxlIiwiTG9naW5QYWdlIiwiZW50ZXJVc2VybmFtZSIsInVzZXJuYW1lIiwiZ2V0IiwidHlwZSIsImVudGVyUGFzc3dvcmQiLCJwYXNzd29yZCIsImNsaWNrTG9naW4iLCJjbGljayIsInByb2ZpbGVOYW1lIiwid2FpdCIsImxvZ2lucGFnZSIsImJhc2VjbGFzcyIsImRlc2NyaWJlIiwiaXQiXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xGWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLHlCQUF5QjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQsYUFBYTtBQUMxRTtBQUNBLDZEQUE2RCxhQUFhO0FBQzFFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLFFBQVEsVUFBVTs7QUFFbEI7QUFDQTs7Ozs7Ozs7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzFCQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyw2SEFBVztBQUNoQyxjQUFjLG1CQUFPLENBQUMseUhBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLHlIQUFTOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFtRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDNXZEQSwrQ0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7Ozs7O0FDdkx0QyxpQkFBaUIsbUJBQU8sQ0FBQyw4SkFBeUI7Ozs7Ozs7Ozs7Ozs7QUNBbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxVQUFV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QUFDQTtBQUNBLHNDQUFzQyxtQkFBTyxDQUFDLHFKQUFpQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxtREFBbUQsaUVBQWlFO0FBQ3BIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDMS9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7OztBQzlxQmE7O0FBRWIsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosYUFBYSxtQkFBTyxDQUFDLDhKQUFhO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQyxhQUFNOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7QUM5RWE7O0FBRWI7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLG1KQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7QUN6RUEsaUJBQWlCLG1CQUFPLENBQUMsd0hBQVE7Ozs7Ozs7Ozs7OztBQ0FqQztBQUNBLGFBQWEsbUJBQU8sQ0FBQyxzSkFBUTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDN0RBLGlCQUFpQixtQkFBTyxDQUFDLCtJQUFZOzs7Ozs7Ozs7Ozs7QUNBckMsMkJBQTJCLG1CQUFPLENBQUMsa0tBQTJCO0FBQzlEO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxrS0FBMkI7QUFDdEQsaUJBQWlCLG1CQUFPLENBQUMsOEpBQXlCO0FBQ2xELG9CQUFvQixtQkFBTyxDQUFDLG9LQUE0QjtBQUN4RCxzQkFBc0IsbUJBQU8sQ0FBQyx3S0FBOEI7Ozs7Ozs7Ozs7OztBQ041RCxpQkFBaUIsbUJBQU8sQ0FBQywrSUFBWTs7Ozs7Ozs7Ozs7O0FDQXJDLGlCQUFpQixtQkFBTyxDQUFDLGtLQUEyQjs7Ozs7Ozs7Ozs7O0FDQXBEO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsc0pBQVE7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7QUN6TEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTLG1CQUFPLENBQUMsd0hBQVE7QUFDekIsZUFBZSxtQkFBTyxDQUFDLHNJQUFVOztBQUVqQztBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGdLQUE2QjtBQUN2RCxrQkFBa0IsbUJBQU8sQ0FBQyxnS0FBNkI7QUFDdkQsZ0JBQWdCLG1CQUFPLENBQUMsNEpBQTJCO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLDBKQUE4QjtBQUN6RCxxQkFBcUIsbUJBQU8sQ0FBQyw4SkFBZ0M7O0FBRTdEO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLGlJQUFhO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0NBQXNDLHNDQUFzQztBQUN6RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLG1CQUFPLENBQUMsMElBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLEtBQUs7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7O0FBRUE7QUFDQTtB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QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7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QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTyxzQ0FBc0MsT0FBTztBQUN0RTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZ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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQmpDLGU7Ozs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7O0FDQUEsZSIsImZpbGUiOiJsb2dpbi5jeS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAhcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWRcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5QYXNzVGhyb3VnaFxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlRyYW5zZm9ybVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG4iLCIvKiEgc2FmZS1idWZmZXIuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJ1ZmZlci5wcm90b3R5cGUpXG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHx8XG4gIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciBkZXNjcmlwdG9ycyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzY3JpcHRvcnNba2V5c1tpXV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfTtcblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuXG5leHBvcnRzLnByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XG4gICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgZm4sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgKTtcbn1cblxuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyZWFzb24sIGNiKSB7XG4gIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgLy8gb2NjdXJyZWRcIiwgd2UgZXJyb3Itd3JhcCBzbyB0aGUgY2FsbGJhY2sgY29uc3VtZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICBpZiAoIXJlYXNvbikge1xuICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoJ1Byb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZScpO1xuICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xuICB9XG4gIHJldHVybiBjYihyZWFzb24pO1xufVxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxuICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IsIG51bGwsIHJldCkgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlaikgeyBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZCwgcmVqLCBjYikgfSk7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpKTtcbiAgcmV0dXJuIGNhbGxiYWNraWZpZWQ7XG59XG5leHBvcnRzLmNhbGxiYWNraWZ5ID0gY2FsbGJhY2tpZnk7XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJleHBvcnQgY2xhc3MgQmFzZUNsYXNzIHtcclxuICAgIC8vSW4gY3lwcmVzcyBjb2RlIGJsb2NrcyB0byBiZSBleGVjdXRlZCBiZWZvcmUgYWxsIGNhbiBhbHNvIGJlIGdpdmVuXHJcbiAgICAvL3VuZGVyIHN1cHBvcnQtPmUyZS5qcyBmaWxlLiAgSnVzdCBuZWVkIHRvIHdyaXRlIGJlZm9yZUVhY2goZnVuY3Rpb24oKSl7Li4uLmNvZGUgdG8gcnVuIGZpcnN0Li4uLn1cclxuXHJcbiAgICBicm93c2VySW5pdGlhbGl6YXRpb24oKSB7XHJcbiAgICAgICAgY3kudmlzaXQoJ2h0dHA6Ly9sb2NhbGhvc3Q6NDIwMC8jL2xvZ2luJylcclxuICAgICAgICBDeXByZXNzLm9uKCd1bmNhdWdodDpleGNlcHRpb24nLCAoZXJyLCBydW5uYWJsZSkgPT4geyByZXR1cm4gZmFsc2U7IH0pLy9UdXJuaW5nIHVuY291Z2h0IGV4Y2VwdGlvbiBvZmYgZm9yIGxvY2FsaG9zdFxyXG4gICAgfVxyXG59IiwiZXhwb3J0IGNsYXNzIExvZ2luUGFnZSB7IC8vZXhwb3J0IGtleXdvcmQgdG8gbWFrZSB0aGUgY2xhc3MgaW1wb3J0YWJsZVxyXG5cclxuXHJcbiAgICBlbnRlclVzZXJuYW1lKHVzZXJuYW1lKSB7XHJcbiAgICAgICAgY3kuZ2V0KCc6bnRoLWNoaWxkKDEpID4gLmZvcm0tY29udHJvbCcpLnR5cGUodXNlcm5hbWUpXHJcbiAgICB9XHJcblxyXG4gICAgZW50ZXJQYXNzd29yZChwYXNzd29yZCkge1xyXG4gICAgICAgIGN5LmdldCgnI2xvZ2luRGF0YXB3ZCcpLnR5cGUocGFzc3dvcmQpXHJcbiAgICB9XHJcblxyXG4gICAgY2xpY2tMb2dpbigpIHtcclxuICAgICAgICBjeS5nZXQoJy5idG4nKS5jbGljaygpXHJcbiAgICB9XHJcblxyXG4gICAgcHJvZmlsZU5hbWUoKSB7XHJcbiAgICAgICAgY3kud2FpdCg0MDAwKVxyXG4gICAgICAgIGN5LmdldCgnLm1lbnUtcHJvZmlsZSA+IC5yb3VuZGVkLWNpcmNsZScpLmNsaWNrKClcclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQgeyBiZWZvcmVFYWNoIH0gZnJvbSBcIm1vY2hhXCJcclxuaW1wb3J0IHsgTG9naW5QYWdlIH0gZnJvbSBcIi4uL3BhZ2VzL2xvZ2luX3BhZ2VcIiAgLy9wYWdlcyBmb2xkZXIgaXMgdHdvIGxldmVscyB1cCBmcm9tIHRoZSBjdXJyZW50IGNsYXNzLCBzbyBuZWVkIHRvIGdpdmUgdHdvIGRvdHMgYWZ0ZXIgdGhlIHNsYXNoIHRvIGFjY2VzcyBpdC5cclxuaW1wb3J0IHsgQmFzZUNsYXNzIH0gZnJvbSBcIi4uL2Jhc2VDbGFzcy9CYXNlQ2xhc3NcIlxyXG5cclxuY29uc3QgbG9naW5wYWdlID0gbmV3IExvZ2luUGFnZSgpXHJcbmNvbnN0IGJhc2VjbGFzcyA9IG5ldyBCYXNlQ2xhc3MoKVxyXG5cclxuXHJcbmJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgYmFzZWNsYXNzLmJyb3dzZXJJbml0aWFsaXphdGlvbigpIC8vVGhpcyBjYW4gYmUgZ2l2ZW4gaGVyZSBzbyB0aGF0IGJyb3dzZXIgaXMgaW5pdGlhbGl6ZWQgZm9yIGVhY2ggaXQgYmxvY2suXHJcbn0pXHJcblxyXG5kZXNjcmliZSgnQWxsIHRoZSBsb2dpbiBpdCBibG9ja3MgSGVyZSEhJywgZnVuY3Rpb24gKCkgeyAvL0FsbCB0aGUgbG9naW4gYmxvY2tzLi4uIG1lc3NhZ2Ugd2lsbCBjb21lIGF0IHRoZSB0b3Agb2YgdGhlIHRlc3QgcmVzdWx0c1xyXG5cclxuXHJcbiAgICBpdCgnTG9naW4gd2l0aCBjb3JyZWN0IGNyZWRlbnRpYWxzJywgKCkgPT4gey8vVXNlIFwiaXQub25seVwiIHRvIHJ1biBvbmx5IHRoaXMgaXQgYmxvY2suICBcIi5za2lwXCIgd2lsbCBza2lwIHRoZSBpdCBibG9jay5cclxuXHJcbiAgICAgICAgbG9naW5wYWdlLmVudGVyVXNlcm5hbWUoJ3N3YXJvb3BfdWF0QGRvcWZ5LmluJylcclxuICAgICAgICBsb2dpbnBhZ2UuZW50ZXJQYXNzd29yZCgnU3dhcm9vcEAyMDIyJylcclxuICAgICAgICBsb2dpbnBhZ2UuY2xpY2tMb2dpbigpXHJcbiAgICAgICAgbG9naW5wYWdlLnByb2ZpbGVOYW1lKClcclxuXHJcbiAgICB9KVxyXG5cclxuICAgIGl0KCdMb2dpbiB3aXRoIGludmFsaWQgcGFzc3dvcmQnLCAoKSA9PiB7XHJcblxyXG5cclxuICAgICAgICBsb2dpbnBhZ2UuZW50ZXJVc2VybmFtZSgnc3dhcm9vcF91YXRAZG9xZnkuaW4nKVxyXG4gICAgICAgIGxvZ2lucGFnZS5lbnRlclBhc3N3b3JkKCdTd2Fyb29wQDIwMjMnKS8vaW52YWxpZCBwYXNzd29kXHJcbiAgICAgICAgbG9naW5wYWdlLmNsaWNrTG9naW4oKVxyXG4gICAgICAgIGxvZ2lucGFnZS5wcm9maWxlTmFtZSgpXHJcblxyXG4gICAgfSlcclxufSkiLCJ2YXIgV3JpdGFibGVTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5Xcml0YWJsZVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG5cbm1vZHVsZS5leHBvcnRzID0gQnJvd3NlclN0ZG91dFxuXG5cbmluaGVyaXRzKEJyb3dzZXJTdGRvdXQsIFdyaXRhYmxlU3RyZWFtKVxuXG5mdW5jdGlvbiBCcm93c2VyU3Rkb3V0KG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJyb3dzZXJTdGRvdXQpKSByZXR1cm4gbmV3IEJyb3dzZXJTdGRvdXQob3B0cylcblxuICBvcHRzID0gb3B0cyB8fCB7fVxuICBXcml0YWJsZVN0cmVhbS5jYWxsKHRoaXMsIG9wdHMpXG4gIHRoaXMubGFiZWwgPSAob3B0cy5sYWJlbCAhPT0gdW5kZWZpbmVkKSA/IG9wdHMubGFiZWwgOiAnc3Rkb3V0J1xufVxuXG5Ccm93c2VyU3Rkb3V0LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVua3MsIGVuY29kaW5nLCBjYikge1xuICB2YXIgb3V0cHV0ID0gY2h1bmtzLnRvU3RyaW5nID8gY2h1bmtzLnRvU3RyaW5nKCkgOiBjaHVua3NcbiAgaWYgKHRoaXMubGFiZWwgPT09IGZhbHNlKSB7XG4gICAgY29uc29sZS5sb2cob3V0cHV0KVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKHRoaXMubGFiZWwrJzonLCBvdXRwdXQpXG4gIH1cbiAgcHJvY2Vzcy5uZXh0VGljayhjYilcbn1cbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblx0XHRsZXQgbmFtZXNwYWNlc0NhY2hlO1xuXHRcdGxldCBlbmFibGVkQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuXHRcdFx0XHRcdG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG5cdFx0XHRcdFx0ZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVuYWJsZWRDYWNoZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cdFx0Y3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zbGljZSgxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLkRpZmYgPSB7fSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIERpZmYoKSB7fVxuICBEaWZmLnByb3RvdHlwZSA9IHtcbiAgICBkaWZmOiBmdW5jdGlvbiBkaWZmKG9sZFN0cmluZywgbmV3U3RyaW5nKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICB2YXIgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIGRvbmUodmFsdWUpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIHZhbHVlKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQWxsb3cgc3ViY2xhc3NlcyB0byBtYXNzYWdlIHRoZSBpbnB1dCBwcmlvciB0byBydW5uaW5nXG5cblxuICAgICAgb2xkU3RyaW5nID0gdGhpcy5jYXN0SW5wdXQob2xkU3RyaW5nKTtcbiAgICAgIG5ld1N0cmluZyA9IHRoaXMuY2FzdElucHV0KG5ld1N0cmluZyk7XG4gICAgICBvbGRTdHJpbmcgPSB0aGlzLnJlbW92ZUVtcHR5KHRoaXMudG9rZW5pemUob2xkU3RyaW5nKSk7XG4gICAgICBuZXdTdHJpbmcgPSB0aGlzLnJlbW92ZUVtcHR5KHRoaXMudG9rZW5pemUobmV3U3RyaW5nKSk7XG4gICAgICB2YXIgbmV3TGVuID0gbmV3U3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoO1xuICAgICAgdmFyIGVkaXRMZW5ndGggPSAxO1xuICAgICAgdmFyIG1heEVkaXRMZW5ndGggPSBuZXdMZW4gKyBvbGRMZW47XG4gICAgICB2YXIgYmVzdFBhdGggPSBbe1xuICAgICAgICBuZXdQb3M6IC0xLFxuICAgICAgICBjb21wb25lbnRzOiBbXVxuICAgICAgfV07IC8vIFNlZWQgZWRpdExlbmd0aCA9IDAsIGkuZS4gdGhlIGNvbnRlbnQgc3RhcnRzIHdpdGggdGhlIHNhbWUgdmFsdWVzXG5cbiAgICAgIHZhciBvbGRQb3MgPSB0aGlzLmV4dHJhY3RDb21tb24oYmVzdFBhdGhbMF0sIG5ld1N0cmluZywgb2xkU3RyaW5nLCAwKTtcblxuICAgICAgaWYgKGJlc3RQYXRoWzBdLm5ld1BvcyArIDEgPj0gbmV3TGVuICYmIG9sZFBvcyArIDEgPj0gb2xkTGVuKSB7XG4gICAgICAgIC8vIElkZW50aXR5IHBlciB0aGUgZXF1YWxpdHkgYW5kIHRva2VuaXplclxuICAgICAgICByZXR1cm4gZG9uZShbe1xuICAgICAgICAgIHZhbHVlOiB0aGlzLmpvaW4obmV3U3RyaW5nKSxcbiAgICAgICAgICBjb3VudDogbmV3U3RyaW5nLmxlbmd0aFxuICAgICAgICB9XSk7XG4gICAgICB9IC8vIE1haW4gd29ya2VyIG1ldGhvZC4gY2hlY2tzIGFsbCBwZXJtdXRhdGlvbnMgb2YgYSBnaXZlbiBlZGl0IGxlbmd0aCBmb3IgYWNjZXB0YW5jZS5cblxuXG4gICAgICBmdW5jdGlvbiBleGVjRWRpdExlbmd0aCgpIHtcbiAgICAgICAgZm9yICh2YXIgZGlhZ29uYWxQYXRoID0gLTEgKiBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGggPD0gZWRpdExlbmd0aDsgZGlhZ29uYWxQYXRoICs9IDIpIHtcbiAgICAgICAgICB2YXIgYmFzZVBhdGggPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgYWRkUGF0aCA9IGJlc3RQYXRoW2RpYWdvbmFsUGF0aCAtIDFdLFxuICAgICAgICAgICAgICByZW1vdmVQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoICsgMV0sXG4gICAgICAgICAgICAgIF9vbGRQb3MgPSAocmVtb3ZlUGF0aCA/IHJlbW92ZVBhdGgubmV3UG9zIDogMCkgLSBkaWFnb25hbFBhdGg7XG5cbiAgICAgICAgICBpZiAoYWRkUGF0aCkge1xuICAgICAgICAgICAgLy8gTm8gb25lIGVsc2UgaXMgZ29pbmcgdG8gYXR0ZW1wdCB0byB1c2UgdGhpcyB2YWx1ZSwgY2xlYXIgaXRcbiAgICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aCAtIDFdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjYW5BZGQgPSBhZGRQYXRoICYmIGFkZFBhdGgubmV3UG9zICsgMSA8IG5ld0xlbixcbiAgICAgICAgICAgICAgY2FuUmVtb3ZlID0gcmVtb3ZlUGF0aCAmJiAwIDw9IF9vbGRQb3MgJiYgX29sZFBvcyA8IG9sZExlbjtcblxuICAgICAgICAgIGlmICghY2FuQWRkICYmICFjYW5SZW1vdmUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgcGF0aCBpcyBhIHRlcm1pbmFsIHRoZW4gcHJ1bmVcbiAgICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IC8vIFNlbGVjdCB0aGUgZGlhZ29uYWwgdGhhdCB3ZSB3YW50IHRvIGJyYW5jaCBmcm9tLiBXZSBzZWxlY3QgdGhlIHByaW9yXG4gICAgICAgICAgLy8gcGF0aCB3aG9zZSBwb3NpdGlvbiBpbiB0aGUgbmV3IHN0cmluZyBpcyB0aGUgZmFydGhlc3QgZnJvbSB0aGUgb3JpZ2luXG4gICAgICAgICAgLy8gYW5kIGRvZXMgbm90IHBhc3MgdGhlIGJvdW5kcyBvZiB0aGUgZGlmZiBncmFwaFxuXG5cbiAgICAgICAgICBpZiAoIWNhbkFkZCB8fCBjYW5SZW1vdmUgJiYgYWRkUGF0aC5uZXdQb3MgPCByZW1vdmVQYXRoLm5ld1Bvcykge1xuICAgICAgICAgICAgYmFzZVBhdGggPSBjbG9uZVBhdGgocmVtb3ZlUGF0aCk7XG4gICAgICAgICAgICBzZWxmLnB1c2hDb21wb25lbnQoYmFzZVBhdGguY29tcG9uZW50cywgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZVBhdGggPSBhZGRQYXRoOyAvLyBObyBuZWVkIHRvIGNsb25lLCB3ZSd2ZSBwdWxsZWQgaXQgZnJvbSB0aGUgbGlzdFxuXG4gICAgICAgICAgICBiYXNlUGF0aC5uZXdQb3MrKztcbiAgICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB0cnVlLCB1bmRlZmluZWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9vbGRQb3MgPSBzZWxmLmV4dHJhY3RDb21tb24oYmFzZVBhdGgsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBkaWFnb25hbFBhdGgpOyAvLyBJZiB3ZSBoYXZlIGhpdCB0aGUgZW5kIG9mIGJvdGggc3RyaW5ncywgdGhlbiB3ZSBhcmUgZG9uZVxuXG4gICAgICAgICAgaWYgKGJhc2VQYXRoLm5ld1BvcyArIDEgPj0gbmV3TGVuICYmIF9vbGRQb3MgKyAxID49IG9sZExlbikge1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUoYnVpbGRWYWx1ZXMoc2VsZiwgYmFzZVBhdGguY29tcG9uZW50cywgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIHNlbGYudXNlTG9uZ2VzdFRva2VuKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0cmFjayB0aGlzIHBhdGggYXMgYSBwb3RlbnRpYWwgY2FuZGlkYXRlIGFuZCBjb250aW51ZS5cbiAgICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSBiYXNlUGF0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlZGl0TGVuZ3RoKys7XG4gICAgICB9IC8vIFBlcmZvcm1zIHRoZSBsZW5ndGggb2YgZWRpdCBpdGVyYXRpb24uIElzIGEgYml0IGZ1Z2x5IGFzIHRoaXMgaGFzIHRvIHN1cHBvcnQgdGhlXG4gICAgICAvLyBzeW5jIGFuZCBhc3luYyBtb2RlIHdoaWNoIGlzIG5ldmVyIGZ1bi4gTG9vcHMgb3ZlciBleGVjRWRpdExlbmd0aCB1bnRpbCBhIHZhbHVlXG4gICAgICAvLyBpcyBwcm9kdWNlZC5cblxuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgKGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBidXQgd2Ugd2FudCB0byBiZSBzYWZlLlxuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKGVkaXRMZW5ndGggPiBtYXhFZGl0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWV4ZWNFZGl0TGVuZ3RoKCkpIHtcbiAgICAgICAgICAgICAgZXhlYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9KSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKGVkaXRMZW5ndGggPD0gbWF4RWRpdExlbmd0aCkge1xuICAgICAgICAgIHZhciByZXQgPSBleGVjRWRpdExlbmd0aCgpO1xuXG4gICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHB1c2hDb21wb25lbnQ6IGZ1bmN0aW9uIHB1c2hDb21wb25lbnQoY29tcG9uZW50cywgYWRkZWQsIHJlbW92ZWQpIHtcbiAgICAgIHZhciBsYXN0ID0gY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAobGFzdCAmJiBsYXN0LmFkZGVkID09PSBhZGRlZCAmJiBsYXN0LnJlbW92ZWQgPT09IHJlbW92ZWQpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBjbG9uZSBoZXJlIGFzIHRoZSBjb21wb25lbnQgY2xvbmUgb3BlcmF0aW9uIGlzIGp1c3RcbiAgICAgICAgLy8gYXMgc2hhbGxvdyBhcnJheSBjbG9uZVxuICAgICAgICBjb21wb25lbnRzW2NvbXBvbmVudHMubGVuZ3RoIC0gMV0gPSB7XG4gICAgICAgICAgY291bnQ6IGxhc3QuY291bnQgKyAxLFxuICAgICAgICAgIGFkZGVkOiBhZGRlZCxcbiAgICAgICAgICByZW1vdmVkOiByZW1vdmVkXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goe1xuICAgICAgICAgIGNvdW50OiAxLFxuICAgICAgICAgIGFkZGVkOiBhZGRlZCxcbiAgICAgICAgICByZW1vdmVkOiByZW1vdmVkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXh0cmFjdENvbW1vbjogZnVuY3Rpb24gZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCkge1xuICAgICAgdmFyIG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsXG4gICAgICAgICAgb2xkTGVuID0gb2xkU3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICBuZXdQb3MgPSBiYXNlUGF0aC5uZXdQb3MsXG4gICAgICAgICAgb2xkUG9zID0gbmV3UG9zIC0gZGlhZ29uYWxQYXRoLFxuICAgICAgICAgIGNvbW1vbkNvdW50ID0gMDtcblxuICAgICAgd2hpbGUgKG5ld1BvcyArIDEgPCBuZXdMZW4gJiYgb2xkUG9zICsgMSA8IG9sZExlbiAmJiB0aGlzLmVxdWFscyhuZXdTdHJpbmdbbmV3UG9zICsgMV0sIG9sZFN0cmluZ1tvbGRQb3MgKyAxXSkpIHtcbiAgICAgICAgbmV3UG9zKys7XG4gICAgICAgIG9sZFBvcysrO1xuICAgICAgICBjb21tb25Db3VudCsrO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tbW9uQ291bnQpIHtcbiAgICAgICAgYmFzZVBhdGguY29tcG9uZW50cy5wdXNoKHtcbiAgICAgICAgICBjb3VudDogY29tbW9uQ291bnRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGJhc2VQYXRoLm5ld1BvcyA9IG5ld1BvcztcbiAgICAgIHJldHVybiBvbGRQb3M7XG4gICAgfSxcbiAgICBlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb21wYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY29tcGFyYXRvcihsZWZ0LCByaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgfHwgdGhpcy5vcHRpb25zLmlnbm9yZUNhc2UgJiYgbGVmdC50b0xvd2VyQ2FzZSgpID09PSByaWdodC50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlRW1wdHk6IGZ1bmN0aW9uIHJlbW92ZUVtcHR5KGFycmF5KSB7XG4gICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycmF5W2ldKSB7XG4gICAgICAgICAgcmV0LnB1c2goYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcbiAgICBjYXN0SW5wdXQ6IGZ1bmN0aW9uIGNhc3RJbnB1dCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgdG9rZW5pemU6IGZ1bmN0aW9uIHRva2VuaXplKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUuc3BsaXQoJycpO1xuICAgIH0sXG4gICAgam9pbjogZnVuY3Rpb24gam9pbihjaGFycykge1xuICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBidWlsZFZhbHVlcyhkaWZmLCBjb21wb25lbnRzLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgdXNlTG9uZ2VzdFRva2VuKSB7XG4gICAgdmFyIGNvbXBvbmVudFBvcyA9IDAsXG4gICAgICAgIGNvbXBvbmVudExlbiA9IGNvbXBvbmVudHMubGVuZ3RoLFxuICAgICAgICBuZXdQb3MgPSAwLFxuICAgICAgICBvbGRQb3MgPSAwO1xuXG4gICAgZm9yICg7IGNvbXBvbmVudFBvcyA8IGNvbXBvbmVudExlbjsgY29tcG9uZW50UG9zKyspIHtcbiAgICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XG5cbiAgICAgIGlmICghY29tcG9uZW50LnJlbW92ZWQpIHtcbiAgICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQgJiYgdXNlTG9uZ2VzdFRva2VuKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbmV3U3RyaW5nLnNsaWNlKG5ld1BvcywgbmV3UG9zICsgY29tcG9uZW50LmNvdW50KTtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IG9sZFN0cmluZ1tvbGRQb3MgKyBpXTtcbiAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZS5sZW5ndGggPiB2YWx1ZS5sZW5ndGggPyBvbGRWYWx1ZSA6IHZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbih2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3UG9zICs9IGNvbXBvbmVudC5jb3VudDsgLy8gQ29tbW9uIGNhc2VcblxuICAgICAgICBpZiAoIWNvbXBvbmVudC5hZGRlZCkge1xuICAgICAgICAgIG9sZFBvcyArPSBjb21wb25lbnQuY291bnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbihvbGRTdHJpbmcuc2xpY2Uob2xkUG9zLCBvbGRQb3MgKyBjb21wb25lbnQuY291bnQpKTtcbiAgICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDsgLy8gUmV2ZXJzZSBhZGQgYW5kIHJlbW92ZSBzbyByZW1vdmVzIGFyZSBvdXRwdXQgZmlyc3QgdG8gbWF0Y2ggY29tbW9uIGNvbnZlbnRpb25cbiAgICAgICAgLy8gVGhlIGRpZmZpbmcgYWxnb3JpdGhtIGlzIHRpZWQgdG8gYWRkIHRoZW4gcmVtb3ZlIG91dHB1dCBhbmQgdGhpcyBpcyB0aGUgc2ltcGxlc3RcbiAgICAgICAgLy8gcm91dGUgdG8gZ2V0IHRoZSBkZXNpcmVkIG91dHB1dCB3aXRoIG1pbmltYWwgb3ZlcmhlYWQuXG5cbiAgICAgICAgaWYgKGNvbXBvbmVudFBvcyAmJiBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdLmFkZGVkKSB7XG4gICAgICAgICAgdmFyIHRtcCA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV07XG4gICAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXSA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcbiAgICAgICAgICBjb21wb25lbnRzW2NvbXBvbmVudFBvc10gPSB0bXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFNwZWNpYWwgY2FzZSBoYW5kbGUgZm9yIHdoZW4gb25lIHRlcm1pbmFsIGlzIGlnbm9yZWQgKGkuZS4gd2hpdGVzcGFjZSkuXG4gICAgLy8gRm9yIHRoaXMgY2FzZSB3ZSBtZXJnZSB0aGUgdGVybWluYWwgaW50byB0aGUgcHJpb3Igc3RyaW5nIGFuZCBkcm9wIHRoZSBjaGFuZ2UuXG4gICAgLy8gVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBmb3Igc3RyaW5nIG1vZGUuXG5cblxuICAgIHZhciBsYXN0Q29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnRMZW4gLSAxXTtcblxuICAgIGlmIChjb21wb25lbnRMZW4gPiAxICYmIHR5cGVvZiBsYXN0Q29tcG9uZW50LnZhbHVlID09PSAnc3RyaW5nJyAmJiAobGFzdENvbXBvbmVudC5hZGRlZCB8fCBsYXN0Q29tcG9uZW50LnJlbW92ZWQpICYmIGRpZmYuZXF1YWxzKCcnLCBsYXN0Q29tcG9uZW50LnZhbHVlKSkge1xuICAgICAgY29tcG9uZW50c1tjb21wb25lbnRMZW4gLSAyXS52YWx1ZSArPSBsYXN0Q29tcG9uZW50LnZhbHVlO1xuICAgICAgY29tcG9uZW50cy5wb3AoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcG9uZW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5ld1BvczogcGF0aC5uZXdQb3MsXG4gICAgICBjb21wb25lbnRzOiBwYXRoLmNvbXBvbmVudHMuc2xpY2UoMClcbiAgICB9O1xuICB9XG5cbiAgdmFyIGNoYXJhY3RlckRpZmYgPSBuZXcgRGlmZigpO1xuICBmdW5jdGlvbiBkaWZmQ2hhcnMob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlT3B0aW9ucyhvcHRpb25zLCBkZWZhdWx0cykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGVmYXVsdHMuY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucykge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgZGVmYXVsdHNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRzO1xuICB9XG5cbiAgLy9cbiAgLy8gUmFuZ2VzIGFuZCBleGNlcHRpb25zOlxuICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQsIDAwODDigJMwMEZGXG4gIC8vICAtIFUrMDBENyAgw5cgTXVsdGlwbGljYXRpb24gc2lnblxuICAvLyAgLSBVKzAwRjcgIMO3IERpdmlzaW9uIHNpZ25cbiAgLy8gTGF0aW4gRXh0ZW5kZWQtQSwgMDEwMOKAkzAxN0ZcbiAgLy8gTGF0aW4gRXh0ZW5kZWQtQiwgMDE4MOKAkzAyNEZcbiAgLy8gSVBBIEV4dGVuc2lvbnMsIDAyNTDigJMwMkFGXG4gIC8vIFNwYWNpbmcgTW9kaWZpZXIgTGV0dGVycywgMDJCMOKAkzAyRkZcbiAgLy8gIC0gVSswMkM3ICDLhyAmIzcxMTsgIENhcm9uXG4gIC8vICAtIFUrMDJEOCAgy5ggJiM3Mjg7ICBCcmV2ZVxuICAvLyAgLSBVKzAyRDkgIMuZICYjNzI5OyAgRG90IEFib3ZlXG4gIC8vICAtIFUrMDJEQSAgy5ogJiM3MzA7ICBSaW5nIEFib3ZlXG4gIC8vICAtIFUrMDJEQiAgy5sgJiM3MzE7ICBPZ29uZWtcbiAgLy8gIC0gVSswMkRDICDLnCAmIzczMjsgIFNtYWxsIFRpbGRlXG4gIC8vICAtIFUrMDJERCAgy50gJiM3MzM7ICBEb3VibGUgQWN1dGUgQWNjZW50XG4gIC8vIExhdGluIEV4dGVuZGVkIEFkZGl0aW9uYWwsIDFFMDDigJMxRUZGXG5cbiAgdmFyIGV4dGVuZGVkV29yZENoYXJzID0gL15bQS1aYS16XFx4QzAtXFx1MDJDNlxcdTAyQzgtXFx1MDJEN1xcdTAyREUtXFx1MDJGRlxcdTFFMDAtXFx1MUVGRl0rJC87XG4gIHZhciByZVdoaXRlc3BhY2UgPSAvXFxTLztcbiAgdmFyIHdvcmREaWZmID0gbmV3IERpZmYoKTtcblxuICB3b3JkRGlmZi5lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZUNhc2UpIHtcbiAgICAgIGxlZnQgPSBsZWZ0LnRvTG93ZXJDYXNlKCk7XG4gICAgICByaWdodCA9IHJpZ2h0LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8IHRoaXMub3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlICYmICFyZVdoaXRlc3BhY2UudGVzdChsZWZ0KSAmJiAhcmVXaGl0ZXNwYWNlLnRlc3QocmlnaHQpO1xuICB9O1xuXG4gIHdvcmREaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gQWxsIHdoaXRlc3BhY2Ugc3ltYm9scyBleGNlcHQgbmV3bGluZSBncm91cCBpbnRvIG9uZSB0b2tlbiwgZWFjaCBuZXdsaW5lIC0gaW4gc2VwYXJhdGUgdG9rZW5cbiAgICB2YXIgdG9rZW5zID0gdmFsdWUuc3BsaXQoLyhbXlxcU1xcclxcbl0rfFsoKVtcXF17fSdcIlxcclxcbl18XFxiKS8pOyAvLyBKb2luIHRoZSBib3VuZGFyeSBzcGxpdHMgdGhhdCB3ZSBkbyBub3QgY29uc2lkZXIgdG8gYmUgYm91bmRhcmllcy4gVGhpcyBpcyBwcmltYXJpbHkgdGhlIGV4dGVuZGVkIExhdGluIGNoYXJhY3RlciBzZXQuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgYW4gZW1wdHkgc3RyaW5nIGluIHRoZSBuZXh0IGZpZWxkIGFuZCB3ZSBoYXZlIG9ubHkgd29yZCBjaGFycyBiZWZvcmUgYW5kIGFmdGVyLCBtZXJnZVxuICAgICAgaWYgKCF0b2tlbnNbaSArIDFdICYmIHRva2Vuc1tpICsgMl0gJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaV0pICYmIGV4dGVuZGVkV29yZENoYXJzLnRlc3QodG9rZW5zW2kgKyAyXSkpIHtcbiAgICAgICAgdG9rZW5zW2ldICs9IHRva2Vuc1tpICsgMl07XG4gICAgICAgIHRva2Vucy5zcGxpY2UoaSArIDEsIDIpO1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRva2VucztcbiAgfTtcblxuICBmdW5jdGlvbiBkaWZmV29yZHMob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZ2VuZXJhdGVPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIGlnbm9yZVdoaXRlc3BhY2U6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gd29yZERpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG4gIH1cbiAgZnVuY3Rpb24gZGlmZldvcmRzV2l0aFNwYWNlKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHdvcmREaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIGxpbmVEaWZmID0gbmV3IERpZmYoKTtcblxuICBsaW5lRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciByZXRMaW5lcyA9IFtdLFxuICAgICAgICBsaW5lc0FuZE5ld2xpbmVzID0gdmFsdWUuc3BsaXQoLyhcXG58XFxyXFxuKS8pOyAvLyBJZ25vcmUgdGhlIGZpbmFsIGVtcHR5IHRva2VuIHRoYXQgb2NjdXJzIGlmIHRoZSBzdHJpbmcgZW5kcyB3aXRoIGEgbmV3IGxpbmVcblxuICAgIGlmICghbGluZXNBbmROZXdsaW5lc1tsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aCAtIDFdKSB7XG4gICAgICBsaW5lc0FuZE5ld2xpbmVzLnBvcCgpO1xuICAgIH0gLy8gTWVyZ2UgdGhlIGNvbnRlbnQgYW5kIGxpbmUgc2VwYXJhdG9ycyBpbnRvIHNpbmdsZSB0b2tlbnNcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGluZSA9IGxpbmVzQW5kTmV3bGluZXNbaV07XG5cbiAgICAgIGlmIChpICUgMiAmJiAhdGhpcy5vcHRpb25zLm5ld2xpbmVJc1Rva2VuKSB7XG4gICAgICAgIHJldExpbmVzW3JldExpbmVzLmxlbmd0aCAtIDFdICs9IGxpbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UpIHtcbiAgICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXRMaW5lcztcbiAgfTtcblxuICBmdW5jdGlvbiBkaWZmTGluZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGxpbmVEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTtcbiAgfVxuICBmdW5jdGlvbiBkaWZmVHJpbW1lZExpbmVzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICAgIHZhciBvcHRpb25zID0gZ2VuZXJhdGVPcHRpb25zKGNhbGxiYWNrLCB7XG4gICAgICBpZ25vcmVXaGl0ZXNwYWNlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGxpbmVEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHNlbnRlbmNlRGlmZiA9IG5ldyBEaWZmKCk7XG5cbiAgc2VudGVuY2VEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KC8oXFxTLis/Wy4hP10pKD89XFxzK3wkKS8pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGRpZmZTZW50ZW5jZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHNlbnRlbmNlRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgY3NzRGlmZiA9IG5ldyBEaWZmKCk7XG5cbiAgY3NzRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5zcGxpdCgvKFt7fTo7LF18XFxzKykvKTtcbiAgfTtcblxuICBmdW5jdGlvbiBkaWZmQ3NzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBjc3NEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIHZhciBvYmplY3RQcm90b3R5cGVUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciBqc29uRGlmZiA9IG5ldyBEaWZmKCk7IC8vIERpc2NyaW1pbmF0ZSBiZXR3ZWVuIHR3byBsaW5lcyBvZiBwcmV0dHktcHJpbnRlZCwgc2VyaWFsaXplZCBKU09OIHdoZXJlIG9uZSBvZiB0aGVtIGhhcyBhXG4gIC8vIGRhbmdsaW5nIGNvbW1hIGFuZCB0aGUgb3RoZXIgZG9lc24ndC4gVHVybnMgb3V0IGluY2x1ZGluZyB0aGUgZGFuZ2xpbmcgY29tbWEgeWllbGRzIHRoZSBuaWNlc3Qgb3V0cHV0OlxuXG4gIGpzb25EaWZmLnVzZUxvbmdlc3RUb2tlbiA9IHRydWU7XG4gIGpzb25EaWZmLnRva2VuaXplID0gbGluZURpZmYudG9rZW5pemU7XG5cbiAganNvbkRpZmYuY2FzdElucHV0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHVuZGVmaW5lZFJlcGxhY2VtZW50ID0gX3RoaXMkb3B0aW9ucy51bmRlZmluZWRSZXBsYWNlbWVudCxcbiAgICAgICAgX3RoaXMkb3B0aW9ucyRzdHJpbmdpID0gX3RoaXMkb3B0aW9ucy5zdHJpbmdpZnlSZXBsYWNlcixcbiAgICAgICAgc3RyaW5naWZ5UmVwbGFjZXIgPSBfdGhpcyRvcHRpb25zJHN0cmluZ2kgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkUmVwbGFjZW1lbnQgOiB2O1xuICAgIH0gOiBfdGhpcyRvcHRpb25zJHN0cmluZ2k7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KGNhbm9uaWNhbGl6ZSh2YWx1ZSwgbnVsbCwgbnVsbCwgc3RyaW5naWZ5UmVwbGFjZXIpLCBzdHJpbmdpZnlSZXBsYWNlciwgJyAgJyk7XG4gIH07XG5cbiAganNvbkRpZmYuZXF1YWxzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIERpZmYucHJvdG90eXBlLmVxdWFscy5jYWxsKGpzb25EaWZmLCBsZWZ0LnJlcGxhY2UoLywoW1xcclxcbl0pL2csICckMScpLCByaWdodC5yZXBsYWNlKC8sKFtcXHJcXG5dKS9nLCAnJDEnKSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gZGlmZkpzb24ob2xkT2JqLCBuZXdPYmosIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ganNvbkRpZmYuZGlmZihvbGRPYmosIG5ld09iaiwgb3B0aW9ucyk7XG4gIH0gLy8gVGhpcyBmdW5jdGlvbiBoYW5kbGVzIHRoZSBwcmVzZW5jZSBvZiBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IGJhaWxpbmcgb3V0IHdoZW4gZW5jb3VudGVyaW5nIGFuXG4gIC8vIG9iamVjdCB0aGF0IGlzIGFscmVhZHkgb24gdGhlIFwic3RhY2tcIiBvZiBpdGVtcyBiZWluZyBwcm9jZXNzZWQuIEFjY2VwdHMgYW4gb3B0aW9uYWwgcmVwbGFjZXJcblxuICBmdW5jdGlvbiBjYW5vbmljYWxpemUob2JqLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjaywgcmVwbGFjZXIsIGtleSkge1xuICAgIHN0YWNrID0gc3RhY2sgfHwgW107XG4gICAgcmVwbGFjZW1lbnRTdGFjayA9IHJlcGxhY2VtZW50U3RhY2sgfHwgW107XG5cbiAgICBpZiAocmVwbGFjZXIpIHtcbiAgICAgIG9iaiA9IHJlcGxhY2VyKGtleSwgb2JqKTtcbiAgICB9XG5cbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHN0YWNrW2ldID09PSBvYmopIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50U3RhY2tbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNhbm9uaWNhbGl6ZWRPYmo7XG5cbiAgICBpZiAoJ1tvYmplY3QgQXJyYXldJyA9PT0gb2JqZWN0UHJvdG90eXBlVG9TdHJpbmcuY2FsbChvYmopKSB7XG4gICAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgICBjYW5vbmljYWxpemVkT2JqID0gbmV3IEFycmF5KG9iai5sZW5ndGgpO1xuICAgICAgcmVwbGFjZW1lbnRTdGFjay5wdXNoKGNhbm9uaWNhbGl6ZWRPYmopO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmpbaV0gPSBjYW5vbmljYWxpemUob2JqW2ldLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjaywgcmVwbGFjZXIsIGtleSk7XG4gICAgICB9XG5cbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgcmVwbGFjZW1lbnRTdGFjay5wb3AoKTtcbiAgICAgIHJldHVybiBjYW5vbmljYWxpemVkT2JqO1xuICAgIH1cblxuICAgIGlmIChvYmogJiYgb2JqLnRvSlNPTikge1xuICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgIH1cblxuICAgIGlmIChfdHlwZW9mKG9iaikgPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xuICAgICAgc3RhY2sucHVzaChvYmopO1xuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IHt9O1xuICAgICAgcmVwbGFjZW1lbnRTdGFjay5wdXNoKGNhbm9uaWNhbGl6ZWRPYmopO1xuXG4gICAgICB2YXIgc29ydGVkS2V5cyA9IFtdLFxuICAgICAgICAgIF9rZXk7XG5cbiAgICAgIGZvciAoX2tleSBpbiBvYmopIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShfa2V5KSkge1xuICAgICAgICAgIHNvcnRlZEtleXMucHVzaChfa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzb3J0ZWRLZXlzLnNvcnQoKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHNvcnRlZEtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgX2tleSA9IHNvcnRlZEtleXNbaV07XG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmpbX2tleV0gPSBjYW5vbmljYWxpemUob2JqW19rZXldLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjaywgcmVwbGFjZXIsIF9rZXkpO1xuICAgICAgfVxuXG4gICAgICBzdGFjay5wb3AoKTtcbiAgICAgIHJlcGxhY2VtZW50U3RhY2sucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XG4gIH1cblxuICB2YXIgYXJyYXlEaWZmID0gbmV3IERpZmYoKTtcblxuICBhcnJheURpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbiAgfTtcblxuICBhcnJheURpZmYuam9pbiA9IGFycmF5RGlmZi5yZW1vdmVFbXB0eSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBmdW5jdGlvbiBkaWZmQXJyYXlzKG9sZEFyciwgbmV3QXJyLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBhcnJheURpZmYuZGlmZihvbGRBcnIsIG5ld0FyciwgY2FsbGJhY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQYXRjaCh1bmlEaWZmKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBkaWZmc3RyID0gdW5pRGlmZi5zcGxpdCgvXFxyXFxufFtcXG5cXHZcXGZcXHJcXHg4NV0vKSxcbiAgICAgICAgZGVsaW1pdGVycyA9IHVuaURpZmYubWF0Y2goL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdL2cpIHx8IFtdLFxuICAgICAgICBsaXN0ID0gW10sXG4gICAgICAgIGkgPSAwO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJbmRleCgpIHtcbiAgICAgIHZhciBpbmRleCA9IHt9O1xuICAgICAgbGlzdC5wdXNoKGluZGV4KTsgLy8gUGFyc2UgZGlmZiBtZXRhZGF0YVxuXG4gICAgICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XG4gICAgICAgIHZhciBsaW5lID0gZGlmZnN0cltpXTsgLy8gRmlsZSBoZWFkZXIgZm91bmQsIGVuZCBwYXJzaW5nIGRpZmYgbWV0YWRhdGFcblxuICAgICAgICBpZiAoL14oXFwtXFwtXFwtfFxcK1xcK1xcK3xAQClcXHMvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBEaWZmIGluZGV4XG5cblxuICAgICAgICB2YXIgaGVhZGVyID0gL14oPzpJbmRleDp8ZGlmZig/OiAtciBcXHcrKSspXFxzKyguKz8pXFxzKiQvLmV4ZWMobGluZSk7XG5cbiAgICAgICAgaWYgKGhlYWRlcikge1xuICAgICAgICAgIGluZGV4LmluZGV4ID0gaGVhZGVyWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaSsrO1xuICAgICAgfSAvLyBQYXJzZSBmaWxlIGhlYWRlcnMgaWYgdGhleSBhcmUgZGVmaW5lZC4gVW5pZmllZCBkaWZmIHJlcXVpcmVzIHRoZW0sIGJ1dFxuICAgICAgLy8gdGhlcmUncyBubyB0ZWNobmljYWwgaXNzdWVzIHRvIGhhdmUgYW4gaXNvbGF0ZWQgaHVuayB3aXRob3V0IGZpbGUgaGVhZGVyXG5cblxuICAgICAgcGFyc2VGaWxlSGVhZGVyKGluZGV4KTtcbiAgICAgIHBhcnNlRmlsZUhlYWRlcihpbmRleCk7IC8vIFBhcnNlIGh1bmtzXG5cbiAgICAgIGluZGV4Lmh1bmtzID0gW107XG5cbiAgICAgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIF9saW5lID0gZGlmZnN0cltpXTtcblxuICAgICAgICBpZiAoL14oSW5kZXg6fGRpZmZ8XFwtXFwtXFwtfFxcK1xcK1xcKylcXHMvLnRlc3QoX2xpbmUpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoL15AQC8udGVzdChfbGluZSkpIHtcbiAgICAgICAgICBpbmRleC5odW5rcy5wdXNoKHBhcnNlSHVuaygpKTtcbiAgICAgICAgfSBlbHNlIGlmIChfbGluZSAmJiBvcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgIC8vIElnbm9yZSB1bmV4cGVjdGVkIGNvbnRlbnQgdW5sZXNzIGluIHN0cmljdCBtb2RlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxpbmUgJyArIChpICsgMSkgKyAnICcgKyBKU09OLnN0cmluZ2lmeShfbGluZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gUGFyc2VzIHRoZSAtLS0gYW5kICsrKyBoZWFkZXJzLCBpZiBub25lIGFyZSBmb3VuZCwgbm8gbGluZXNcbiAgICAvLyBhcmUgY29uc3VtZWQuXG5cblxuICAgIGZ1bmN0aW9uIHBhcnNlRmlsZUhlYWRlcihpbmRleCkge1xuICAgICAgdmFyIGZpbGVIZWFkZXIgPSAvXigtLS18XFwrXFwrXFwrKVxccysoLiopJC8uZXhlYyhkaWZmc3RyW2ldKTtcblxuICAgICAgaWYgKGZpbGVIZWFkZXIpIHtcbiAgICAgICAgdmFyIGtleVByZWZpeCA9IGZpbGVIZWFkZXJbMV0gPT09ICctLS0nID8gJ29sZCcgOiAnbmV3JztcbiAgICAgICAgdmFyIGRhdGEgPSBmaWxlSGVhZGVyWzJdLnNwbGl0KCdcXHQnLCAyKTtcbiAgICAgICAgdmFyIGZpbGVOYW1lID0gZGF0YVswXS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xuXG4gICAgICAgIGlmICgvXlwiLipcIiQvLnRlc3QoZmlsZU5hbWUpKSB7XG4gICAgICAgICAgZmlsZU5hbWUgPSBmaWxlTmFtZS5zdWJzdHIoMSwgZmlsZU5hbWUubGVuZ3RoIC0gMik7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleFtrZXlQcmVmaXggKyAnRmlsZU5hbWUnXSA9IGZpbGVOYW1lO1xuICAgICAgICBpbmRleFtrZXlQcmVmaXggKyAnSGVhZGVyJ10gPSAoZGF0YVsxXSB8fCAnJykudHJpbSgpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSAvLyBQYXJzZXMgYSBodW5rXG4gICAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgd2UgYXJlIGF0IHRoZSBzdGFydCBvZiBhIGh1bmsuXG5cblxuICAgIGZ1bmN0aW9uIHBhcnNlSHVuaygpIHtcbiAgICAgIHZhciBjaHVua0hlYWRlckluZGV4ID0gaSxcbiAgICAgICAgICBjaHVua0hlYWRlckxpbmUgPSBkaWZmc3RyW2krK10sXG4gICAgICAgICAgY2h1bmtIZWFkZXIgPSBjaHVua0hlYWRlckxpbmUuc3BsaXQoL0BAIC0oXFxkKykoPzosKFxcZCspKT8gXFwrKFxcZCspKD86LChcXGQrKSk/IEBALyk7XG4gICAgICB2YXIgaHVuayA9IHtcbiAgICAgICAgb2xkU3RhcnQ6ICtjaHVua0hlYWRlclsxXSxcbiAgICAgICAgb2xkTGluZXM6IHR5cGVvZiBjaHVua0hlYWRlclsyXSA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogK2NodW5rSGVhZGVyWzJdLFxuICAgICAgICBuZXdTdGFydDogK2NodW5rSGVhZGVyWzNdLFxuICAgICAgICBuZXdMaW5lczogdHlwZW9mIGNodW5rSGVhZGVyWzRdID09PSAndW5kZWZpbmVkJyA/IDEgOiArY2h1bmtIZWFkZXJbNF0sXG4gICAgICAgIGxpbmVzOiBbXSxcbiAgICAgICAgbGluZWRlbGltaXRlcnM6IFtdXG4gICAgICB9OyAvLyBVbmlmaWVkIERpZmYgRm9ybWF0IHF1aXJrOiBJZiB0aGUgY2h1bmsgc2l6ZSBpcyAwLFxuICAgICAgLy8gdGhlIGZpcnN0IG51bWJlciBpcyBvbmUgbG93ZXIgdGhhbiBvbmUgd291bGQgZXhwZWN0LlxuICAgICAgLy8gaHR0cHM6Ly93d3cuYXJ0aW1hLmNvbS93ZWJsb2dzL3ZpZXdwb3N0LmpzcD90aHJlYWQ9MTY0MjkzXG5cbiAgICAgIGlmIChodW5rLm9sZExpbmVzID09PSAwKSB7XG4gICAgICAgIGh1bmsub2xkU3RhcnQgKz0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGh1bmsubmV3TGluZXMgPT09IDApIHtcbiAgICAgICAgaHVuay5uZXdTdGFydCArPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWRkQ291bnQgPSAwLFxuICAgICAgICAgIHJlbW92ZUNvdW50ID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBkaWZmc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggJy0tLScgY291bGQgYmUgbWlzdGFrZW4gZm9yIHRoZSBcInJlbW92ZSBsaW5lXCIgb3BlcmF0aW9uXG4gICAgICAgIC8vIEJ1dCB0aGV5IGNvdWxkIGJlIHRoZSBoZWFkZXIgZm9yIHRoZSBuZXh0IGZpbGUuIFRoZXJlZm9yZSBwcnVuZSBzdWNoIGNhc2VzIG91dC5cbiAgICAgICAgaWYgKGRpZmZzdHJbaV0uaW5kZXhPZignLS0tICcpID09PSAwICYmIGkgKyAyIDwgZGlmZnN0ci5sZW5ndGggJiYgZGlmZnN0cltpICsgMV0uaW5kZXhPZignKysrICcpID09PSAwICYmIGRpZmZzdHJbaSArIDJdLmluZGV4T2YoJ0BAJykgPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcGVyYXRpb24gPSBkaWZmc3RyW2ldLmxlbmd0aCA9PSAwICYmIGkgIT0gZGlmZnN0ci5sZW5ndGggLSAxID8gJyAnIDogZGlmZnN0cltpXVswXTtcblxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnKycgfHwgb3BlcmF0aW9uID09PSAnLScgfHwgb3BlcmF0aW9uID09PSAnICcgfHwgb3BlcmF0aW9uID09PSAnXFxcXCcpIHtcbiAgICAgICAgICBodW5rLmxpbmVzLnB1c2goZGlmZnN0cltpXSk7XG4gICAgICAgICAgaHVuay5saW5lZGVsaW1pdGVycy5wdXNoKGRlbGltaXRlcnNbaV0gfHwgJ1xcbicpO1xuXG4gICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJysnKSB7XG4gICAgICAgICAgICBhZGRDb3VudCsrO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgICAgIHJlbW92ZUNvdW50Kys7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICcgJykge1xuICAgICAgICAgICAgYWRkQ291bnQrKztcbiAgICAgICAgICAgIHJlbW92ZUNvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IC8vIEhhbmRsZSB0aGUgZW1wdHkgYmxvY2sgY291bnQgY2FzZVxuXG5cbiAgICAgIGlmICghYWRkQ291bnQgJiYgaHVuay5uZXdMaW5lcyA9PT0gMSkge1xuICAgICAgICBodW5rLm5ld0xpbmVzID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZW1vdmVDb3VudCAmJiBodW5rLm9sZExpbmVzID09PSAxKSB7XG4gICAgICAgIGh1bmsub2xkTGluZXMgPSAwO1xuICAgICAgfSAvLyBQZXJmb3JtIG9wdGlvbmFsIHNhbml0eSBjaGVja2luZ1xuXG5cbiAgICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xuICAgICAgICBpZiAoYWRkQ291bnQgIT09IGh1bmsubmV3TGluZXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkZGVkIGxpbmUgY291bnQgZGlkIG5vdCBtYXRjaCBmb3IgaHVuayBhdCBsaW5lICcgKyAoY2h1bmtIZWFkZXJJbmRleCArIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW1vdmVDb3VudCAhPT0gaHVuay5vbGRMaW5lcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVtb3ZlZCBsaW5lIGNvdW50IGRpZCBub3QgbWF0Y2ggZm9yIGh1bmsgYXQgbGluZSAnICsgKGNodW5rSGVhZGVySW5kZXggKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGh1bms7XG4gICAgfVxuXG4gICAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCkge1xuICAgICAgcGFyc2VJbmRleCgpO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgLy8gSXRlcmF0b3IgdGhhdCB0cmF2ZXJzZXMgaW4gdGhlIHJhbmdlIG9mIFttaW4sIG1heF0sIHN0ZXBwaW5nXG4gIC8vIGJ5IGRpc3RhbmNlIGZyb20gYSBnaXZlbiBzdGFydCBwb3NpdGlvbi4gSS5lLiBmb3IgWzAsIDRdLCB3aXRoXG4gIC8vIHN0YXJ0IG9mIDIsIHRoaXMgd2lsbCBpdGVyYXRlIDIsIDMsIDEsIDQsIDAuXG4gIGZ1bmN0aW9uIGRpc3RhbmNlSXRlcmF0b3IgKHN0YXJ0LCBtaW5MaW5lLCBtYXhMaW5lKSB7XG4gICAgdmFyIHdhbnRGb3J3YXJkID0gdHJ1ZSxcbiAgICAgICAgYmFja3dhcmRFeGhhdXN0ZWQgPSBmYWxzZSxcbiAgICAgICAgZm9yd2FyZEV4aGF1c3RlZCA9IGZhbHNlLFxuICAgICAgICBsb2NhbE9mZnNldCA9IDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgaWYgKHdhbnRGb3J3YXJkICYmICFmb3J3YXJkRXhoYXVzdGVkKSB7XG4gICAgICAgIGlmIChiYWNrd2FyZEV4aGF1c3RlZCkge1xuICAgICAgICAgIGxvY2FsT2Zmc2V0Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FudEZvcndhcmQgPSBmYWxzZTtcbiAgICAgICAgfSAvLyBDaGVjayBpZiB0cnlpbmcgdG8gZml0IGJleW9uZCB0ZXh0IGxlbmd0aCwgYW5kIGlmIG5vdCwgY2hlY2sgaXQgZml0c1xuICAgICAgICAvLyBhZnRlciBvZmZzZXQgbG9jYXRpb24gKG9yIGRlc2lyZWQgbG9jYXRpb24gb24gZmlyc3QgaXRlcmF0aW9uKVxuXG5cbiAgICAgICAgaWYgKHN0YXJ0ICsgbG9jYWxPZmZzZXQgPD0gbWF4TGluZSkge1xuICAgICAgICAgIHJldHVybiBsb2NhbE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcndhcmRFeGhhdXN0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWJhY2t3YXJkRXhoYXVzdGVkKSB7XG4gICAgICAgIGlmICghZm9yd2FyZEV4aGF1c3RlZCkge1xuICAgICAgICAgIHdhbnRGb3J3YXJkID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBDaGVjayBpZiB0cnlpbmcgdG8gZml0IGJlZm9yZSB0ZXh0IGJlZ2lubmluZywgYW5kIGlmIG5vdCwgY2hlY2sgaXQgZml0c1xuICAgICAgICAvLyBiZWZvcmUgb2Zmc2V0IGxvY2F0aW9uXG5cblxuICAgICAgICBpZiAobWluTGluZSA8PSBzdGFydCAtIGxvY2FsT2Zmc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIC1sb2NhbE9mZnNldCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFja3dhcmRFeGhhdXN0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3IoKTtcbiAgICAgIH0gLy8gV2UgdHJpZWQgdG8gZml0IGh1bmsgYmVmb3JlIHRleHQgYmVnaW5uaW5nIGFuZCBiZXlvbmQgdGV4dCBsZW5ndGgsIHRoZW5cbiAgICAgIC8vIGh1bmsgY2FuJ3QgZml0IG9uIHRoZSB0ZXh0LiBSZXR1cm4gdW5kZWZpbmVkXG5cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlQYXRjaChzb3VyY2UsIHVuaURpZmYpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICBpZiAodHlwZW9mIHVuaURpZmYgPT09ICdzdHJpbmcnKSB7XG4gICAgICB1bmlEaWZmID0gcGFyc2VQYXRjaCh1bmlEaWZmKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh1bmlEaWZmKSkge1xuICAgICAgaWYgKHVuaURpZmYubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FwcGx5UGF0Y2ggb25seSB3b3JrcyB3aXRoIGEgc2luZ2xlIGlucHV0LicpO1xuICAgICAgfVxuXG4gICAgICB1bmlEaWZmID0gdW5pRGlmZlswXTtcbiAgICB9IC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBpbnB1dFxuXG5cbiAgICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdLyksXG4gICAgICAgIGRlbGltaXRlcnMgPSBzb3VyY2UubWF0Y2goL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdL2cpIHx8IFtdLFxuICAgICAgICBodW5rcyA9IHVuaURpZmYuaHVua3MsXG4gICAgICAgIGNvbXBhcmVMaW5lID0gb3B0aW9ucy5jb21wYXJlTGluZSB8fCBmdW5jdGlvbiAobGluZU51bWJlciwgbGluZSwgb3BlcmF0aW9uLCBwYXRjaENvbnRlbnQpIHtcbiAgICAgIHJldHVybiBsaW5lID09PSBwYXRjaENvbnRlbnQ7XG4gICAgfSxcbiAgICAgICAgZXJyb3JDb3VudCA9IDAsXG4gICAgICAgIGZ1enpGYWN0b3IgPSBvcHRpb25zLmZ1enpGYWN0b3IgfHwgMCxcbiAgICAgICAgbWluTGluZSA9IDAsXG4gICAgICAgIG9mZnNldCA9IDAsXG4gICAgICAgIHJlbW92ZUVPRk5MLFxuICAgICAgICBhZGRFT0ZOTDtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGh1bmsgZXhhY3RseSBmaXRzIG9uIHRoZSBwcm92aWRlZCBsb2NhdGlvblxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBodW5rRml0cyhodW5rLCB0b1Bvcykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBodW5rLmxpbmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBsaW5lID0gaHVuay5saW5lc1tqXSxcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IGxpbmUubGVuZ3RoID4gMCA/IGxpbmVbMF0gOiAnICcsXG4gICAgICAgICAgICBjb250ZW50ID0gbGluZS5sZW5ndGggPiAwID8gbGluZS5zdWJzdHIoMSkgOiBsaW5lO1xuXG4gICAgICAgIGlmIChvcGVyYXRpb24gPT09ICcgJyB8fCBvcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICAgIC8vIENvbnRleHQgc2FuaXR5IGNoZWNrXG4gICAgICAgICAgaWYgKCFjb21wYXJlTGluZSh0b1BvcyArIDEsIGxpbmVzW3RvUG9zXSwgb3BlcmF0aW9uLCBjb250ZW50KSkge1xuICAgICAgICAgICAgZXJyb3JDb3VudCsrO1xuXG4gICAgICAgICAgICBpZiAoZXJyb3JDb3VudCA+IGZ1enpGYWN0b3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvUG9zKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBTZWFyY2ggYmVzdCBmaXQgb2Zmc2V0cyBmb3IgZWFjaCBodW5rIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBvbmVzXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBodW5rID0gaHVua3NbaV0sXG4gICAgICAgICAgbWF4TGluZSA9IGxpbmVzLmxlbmd0aCAtIGh1bmsub2xkTGluZXMsXG4gICAgICAgICAgbG9jYWxPZmZzZXQgPSAwLFxuICAgICAgICAgIHRvUG9zID0gb2Zmc2V0ICsgaHVuay5vbGRTdGFydCAtIDE7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBkaXN0YW5jZUl0ZXJhdG9yKHRvUG9zLCBtaW5MaW5lLCBtYXhMaW5lKTtcblxuICAgICAgZm9yICg7IGxvY2FsT2Zmc2V0ICE9PSB1bmRlZmluZWQ7IGxvY2FsT2Zmc2V0ID0gaXRlcmF0b3IoKSkge1xuICAgICAgICBpZiAoaHVua0ZpdHMoaHVuaywgdG9Qb3MgKyBsb2NhbE9mZnNldCkpIHtcbiAgICAgICAgICBodW5rLm9mZnNldCA9IG9mZnNldCArPSBsb2NhbE9mZnNldDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobG9jYWxPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIFNldCBsb3dlciB0ZXh0IGxpbWl0IHRvIGVuZCBvZiB0aGUgY3VycmVudCBodW5rLCBzbyBuZXh0IG9uZXMgZG9uJ3QgdHJ5XG4gICAgICAvLyB0byBmaXQgb3ZlciBhbHJlYWR5IHBhdGNoZWQgdGV4dFxuXG5cbiAgICAgIG1pbkxpbmUgPSBodW5rLm9mZnNldCArIGh1bmsub2xkU3RhcnQgKyBodW5rLm9sZExpbmVzO1xuICAgIH0gLy8gQXBwbHkgcGF0Y2ggaHVua3NcblxuXG4gICAgdmFyIGRpZmZPZmZzZXQgPSAwO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGh1bmtzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9odW5rID0gaHVua3NbX2ldLFxuICAgICAgICAgIF90b1BvcyA9IF9odW5rLm9sZFN0YXJ0ICsgX2h1bmsub2Zmc2V0ICsgZGlmZk9mZnNldCAtIDE7XG5cbiAgICAgIGRpZmZPZmZzZXQgKz0gX2h1bmsubmV3TGluZXMgLSBfaHVuay5vbGRMaW5lcztcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBfaHVuay5saW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbGluZSA9IF9odW5rLmxpbmVzW2pdLFxuICAgICAgICAgICAgb3BlcmF0aW9uID0gbGluZS5sZW5ndGggPiAwID8gbGluZVswXSA6ICcgJyxcbiAgICAgICAgICAgIGNvbnRlbnQgPSBsaW5lLmxlbmd0aCA+IDAgPyBsaW5lLnN1YnN0cigxKSA6IGxpbmUsXG4gICAgICAgICAgICBkZWxpbWl0ZXIgPSBfaHVuay5saW5lZGVsaW1pdGVyc1tqXTtcblxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnICcpIHtcbiAgICAgICAgICBfdG9Qb3MrKztcbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICAgIGxpbmVzLnNwbGljZShfdG9Qb3MsIDEpO1xuICAgICAgICAgIGRlbGltaXRlcnMuc3BsaWNlKF90b1BvcywgMSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICcrJykge1xuICAgICAgICAgIGxpbmVzLnNwbGljZShfdG9Qb3MsIDAsIGNvbnRlbnQpO1xuICAgICAgICAgIGRlbGltaXRlcnMuc3BsaWNlKF90b1BvcywgMCwgZGVsaW1pdGVyKTtcbiAgICAgICAgICBfdG9Qb3MrKztcbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICdcXFxcJykge1xuICAgICAgICAgIHZhciBwcmV2aW91c09wZXJhdGlvbiA9IF9odW5rLmxpbmVzW2ogLSAxXSA/IF9odW5rLmxpbmVzW2ogLSAxXVswXSA6IG51bGw7XG5cbiAgICAgICAgICBpZiAocHJldmlvdXNPcGVyYXRpb24gPT09ICcrJykge1xuICAgICAgICAgICAgcmVtb3ZlRU9GTkwgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNPcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICAgICAgYWRkRU9GTkwgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gSGFuZGxlIEVPRk5MIGluc2VydGlvbi9yZW1vdmFsXG5cblxuICAgIGlmIChyZW1vdmVFT0ZOTCkge1xuICAgICAgd2hpbGUgKCFsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSkge1xuICAgICAgICBsaW5lcy5wb3AoKTtcbiAgICAgICAgZGVsaW1pdGVycy5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFkZEVPRk5MKSB7XG4gICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgIGRlbGltaXRlcnMucHVzaCgnXFxuJyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IGxpbmVzLmxlbmd0aCAtIDE7IF9rKyspIHtcbiAgICAgIGxpbmVzW19rXSA9IGxpbmVzW19rXSArIGRlbGltaXRlcnNbX2tdO1xuICAgIH1cblxuICAgIHJldHVybiBsaW5lcy5qb2luKCcnKTtcbiAgfSAvLyBXcmFwcGVyIHRoYXQgc3VwcG9ydHMgbXVsdGlwbGUgZmlsZSBwYXRjaGVzIHZpYSBjYWxsYmFja3MuXG5cbiAgZnVuY3Rpb24gYXBwbHlQYXRjaGVzKHVuaURpZmYsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHVuaURpZmYgPT09ICdzdHJpbmcnKSB7XG4gICAgICB1bmlEaWZmID0gcGFyc2VQYXRjaCh1bmlEaWZmKTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudEluZGV4ID0gMDtcblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NJbmRleCgpIHtcbiAgICAgIHZhciBpbmRleCA9IHVuaURpZmZbY3VycmVudEluZGV4KytdO1xuXG4gICAgICBpZiAoIWluZGV4KSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKCk7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMubG9hZEZpbGUoaW5kZXgsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXBkYXRlZENvbnRlbnQgPSBhcHBseVBhdGNoKGRhdGEsIGluZGV4LCBvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5wYXRjaGVkKGluZGV4LCB1cGRhdGVkQ29udGVudCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJvY2Vzc0luZGV4KCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJvY2Vzc0luZGV4KCk7XG4gIH1cblxuICBmdW5jdGlvbiBzdHJ1Y3R1cmVkUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbnMuY29udGV4dCA9IDQ7XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSBkaWZmTGluZXMob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xuICAgIGRpZmYucHVzaCh7XG4gICAgICB2YWx1ZTogJycsXG4gICAgICBsaW5lczogW11cbiAgICB9KTsgLy8gQXBwZW5kIGFuIGVtcHR5IHZhbHVlIHRvIG1ha2UgY2xlYW51cCBlYXNpZXJcblxuICAgIGZ1bmN0aW9uIGNvbnRleHRMaW5lcyhsaW5lcykge1xuICAgICAgcmV0dXJuIGxpbmVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgcmV0dXJuICcgJyArIGVudHJ5O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGh1bmtzID0gW107XG4gICAgdmFyIG9sZFJhbmdlU3RhcnQgPSAwLFxuICAgICAgICBuZXdSYW5nZVN0YXJ0ID0gMCxcbiAgICAgICAgY3VyUmFuZ2UgPSBbXSxcbiAgICAgICAgb2xkTGluZSA9IDEsXG4gICAgICAgIG5ld0xpbmUgPSAxO1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBkaWZmW2ldLFxuICAgICAgICAgIGxpbmVzID0gY3VycmVudC5saW5lcyB8fCBjdXJyZW50LnZhbHVlLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpO1xuICAgICAgY3VycmVudC5saW5lcyA9IGxpbmVzO1xuXG4gICAgICBpZiAoY3VycmVudC5hZGRlZCB8fCBjdXJyZW50LnJlbW92ZWQpIHtcbiAgICAgICAgdmFyIF9jdXJSYW5nZTtcblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIHByZXZpb3VzIGNvbnRleHQsIHN0YXJ0IHdpdGggdGhhdFxuICAgICAgICBpZiAoIW9sZFJhbmdlU3RhcnQpIHtcbiAgICAgICAgICB2YXIgcHJldiA9IGRpZmZbaSAtIDFdO1xuICAgICAgICAgIG9sZFJhbmdlU3RhcnQgPSBvbGRMaW5lO1xuICAgICAgICAgIG5ld1JhbmdlU3RhcnQgPSBuZXdMaW5lO1xuXG4gICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIGN1clJhbmdlID0gb3B0aW9ucy5jb250ZXh0ID4gMCA/IGNvbnRleHRMaW5lcyhwcmV2LmxpbmVzLnNsaWNlKC1vcHRpb25zLmNvbnRleHQpKSA6IFtdO1xuICAgICAgICAgICAgb2xkUmFuZ2VTdGFydCAtPSBjdXJSYW5nZS5sZW5ndGg7XG4gICAgICAgICAgICBuZXdSYW5nZVN0YXJ0IC09IGN1clJhbmdlLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gT3V0cHV0IG91ciBjaGFuZ2VzXG5cblxuICAgICAgICAoX2N1clJhbmdlID0gY3VyUmFuZ2UpLnB1c2guYXBwbHkoX2N1clJhbmdlLCBfdG9Db25zdW1hYmxlQXJyYXkobGluZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIHJldHVybiAoY3VycmVudC5hZGRlZCA/ICcrJyA6ICctJykgKyBlbnRyeTtcbiAgICAgICAgfSkpKTsgLy8gVHJhY2sgdGhlIHVwZGF0ZWQgZmlsZSBwb3NpdGlvblxuXG5cbiAgICAgICAgaWYgKGN1cnJlbnQuYWRkZWQpIHtcbiAgICAgICAgICBuZXdMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbGRMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWRlbnRpY2FsIGNvbnRleHQgbGluZXMuIFRyYWNrIGxpbmUgY2hhbmdlc1xuICAgICAgICBpZiAob2xkUmFuZ2VTdGFydCkge1xuICAgICAgICAgIC8vIENsb3NlIG91dCBhbnkgY2hhbmdlcyB0aGF0IGhhdmUgYmVlbiBvdXRwdXQgKG9yIGpvaW4gb3ZlcmxhcHBpbmcpXG4gICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA8PSBvcHRpb25zLmNvbnRleHQgKiAyICYmIGkgPCBkaWZmLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgIHZhciBfY3VyUmFuZ2UyO1xuXG4gICAgICAgICAgICAvLyBPdmVybGFwcGluZ1xuICAgICAgICAgICAgKF9jdXJSYW5nZTIgPSBjdXJSYW5nZSkucHVzaC5hcHBseShfY3VyUmFuZ2UyLCBfdG9Db25zdW1hYmxlQXJyYXkoY29udGV4dExpbmVzKGxpbmVzKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX2N1clJhbmdlMztcblxuICAgICAgICAgICAgLy8gZW5kIHRoZSByYW5nZSBhbmQgb3V0cHV0XG4gICAgICAgICAgICB2YXIgY29udGV4dFNpemUgPSBNYXRoLm1pbihsaW5lcy5sZW5ndGgsIG9wdGlvbnMuY29udGV4dCk7XG5cbiAgICAgICAgICAgIChfY3VyUmFuZ2UzID0gY3VyUmFuZ2UpLnB1c2guYXBwbHkoX2N1clJhbmdlMywgX3RvQ29uc3VtYWJsZUFycmF5KGNvbnRleHRMaW5lcyhsaW5lcy5zbGljZSgwLCBjb250ZXh0U2l6ZSkpKSk7XG5cbiAgICAgICAgICAgIHZhciBodW5rID0ge1xuICAgICAgICAgICAgICBvbGRTdGFydDogb2xkUmFuZ2VTdGFydCxcbiAgICAgICAgICAgICAgb2xkTGluZXM6IG9sZExpbmUgLSBvbGRSYW5nZVN0YXJ0ICsgY29udGV4dFNpemUsXG4gICAgICAgICAgICAgIG5ld1N0YXJ0OiBuZXdSYW5nZVN0YXJ0LFxuICAgICAgICAgICAgICBuZXdMaW5lczogbmV3TGluZSAtIG5ld1JhbmdlU3RhcnQgKyBjb250ZXh0U2l6ZSxcbiAgICAgICAgICAgICAgbGluZXM6IGN1clJhbmdlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoaSA+PSBkaWZmLmxlbmd0aCAtIDIgJiYgbGluZXMubGVuZ3RoIDw9IG9wdGlvbnMuY29udGV4dCkge1xuICAgICAgICAgICAgICAvLyBFT0YgaXMgaW5zaWRlIHRoaXMgaHVua1xuICAgICAgICAgICAgICB2YXIgb2xkRU9GTmV3bGluZSA9IC9cXG4kLy50ZXN0KG9sZFN0cik7XG4gICAgICAgICAgICAgIHZhciBuZXdFT0ZOZXdsaW5lID0gL1xcbiQvLnRlc3QobmV3U3RyKTtcbiAgICAgICAgICAgICAgdmFyIG5vTmxCZWZvcmVBZGRzID0gbGluZXMubGVuZ3RoID09IDAgJiYgY3VyUmFuZ2UubGVuZ3RoID4gaHVuay5vbGRMaW5lcztcblxuICAgICAgICAgICAgICBpZiAoIW9sZEVPRk5ld2xpbmUgJiYgbm9ObEJlZm9yZUFkZHMgJiYgb2xkU3RyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IG9sZCBoYXMgbm8gZW9sIGFuZCBubyB0cmFpbGluZyBjb250ZXh0OyBuby1ubCBjYW4gZW5kIHVwIGJlZm9yZSBhZGRzXG4gICAgICAgICAgICAgICAgLy8gaG93ZXZlciwgaWYgdGhlIG9sZCBmaWxlIGlzIGVtcHR5LCBkbyBub3Qgb3V0cHV0IHRoZSBuby1ubCBsaW5lXG4gICAgICAgICAgICAgICAgY3VyUmFuZ2Uuc3BsaWNlKGh1bmsub2xkTGluZXMsIDAsICdcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghb2xkRU9GTmV3bGluZSAmJiAhbm9ObEJlZm9yZUFkZHMgfHwgIW5ld0VPRk5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICBjdXJSYW5nZS5wdXNoKCdcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBodW5rcy5wdXNoKGh1bmspO1xuICAgICAgICAgICAgb2xkUmFuZ2VTdGFydCA9IDA7XG4gICAgICAgICAgICBuZXdSYW5nZVN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGN1clJhbmdlID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIG5ld0xpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmYubGVuZ3RoOyBpKyspIHtcbiAgICAgIF9sb29wKGkpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvbGRGaWxlTmFtZTogb2xkRmlsZU5hbWUsXG4gICAgICBuZXdGaWxlTmFtZTogbmV3RmlsZU5hbWUsXG4gICAgICBvbGRIZWFkZXI6IG9sZEhlYWRlcixcbiAgICAgIG5ld0hlYWRlcjogbmV3SGVhZGVyLFxuICAgICAgaHVua3M6IGh1bmtzXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBmb3JtYXRQYXRjaChkaWZmKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgaWYgKGRpZmYub2xkRmlsZU5hbWUgPT0gZGlmZi5uZXdGaWxlTmFtZSkge1xuICAgICAgcmV0LnB1c2goJ0luZGV4OiAnICsgZGlmZi5vbGRGaWxlTmFtZSk7XG4gICAgfVxuXG4gICAgcmV0LnB1c2goJz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0nKTtcbiAgICByZXQucHVzaCgnLS0tICcgKyBkaWZmLm9sZEZpbGVOYW1lICsgKHR5cGVvZiBkaWZmLm9sZEhlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXHQnICsgZGlmZi5vbGRIZWFkZXIpKTtcbiAgICByZXQucHVzaCgnKysrICcgKyBkaWZmLm5ld0ZpbGVOYW1lICsgKHR5cGVvZiBkaWZmLm5ld0hlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXHQnICsgZGlmZi5uZXdIZWFkZXIpKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZi5odW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGh1bmsgPSBkaWZmLmh1bmtzW2ldOyAvLyBVbmlmaWVkIERpZmYgRm9ybWF0IHF1aXJrOiBJZiB0aGUgY2h1bmsgc2l6ZSBpcyAwLFxuICAgICAgLy8gdGhlIGZpcnN0IG51bWJlciBpcyBvbmUgbG93ZXIgdGhhbiBvbmUgd291bGQgZXhwZWN0LlxuICAgICAgLy8gaHR0cHM6Ly93d3cuYXJ0aW1hLmNvbS93ZWJsb2dzL3ZpZXdwb3N0LmpzcD90aHJlYWQ9MTY0MjkzXG5cbiAgICAgIGlmIChodW5rLm9sZExpbmVzID09PSAwKSB7XG4gICAgICAgIGh1bmsub2xkU3RhcnQgLT0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGh1bmsubmV3TGluZXMgPT09IDApIHtcbiAgICAgICAgaHVuay5uZXdTdGFydCAtPSAxO1xuICAgICAgfVxuXG4gICAgICByZXQucHVzaCgnQEAgLScgKyBodW5rLm9sZFN0YXJ0ICsgJywnICsgaHVuay5vbGRMaW5lcyArICcgKycgKyBodW5rLm5ld1N0YXJ0ICsgJywnICsgaHVuay5uZXdMaW5lcyArICcgQEAnKTtcbiAgICAgIHJldC5wdXNoLmFwcGx5KHJldCwgaHVuay5saW5lcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldC5qb2luKCdcXG4nKSArICdcXG4nO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVR3b0ZpbGVzUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZm9ybWF0UGF0Y2goc3RydWN0dXJlZFBhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlUGF0Y2goZmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykge1xuICAgIHJldHVybiBjcmVhdGVUd29GaWxlc1BhdGNoKGZpbGVOYW1lLCBmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5RXF1YWwoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlTdGFydHNXaXRoKGEsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIGFycmF5U3RhcnRzV2l0aChhcnJheSwgc3RhcnQpIHtcbiAgICBpZiAoc3RhcnQubGVuZ3RoID4gYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFydC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YXJ0W2ldICE9PSBhcnJheVtpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjTGluZUNvdW50KGh1bmspIHtcbiAgICB2YXIgX2NhbGNPbGROZXdMaW5lQ291bnQgPSBjYWxjT2xkTmV3TGluZUNvdW50KGh1bmsubGluZXMpLFxuICAgICAgICBvbGRMaW5lcyA9IF9jYWxjT2xkTmV3TGluZUNvdW50Lm9sZExpbmVzLFxuICAgICAgICBuZXdMaW5lcyA9IF9jYWxjT2xkTmV3TGluZUNvdW50Lm5ld0xpbmVzO1xuXG4gICAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGh1bmsub2xkTGluZXMgPSBvbGRMaW5lcztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIGh1bmsub2xkTGluZXM7XG4gICAgfVxuXG4gICAgaWYgKG5ld0xpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGh1bmsubmV3TGluZXMgPSBuZXdMaW5lcztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIGh1bmsubmV3TGluZXM7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlKG1pbmUsIHRoZWlycywgYmFzZSkge1xuICAgIG1pbmUgPSBsb2FkUGF0Y2gobWluZSwgYmFzZSk7XG4gICAgdGhlaXJzID0gbG9hZFBhdGNoKHRoZWlycywgYmFzZSk7XG4gICAgdmFyIHJldCA9IHt9OyAvLyBGb3IgaW5kZXggd2UganVzdCBsZXQgaXQgcGFzcyB0aHJvdWdoIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhbnkgbmVjZXNzYXJ5IG1lYW5pbmcuXG4gICAgLy8gTGVhdmluZyBzYW5pdHkgY2hlY2tzIG9uIHRoaXMgdG8gdGhlIEFQSSBjb25zdW1lciB0aGF0IG1heSBrbm93IG1vcmUgYWJvdXQgdGhlXG4gICAgLy8gbWVhbmluZyBpbiB0aGVpciBvd24gY29udGV4dC5cblxuICAgIGlmIChtaW5lLmluZGV4IHx8IHRoZWlycy5pbmRleCkge1xuICAgICAgcmV0LmluZGV4ID0gbWluZS5pbmRleCB8fCB0aGVpcnMuaW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKG1pbmUubmV3RmlsZU5hbWUgfHwgdGhlaXJzLm5ld0ZpbGVOYW1lKSB7XG4gICAgICBpZiAoIWZpbGVOYW1lQ2hhbmdlZChtaW5lKSkge1xuICAgICAgICAvLyBObyBoZWFkZXIgb3Igbm8gY2hhbmdlIGluIG91cnMsIHVzZSB0aGVpcnMgKGFuZCBvdXJzIGlmIHRoZWlycyBkb2VzIG5vdCBleGlzdClcbiAgICAgICAgcmV0Lm9sZEZpbGVOYW1lID0gdGhlaXJzLm9sZEZpbGVOYW1lIHx8IG1pbmUub2xkRmlsZU5hbWU7XG4gICAgICAgIHJldC5uZXdGaWxlTmFtZSA9IHRoZWlycy5uZXdGaWxlTmFtZSB8fCBtaW5lLm5ld0ZpbGVOYW1lO1xuICAgICAgICByZXQub2xkSGVhZGVyID0gdGhlaXJzLm9sZEhlYWRlciB8fCBtaW5lLm9sZEhlYWRlcjtcbiAgICAgICAgcmV0Lm5ld0hlYWRlciA9IHRoZWlycy5uZXdIZWFkZXIgfHwgbWluZS5uZXdIZWFkZXI7XG4gICAgICB9IGVsc2UgaWYgKCFmaWxlTmFtZUNoYW5nZWQodGhlaXJzKSkge1xuICAgICAgICAvLyBObyBoZWFkZXIgb3Igbm8gY2hhbmdlIGluIHRoZWlycywgdXNlIG91cnNcbiAgICAgICAgcmV0Lm9sZEZpbGVOYW1lID0gbWluZS5vbGRGaWxlTmFtZTtcbiAgICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gbWluZS5uZXdGaWxlTmFtZTtcbiAgICAgICAgcmV0Lm9sZEhlYWRlciA9IG1pbmUub2xkSGVhZGVyO1xuICAgICAgICByZXQubmV3SGVhZGVyID0gbWluZS5uZXdIZWFkZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCb3RoIGNoYW5nZWQuLi4gZmlndXJlIGl0IG91dFxuICAgICAgICByZXQub2xkRmlsZU5hbWUgPSBzZWxlY3RGaWVsZChyZXQsIG1pbmUub2xkRmlsZU5hbWUsIHRoZWlycy5vbGRGaWxlTmFtZSk7XG4gICAgICAgIHJldC5uZXdGaWxlTmFtZSA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5uZXdGaWxlTmFtZSwgdGhlaXJzLm5ld0ZpbGVOYW1lKTtcbiAgICAgICAgcmV0Lm9sZEhlYWRlciA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5vbGRIZWFkZXIsIHRoZWlycy5vbGRIZWFkZXIpO1xuICAgICAgICByZXQubmV3SGVhZGVyID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm5ld0hlYWRlciwgdGhlaXJzLm5ld0hlYWRlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0Lmh1bmtzID0gW107XG4gICAgdmFyIG1pbmVJbmRleCA9IDAsXG4gICAgICAgIHRoZWlyc0luZGV4ID0gMCxcbiAgICAgICAgbWluZU9mZnNldCA9IDAsXG4gICAgICAgIHRoZWlyc09mZnNldCA9IDA7XG5cbiAgICB3aGlsZSAobWluZUluZGV4IDwgbWluZS5odW5rcy5sZW5ndGggfHwgdGhlaXJzSW5kZXggPCB0aGVpcnMuaHVua3MubGVuZ3RoKSB7XG4gICAgICB2YXIgbWluZUN1cnJlbnQgPSBtaW5lLmh1bmtzW21pbmVJbmRleF0gfHwge1xuICAgICAgICBvbGRTdGFydDogSW5maW5pdHlcbiAgICAgIH0sXG4gICAgICAgICAgdGhlaXJzQ3VycmVudCA9IHRoZWlycy5odW5rc1t0aGVpcnNJbmRleF0gfHwge1xuICAgICAgICBvbGRTdGFydDogSW5maW5pdHlcbiAgICAgIH07XG5cbiAgICAgIGlmIChodW5rQmVmb3JlKG1pbmVDdXJyZW50LCB0aGVpcnNDdXJyZW50KSkge1xuICAgICAgICAvLyBUaGlzIHBhdGNoIGRvZXMgbm90IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIG90aGVycywgeWF5LlxuICAgICAgICByZXQuaHVua3MucHVzaChjbG9uZUh1bmsobWluZUN1cnJlbnQsIG1pbmVPZmZzZXQpKTtcbiAgICAgICAgbWluZUluZGV4Kys7XG4gICAgICAgIHRoZWlyc09mZnNldCArPSBtaW5lQ3VycmVudC5uZXdMaW5lcyAtIG1pbmVDdXJyZW50Lm9sZExpbmVzO1xuICAgICAgfSBlbHNlIGlmIChodW5rQmVmb3JlKHRoZWlyc0N1cnJlbnQsIG1pbmVDdXJyZW50KSkge1xuICAgICAgICAvLyBUaGlzIHBhdGNoIGRvZXMgbm90IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIG90aGVycywgeWF5LlxuICAgICAgICByZXQuaHVua3MucHVzaChjbG9uZUh1bmsodGhlaXJzQ3VycmVudCwgdGhlaXJzT2Zmc2V0KSk7XG4gICAgICAgIHRoZWlyc0luZGV4Kys7XG4gICAgICAgIG1pbmVPZmZzZXQgKz0gdGhlaXJzQ3VycmVudC5uZXdMaW5lcyAtIHRoZWlyc0N1cnJlbnQub2xkTGluZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdmVybGFwLCBtZXJnZSBhcyBiZXN0IHdlIGNhblxuICAgICAgICB2YXIgbWVyZ2VkSHVuayA9IHtcbiAgICAgICAgICBvbGRTdGFydDogTWF0aC5taW4obWluZUN1cnJlbnQub2xkU3RhcnQsIHRoZWlyc0N1cnJlbnQub2xkU3RhcnQpLFxuICAgICAgICAgIG9sZExpbmVzOiAwLFxuICAgICAgICAgIG5ld1N0YXJ0OiBNYXRoLm1pbihtaW5lQ3VycmVudC5uZXdTdGFydCArIG1pbmVPZmZzZXQsIHRoZWlyc0N1cnJlbnQub2xkU3RhcnQgKyB0aGVpcnNPZmZzZXQpLFxuICAgICAgICAgIG5ld0xpbmVzOiAwLFxuICAgICAgICAgIGxpbmVzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBtZXJnZUxpbmVzKG1lcmdlZEh1bmssIG1pbmVDdXJyZW50Lm9sZFN0YXJ0LCBtaW5lQ3VycmVudC5saW5lcywgdGhlaXJzQ3VycmVudC5vbGRTdGFydCwgdGhlaXJzQ3VycmVudC5saW5lcyk7XG4gICAgICAgIHRoZWlyc0luZGV4Kys7XG4gICAgICAgIG1pbmVJbmRleCsrO1xuICAgICAgICByZXQuaHVua3MucHVzaChtZXJnZWRIdW5rKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgZnVuY3Rpb24gbG9hZFBhdGNoKHBhcmFtLCBiYXNlKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICgvXkBAL20udGVzdChwYXJhbSkgfHwgL15JbmRleDovbS50ZXN0KHBhcmFtKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VQYXRjaChwYXJhbSlbMF07XG4gICAgICB9XG5cbiAgICAgIGlmICghYmFzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhIGJhc2UgcmVmZXJlbmNlIG9yIHBhc3MgaW4gYSBwYXRjaCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RydWN0dXJlZFBhdGNoKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBiYXNlLCBwYXJhbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsZU5hbWVDaGFuZ2VkKHBhdGNoKSB7XG4gICAgcmV0dXJuIHBhdGNoLm5ld0ZpbGVOYW1lICYmIHBhdGNoLm5ld0ZpbGVOYW1lICE9PSBwYXRjaC5vbGRGaWxlTmFtZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdEZpZWxkKGluZGV4LCBtaW5lLCB0aGVpcnMpIHtcbiAgICBpZiAobWluZSA9PT0gdGhlaXJzKSB7XG4gICAgICByZXR1cm4gbWluZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXguY29uZmxpY3QgPSB0cnVlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluZTogbWluZSxcbiAgICAgICAgdGhlaXJzOiB0aGVpcnNcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaHVua0JlZm9yZSh0ZXN0LCBjaGVjaykge1xuICAgIHJldHVybiB0ZXN0Lm9sZFN0YXJ0IDwgY2hlY2sub2xkU3RhcnQgJiYgdGVzdC5vbGRTdGFydCArIHRlc3Qub2xkTGluZXMgPCBjaGVjay5vbGRTdGFydDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lSHVuayhodW5rLCBvZmZzZXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb2xkU3RhcnQ6IGh1bmsub2xkU3RhcnQsXG4gICAgICBvbGRMaW5lczogaHVuay5vbGRMaW5lcyxcbiAgICAgIG5ld1N0YXJ0OiBodW5rLm5ld1N0YXJ0ICsgb2Zmc2V0LFxuICAgICAgbmV3TGluZXM6IGh1bmsubmV3TGluZXMsXG4gICAgICBsaW5lczogaHVuay5saW5lc1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUxpbmVzKGh1bmssIG1pbmVPZmZzZXQsIG1pbmVMaW5lcywgdGhlaXJPZmZzZXQsIHRoZWlyTGluZXMpIHtcbiAgICAvLyBUaGlzIHdpbGwgZ2VuZXJhbGx5IHJlc3VsdCBpbiBhIGNvbmZsaWN0ZWQgaHVuaywgYnV0IHRoZXJlIGFyZSBjYXNlcyB3aGVyZSB0aGUgY29udGV4dFxuICAgIC8vIGlzIHRoZSBvbmx5IG92ZXJsYXAgd2hlcmUgd2UgY2FuIHN1Y2Nlc3NmdWxseSBtZXJnZSB0aGUgY29udGVudCBoZXJlLlxuICAgIHZhciBtaW5lID0ge1xuICAgICAgb2Zmc2V0OiBtaW5lT2Zmc2V0LFxuICAgICAgbGluZXM6IG1pbmVMaW5lcyxcbiAgICAgIGluZGV4OiAwXG4gICAgfSxcbiAgICAgICAgdGhlaXIgPSB7XG4gICAgICBvZmZzZXQ6IHRoZWlyT2Zmc2V0LFxuICAgICAgbGluZXM6IHRoZWlyTGluZXMsXG4gICAgICBpbmRleDogMFxuICAgIH07IC8vIEhhbmRsZSBhbnkgbGVhZGluZyBjb250ZW50XG5cbiAgICBpbnNlcnRMZWFkaW5nKGh1bmssIG1pbmUsIHRoZWlyKTtcbiAgICBpbnNlcnRMZWFkaW5nKGh1bmssIHRoZWlyLCBtaW5lKTsgLy8gTm93IGluIHRoZSBvdmVybGFwIGNvbnRlbnQuIFNjYW4gdGhyb3VnaCBhbmQgc2VsZWN0IHRoZSBiZXN0IGNoYW5nZXMgZnJvbSBlYWNoLlxuXG4gICAgd2hpbGUgKG1pbmUuaW5kZXggPCBtaW5lLmxpbmVzLmxlbmd0aCAmJiB0aGVpci5pbmRleCA8IHRoZWlyLmxpbmVzLmxlbmd0aCkge1xuICAgICAgdmFyIG1pbmVDdXJyZW50ID0gbWluZS5saW5lc1ttaW5lLmluZGV4XSxcbiAgICAgICAgICB0aGVpckN1cnJlbnQgPSB0aGVpci5saW5lc1t0aGVpci5pbmRleF07XG5cbiAgICAgIGlmICgobWluZUN1cnJlbnRbMF0gPT09ICctJyB8fCBtaW5lQ3VycmVudFswXSA9PT0gJysnKSAmJiAodGhlaXJDdXJyZW50WzBdID09PSAnLScgfHwgdGhlaXJDdXJyZW50WzBdID09PSAnKycpKSB7XG4gICAgICAgIC8vIEJvdGggbW9kaWZpZWQgLi4uXG4gICAgICAgIG11dHVhbENoYW5nZShodW5rLCBtaW5lLCB0aGVpcik7XG4gICAgICB9IGVsc2UgaWYgKG1pbmVDdXJyZW50WzBdID09PSAnKycgJiYgdGhlaXJDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgICAgdmFyIF9odW5rJGxpbmVzO1xuXG4gICAgICAgIC8vIE1pbmUgaW5zZXJ0ZWRcbiAgICAgICAgKF9odW5rJGxpbmVzID0gaHVuay5saW5lcykucHVzaC5hcHBseShfaHVuayRsaW5lcywgX3RvQ29uc3VtYWJsZUFycmF5KGNvbGxlY3RDaGFuZ2UobWluZSkpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhlaXJDdXJyZW50WzBdID09PSAnKycgJiYgbWluZUN1cnJlbnRbMF0gPT09ICcgJykge1xuICAgICAgICB2YXIgX2h1bmskbGluZXMyO1xuXG4gICAgICAgIC8vIFRoZWlycyBpbnNlcnRlZFxuICAgICAgICAoX2h1bmskbGluZXMyID0gaHVuay5saW5lcykucHVzaC5hcHBseShfaHVuayRsaW5lczIsIF90b0NvbnN1bWFibGVBcnJheShjb2xsZWN0Q2hhbmdlKHRoZWlyKSkpO1xuICAgICAgfSBlbHNlIGlmIChtaW5lQ3VycmVudFswXSA9PT0gJy0nICYmIHRoZWlyQ3VycmVudFswXSA9PT0gJyAnKSB7XG4gICAgICAgIC8vIE1pbmUgcmVtb3ZlZCBvciBlZGl0ZWRcbiAgICAgICAgcmVtb3ZhbChodW5rLCBtaW5lLCB0aGVpcik7XG4gICAgICB9IGVsc2UgaWYgKHRoZWlyQ3VycmVudFswXSA9PT0gJy0nICYmIG1pbmVDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgICAgLy8gVGhlaXIgcmVtb3ZlZCBvciBlZGl0ZWRcbiAgICAgICAgcmVtb3ZhbChodW5rLCB0aGVpciwgbWluZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG1pbmVDdXJyZW50ID09PSB0aGVpckN1cnJlbnQpIHtcbiAgICAgICAgLy8gQ29udGV4dCBpZGVudGl0eVxuICAgICAgICBodW5rLmxpbmVzLnB1c2gobWluZUN1cnJlbnQpO1xuICAgICAgICBtaW5lLmluZGV4Kys7XG4gICAgICAgIHRoZWlyLmluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb250ZXh0IG1pc21hdGNoXG4gICAgICAgIGNvbmZsaWN0KGh1bmssIGNvbGxlY3RDaGFuZ2UobWluZSksIGNvbGxlY3RDaGFuZ2UodGhlaXIpKTtcbiAgICAgIH1cbiAgICB9IC8vIE5vdyBwdXNoIGFueXRoaW5nIHRoYXQgbWF5IGJlIHJlbWFpbmluZ1xuXG5cbiAgICBpbnNlcnRUcmFpbGluZyhodW5rLCBtaW5lKTtcbiAgICBpbnNlcnRUcmFpbGluZyhodW5rLCB0aGVpcik7XG4gICAgY2FsY0xpbmVDb3VudChodW5rKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG11dHVhbENoYW5nZShodW5rLCBtaW5lLCB0aGVpcikge1xuICAgIHZhciBteUNoYW5nZXMgPSBjb2xsZWN0Q2hhbmdlKG1pbmUpLFxuICAgICAgICB0aGVpckNoYW5nZXMgPSBjb2xsZWN0Q2hhbmdlKHRoZWlyKTtcblxuICAgIGlmIChhbGxSZW1vdmVzKG15Q2hhbmdlcykgJiYgYWxsUmVtb3Zlcyh0aGVpckNoYW5nZXMpKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHJlbW92ZSBjaGFuZ2VzIHRoYXQgYXJlIHN1cGVyc2V0cyBvZiBvbmUgYW5vdGhlclxuICAgICAgaWYgKGFycmF5U3RhcnRzV2l0aChteUNoYW5nZXMsIHRoZWlyQ2hhbmdlcykgJiYgc2tpcFJlbW92ZVN1cGVyc2V0KHRoZWlyLCBteUNoYW5nZXMsIG15Q2hhbmdlcy5sZW5ndGggLSB0aGVpckNoYW5nZXMubGVuZ3RoKSkge1xuICAgICAgICB2YXIgX2h1bmskbGluZXMzO1xuXG4gICAgICAgIChfaHVuayRsaW5lczMgPSBodW5rLmxpbmVzKS5wdXNoLmFwcGx5KF9odW5rJGxpbmVzMywgX3RvQ29uc3VtYWJsZUFycmF5KG15Q2hhbmdlcykpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoYXJyYXlTdGFydHNXaXRoKHRoZWlyQ2hhbmdlcywgbXlDaGFuZ2VzKSAmJiBza2lwUmVtb3ZlU3VwZXJzZXQobWluZSwgdGhlaXJDaGFuZ2VzLCB0aGVpckNoYW5nZXMubGVuZ3RoIC0gbXlDaGFuZ2VzLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIF9odW5rJGxpbmVzNDtcblxuICAgICAgICAoX2h1bmskbGluZXM0ID0gaHVuay5saW5lcykucHVzaC5hcHBseShfaHVuayRsaW5lczQsIF90b0NvbnN1bWFibGVBcnJheSh0aGVpckNoYW5nZXMpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcnJheUVxdWFsKG15Q2hhbmdlcywgdGhlaXJDaGFuZ2VzKSkge1xuICAgICAgdmFyIF9odW5rJGxpbmVzNTtcblxuICAgICAgKF9odW5rJGxpbmVzNSA9IGh1bmsubGluZXMpLnB1c2guYXBwbHkoX2h1bmskbGluZXM1LCBfdG9Db25zdW1hYmxlQXJyYXkobXlDaGFuZ2VzKSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25mbGljdChodW5rLCBteUNoYW5nZXMsIHRoZWlyQ2hhbmdlcyk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmFsKGh1bmssIG1pbmUsIHRoZWlyLCBzd2FwKSB7XG4gICAgdmFyIG15Q2hhbmdlcyA9IGNvbGxlY3RDaGFuZ2UobWluZSksXG4gICAgICAgIHRoZWlyQ2hhbmdlcyA9IGNvbGxlY3RDb250ZXh0KHRoZWlyLCBteUNoYW5nZXMpO1xuXG4gICAgaWYgKHRoZWlyQ2hhbmdlcy5tZXJnZWQpIHtcbiAgICAgIHZhciBfaHVuayRsaW5lczY7XG5cbiAgICAgIChfaHVuayRsaW5lczYgPSBodW5rLmxpbmVzKS5wdXNoLmFwcGx5KF9odW5rJGxpbmVzNiwgX3RvQ29uc3VtYWJsZUFycmF5KHRoZWlyQ2hhbmdlcy5tZXJnZWQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmxpY3QoaHVuaywgc3dhcCA/IHRoZWlyQ2hhbmdlcyA6IG15Q2hhbmdlcywgc3dhcCA/IG15Q2hhbmdlcyA6IHRoZWlyQ2hhbmdlcyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29uZmxpY3QoaHVuaywgbWluZSwgdGhlaXIpIHtcbiAgICBodW5rLmNvbmZsaWN0ID0gdHJ1ZTtcbiAgICBodW5rLmxpbmVzLnB1c2goe1xuICAgICAgY29uZmxpY3Q6IHRydWUsXG4gICAgICBtaW5lOiBtaW5lLFxuICAgICAgdGhlaXJzOiB0aGVpclxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0TGVhZGluZyhodW5rLCBpbnNlcnQsIHRoZWlyKSB7XG4gICAgd2hpbGUgKGluc2VydC5vZmZzZXQgPCB0aGVpci5vZmZzZXQgJiYgaW5zZXJ0LmluZGV4IDwgaW5zZXJ0LmxpbmVzLmxlbmd0aCkge1xuICAgICAgdmFyIGxpbmUgPSBpbnNlcnQubGluZXNbaW5zZXJ0LmluZGV4KytdO1xuICAgICAgaHVuay5saW5lcy5wdXNoKGxpbmUpO1xuICAgICAgaW5zZXJ0Lm9mZnNldCsrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydFRyYWlsaW5nKGh1bmssIGluc2VydCkge1xuICAgIHdoaWxlIChpbnNlcnQuaW5kZXggPCBpbnNlcnQubGluZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgbGluZSA9IGluc2VydC5saW5lc1tpbnNlcnQuaW5kZXgrK107XG4gICAgICBodW5rLmxpbmVzLnB1c2gobGluZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29sbGVjdENoYW5nZShzdGF0ZSkge1xuICAgIHZhciByZXQgPSBbXSxcbiAgICAgICAgb3BlcmF0aW9uID0gc3RhdGUubGluZXNbc3RhdGUuaW5kZXhdWzBdO1xuXG4gICAgd2hpbGUgKHN0YXRlLmluZGV4IDwgc3RhdGUubGluZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgbGluZSA9IHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4XTsgLy8gR3JvdXAgYWRkaXRpb25zIHRoYXQgYXJlIGltbWVkaWF0ZWx5IGFmdGVyIHN1YnRyYWN0aW9ucyBhbmQgdHJlYXQgdGhlbSBhcyBvbmUgXCJhdG9taWNcIiBtb2RpZnkgY2hhbmdlLlxuXG4gICAgICBpZiAob3BlcmF0aW9uID09PSAnLScgJiYgbGluZVswXSA9PT0gJysnKSB7XG4gICAgICAgIG9wZXJhdGlvbiA9ICcrJztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gbGluZVswXSkge1xuICAgICAgICByZXQucHVzaChsaW5lKTtcbiAgICAgICAgc3RhdGUuaW5kZXgrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBjb2xsZWN0Q29udGV4dChzdGF0ZSwgbWF0Y2hDaGFuZ2VzKSB7XG4gICAgdmFyIGNoYW5nZXMgPSBbXSxcbiAgICAgICAgbWVyZ2VkID0gW10sXG4gICAgICAgIG1hdGNoSW5kZXggPSAwLFxuICAgICAgICBjb250ZXh0Q2hhbmdlcyA9IGZhbHNlLFxuICAgICAgICBjb25mbGljdGVkID0gZmFsc2U7XG5cbiAgICB3aGlsZSAobWF0Y2hJbmRleCA8IG1hdGNoQ2hhbmdlcy5sZW5ndGggJiYgc3RhdGUuaW5kZXggPCBzdGF0ZS5saW5lcy5sZW5ndGgpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleF0sXG4gICAgICAgICAgbWF0Y2ggPSBtYXRjaENoYW5nZXNbbWF0Y2hJbmRleF07IC8vIE9uY2Ugd2UndmUgaGl0IG91ciBhZGQsIHRoZW4gd2UgYXJlIGRvbmVcblxuICAgICAgaWYgKG1hdGNoWzBdID09PSAnKycpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHRDaGFuZ2VzID0gY29udGV4dENoYW5nZXMgfHwgY2hhbmdlWzBdICE9PSAnICc7XG4gICAgICBtZXJnZWQucHVzaChtYXRjaCk7XG4gICAgICBtYXRjaEluZGV4Kys7IC8vIENvbnN1bWUgYW55IGFkZGl0aW9ucyBpbiB0aGUgb3RoZXIgYmxvY2sgYXMgYSBjb25mbGljdCB0byBhdHRlbXB0XG4gICAgICAvLyB0byBwdWxsIGluIHRoZSByZW1haW5pbmcgY29udGV4dCBhZnRlciB0aGlzXG5cbiAgICAgIGlmIChjaGFuZ2VbMF0gPT09ICcrJykge1xuICAgICAgICBjb25mbGljdGVkID0gdHJ1ZTtcblxuICAgICAgICB3aGlsZSAoY2hhbmdlWzBdID09PSAnKycpIHtcbiAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICBjaGFuZ2UgPSBzdGF0ZS5saW5lc1srK3N0YXRlLmluZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2guc3Vic3RyKDEpID09PSBjaGFuZ2Uuc3Vic3RyKDEpKSB7XG4gICAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICBzdGF0ZS5pbmRleCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmxpY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKChtYXRjaENoYW5nZXNbbWF0Y2hJbmRleF0gfHwgJycpWzBdID09PSAnKycgJiYgY29udGV4dENoYW5nZXMpIHtcbiAgICAgIGNvbmZsaWN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjb25mbGljdGVkKSB7XG4gICAgICByZXR1cm4gY2hhbmdlcztcbiAgICB9XG5cbiAgICB3aGlsZSAobWF0Y2hJbmRleCA8IG1hdGNoQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgIG1lcmdlZC5wdXNoKG1hdGNoQ2hhbmdlc1ttYXRjaEluZGV4KytdKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWVyZ2VkOiBtZXJnZWQsXG4gICAgICBjaGFuZ2VzOiBjaGFuZ2VzXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFsbFJlbW92ZXMoY2hhbmdlcykge1xuICAgIHJldHVybiBjaGFuZ2VzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY2hhbmdlKSB7XG4gICAgICByZXR1cm4gcHJldiAmJiBjaGFuZ2VbMF0gPT09ICctJztcbiAgICB9LCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBSZW1vdmVTdXBlcnNldChzdGF0ZSwgcmVtb3ZlQ2hhbmdlcywgZGVsdGEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbHRhOyBpKyspIHtcbiAgICAgIHZhciBjaGFuZ2VDb250ZW50ID0gcmVtb3ZlQ2hhbmdlc1tyZW1vdmVDaGFuZ2VzLmxlbmd0aCAtIGRlbHRhICsgaV0uc3Vic3RyKDEpO1xuXG4gICAgICBpZiAoc3RhdGUubGluZXNbc3RhdGUuaW5kZXggKyBpXSAhPT0gJyAnICsgY2hhbmdlQ29udGVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUuaW5kZXggKz0gZGVsdGE7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjT2xkTmV3TGluZUNvdW50KGxpbmVzKSB7XG4gICAgdmFyIG9sZExpbmVzID0gMDtcbiAgICB2YXIgbmV3TGluZXMgPSAwO1xuICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmICh0eXBlb2YgbGluZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIG15Q291bnQgPSBjYWxjT2xkTmV3TGluZUNvdW50KGxpbmUubWluZSk7XG4gICAgICAgIHZhciB0aGVpckNvdW50ID0gY2FsY09sZE5ld0xpbmVDb3VudChsaW5lLnRoZWlycyk7XG5cbiAgICAgICAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAobXlDb3VudC5vbGRMaW5lcyA9PT0gdGhlaXJDb3VudC5vbGRMaW5lcykge1xuICAgICAgICAgICAgb2xkTGluZXMgKz0gbXlDb3VudC5vbGRMaW5lcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2xkTGluZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0xpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAobXlDb3VudC5uZXdMaW5lcyA9PT0gdGhlaXJDb3VudC5uZXdMaW5lcykge1xuICAgICAgICAgICAgbmV3TGluZXMgKz0gbXlDb3VudC5uZXdMaW5lcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TGluZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobmV3TGluZXMgIT09IHVuZGVmaW5lZCAmJiAobGluZVswXSA9PT0gJysnIHx8IGxpbmVbMF0gPT09ICcgJykpIHtcbiAgICAgICAgICBuZXdMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQgJiYgKGxpbmVbMF0gPT09ICctJyB8fCBsaW5lWzBdID09PSAnICcpKSB7XG4gICAgICAgICAgb2xkTGluZXMrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBvbGRMaW5lczogb2xkTGluZXMsXG4gICAgICBuZXdMaW5lczogbmV3TGluZXNcbiAgICB9O1xuICB9XG5cbiAgLy8gU2VlOiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZ29vZ2xlLWRpZmYtbWF0Y2gtcGF0Y2gvd2lraS9BUElcbiAgZnVuY3Rpb24gY29udmVydENoYW5nZXNUb0RNUChjaGFuZ2VzKSB7XG4gICAgdmFyIHJldCA9IFtdLFxuICAgICAgICBjaGFuZ2UsXG4gICAgICAgIG9wZXJhdGlvbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhbmdlID0gY2hhbmdlc1tpXTtcblxuICAgICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgICBvcGVyYXRpb24gPSAxO1xuICAgICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xuICAgICAgICBvcGVyYXRpb24gPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wZXJhdGlvbiA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldC5wdXNoKFtvcGVyYXRpb24sIGNoYW5nZS52YWx1ZV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0Q2hhbmdlc1RvWE1MKGNoYW5nZXMpIHtcbiAgICB2YXIgcmV0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuXG4gICAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICAgIHJldC5wdXNoKCc8aW5zPicpO1xuICAgICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xuICAgICAgICByZXQucHVzaCgnPGRlbD4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0LnB1c2goZXNjYXBlSFRNTChjaGFuZ2UudmFsdWUpKTtcblxuICAgICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgICByZXQucHVzaCgnPC9pbnM+Jyk7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICAgIHJldC5wdXNoKCc8L2RlbD4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXNjYXBlSFRNTChzKSB7XG4gICAgdmFyIG4gPSBzO1xuICAgIG4gPSBuLnJlcGxhY2UoLyYvZywgJyZhbXA7Jyk7XG4gICAgbiA9IG4ucmVwbGFjZSgvPC9nLCAnJmx0OycpO1xuICAgIG4gPSBuLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgICBuID0gbi5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gICAgcmV0dXJuIG47XG4gIH1cblxuICBleHBvcnRzLkRpZmYgPSBEaWZmO1xuICBleHBvcnRzLmFwcGx5UGF0Y2ggPSBhcHBseVBhdGNoO1xuICBleHBvcnRzLmFwcGx5UGF0Y2hlcyA9IGFwcGx5UGF0Y2hlcztcbiAgZXhwb3J0cy5jYW5vbmljYWxpemUgPSBjYW5vbmljYWxpemU7XG4gIGV4cG9ydHMuY29udmVydENoYW5nZXNUb0RNUCA9IGNvbnZlcnRDaGFuZ2VzVG9ETVA7XG4gIGV4cG9ydHMuY29udmVydENoYW5nZXNUb1hNTCA9IGNvbnZlcnRDaGFuZ2VzVG9YTUw7XG4gIGV4cG9ydHMuY3JlYXRlUGF0Y2ggPSBjcmVhdGVQYXRjaDtcbiAgZXhwb3J0cy5jcmVhdGVUd29GaWxlc1BhdGNoID0gY3JlYXRlVHdvRmlsZXNQYXRjaDtcbiAgZXhwb3J0cy5kaWZmQXJyYXlzID0gZGlmZkFycmF5cztcbiAgZXhwb3J0cy5kaWZmQ2hhcnMgPSBkaWZmQ2hhcnM7XG4gIGV4cG9ydHMuZGlmZkNzcyA9IGRpZmZDc3M7XG4gIGV4cG9ydHMuZGlmZkpzb24gPSBkaWZmSnNvbjtcbiAgZXhwb3J0cy5kaWZmTGluZXMgPSBkaWZmTGluZXM7XG4gIGV4cG9ydHMuZGlmZlNlbnRlbmNlcyA9IGRpZmZTZW50ZW5jZXM7XG4gIGV4cG9ydHMuZGlmZlRyaW1tZWRMaW5lcyA9IGRpZmZUcmltbWVkTGluZXM7XG4gIGV4cG9ydHMuZGlmZldvcmRzID0gZGlmZldvcmRzO1xuICBleHBvcnRzLmRpZmZXb3Jkc1dpdGhTcGFjZSA9IGRpZmZXb3Jkc1dpdGhTcGFjZTtcbiAgZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuICBleHBvcnRzLnBhcnNlUGF0Y2ggPSBwYXJzZVBhdGNoO1xuICBleHBvcnRzLnN0cnVjdHVyZWRQYXRjaCA9IHN0cnVjdHVyZWRQYXRjaDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9oZSB2MS4yLjAgYnkgQG1hdGhpYXMgfCBNSVQgbGljZW5zZSAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYC5cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC5cblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLFxuXHQvLyBhbmQgdXNlIGl0IGFzIGByb290YC5cblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvLyBBbGwgYXN0cmFsIHN5bWJvbHMuXG5cdHZhciByZWdleEFzdHJhbFN5bWJvbHMgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nO1xuXHQvLyBBbGwgQVNDSUkgc3ltYm9scyAobm90IGp1c3QgcHJpbnRhYmxlIEFTQ0lJKSBleGNlcHQgdGhvc2UgbGlzdGVkIGluIHRoZVxuXHQvLyBmaXJzdCBjb2x1bW4gb2YgdGhlIG92ZXJyaWRlcyB0YWJsZS5cblx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjdGFibGUtY2hhcnJlZi1vdmVycmlkZXNcblx0dmFyIHJlZ2V4QXNjaWlXaGl0ZWxpc3QgPSAvW1xceDAxLVxceDdGXS9nO1xuXHQvLyBBbGwgQk1QIHN5bWJvbHMgdGhhdCBhcmUgbm90IEFTQ0lJIG5ld2xpbmVzLCBwcmludGFibGUgQVNDSUkgc3ltYm9scywgb3Jcblx0Ly8gY29kZSBwb2ludHMgbGlzdGVkIGluIHRoZSBmaXJzdCBjb2x1bW4gb2YgdGhlIG92ZXJyaWRlcyB0YWJsZSBvblxuXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCN0YWJsZS1jaGFycmVmLW92ZXJyaWRlcy5cblx0dmFyIHJlZ2V4Qm1wV2hpdGVsaXN0ID0gL1tcXHgwMS1cXHRcXHgwQlxcZlxceDBFLVxceDFGXFx4N0ZcXHg4MVxceDhEXFx4OEZcXHg5MFxceDlEXFx4QTAtXFx1RkZGRl0vZztcblxuXHR2YXIgcmVnZXhFbmNvZGVOb25Bc2NpaSA9IC88XFx1MjBEMnw9XFx1MjBFNXw+XFx1MjBEMnxcXHUyMDVGXFx1MjAwQXxcXHUyMTlEXFx1MDMzOHxcXHUyMjAyXFx1MDMzOHxcXHUyMjIwXFx1MjBEMnxcXHUyMjI5XFx1RkUwMHxcXHUyMjJBXFx1RkUwMHxcXHUyMjNDXFx1MjBEMnxcXHUyMjNEXFx1MDMzMXxcXHUyMjNFXFx1MDMzM3xcXHUyMjQyXFx1MDMzOHxcXHUyMjRCXFx1MDMzOHxcXHUyMjREXFx1MjBEMnxcXHUyMjRFXFx1MDMzOHxcXHUyMjRGXFx1MDMzOHxcXHUyMjUwXFx1MDMzOHxcXHUyMjYxXFx1MjBFNXxcXHUyMjY0XFx1MjBEMnxcXHUyMjY1XFx1MjBEMnxcXHUyMjY2XFx1MDMzOHxcXHUyMjY3XFx1MDMzOHxcXHUyMjY4XFx1RkUwMHxcXHUyMjY5XFx1RkUwMHxcXHUyMjZBXFx1MDMzOHxcXHUyMjZBXFx1MjBEMnxcXHUyMjZCXFx1MDMzOHxcXHUyMjZCXFx1MjBEMnxcXHUyMjdGXFx1MDMzOHxcXHUyMjgyXFx1MjBEMnxcXHUyMjgzXFx1MjBEMnxcXHUyMjhBXFx1RkUwMHxcXHUyMjhCXFx1RkUwMHxcXHUyMjhGXFx1MDMzOHxcXHUyMjkwXFx1MDMzOHxcXHUyMjkzXFx1RkUwMHxcXHUyMjk0XFx1RkUwMHxcXHUyMkI0XFx1MjBEMnxcXHUyMkI1XFx1MjBEMnxcXHUyMkQ4XFx1MDMzOHxcXHUyMkQ5XFx1MDMzOHxcXHUyMkRBXFx1RkUwMHxcXHUyMkRCXFx1RkUwMHxcXHUyMkY1XFx1MDMzOHxcXHUyMkY5XFx1MDMzOHxcXHUyOTMzXFx1MDMzOHxcXHUyOUNGXFx1MDMzOHxcXHUyOUQwXFx1MDMzOHxcXHUyQTZEXFx1MDMzOHxcXHUyQTcwXFx1MDMzOHxcXHUyQTdEXFx1MDMzOHxcXHUyQTdFXFx1MDMzOHxcXHUyQUExXFx1MDMzOHxcXHUyQUEyXFx1MDMzOHxcXHUyQUFDXFx1RkUwMHxcXHUyQUFEXFx1RkUwMHxcXHUyQUFGXFx1MDMzOHxcXHUyQUIwXFx1MDMzOHxcXHUyQUM1XFx1MDMzOHxcXHUyQUM2XFx1MDMzOHxcXHUyQUNCXFx1RkUwMHxcXHUyQUNDXFx1RkUwMHxcXHUyQUZEXFx1MjBFNXxbXFx4QTAtXFx1MDExM1xcdTAxMTYtXFx1MDEyMlxcdTAxMjQtXFx1MDEyQlxcdTAxMkUtXFx1MDE0RFxcdTAxNTAtXFx1MDE3RVxcdTAxOTJcXHUwMUI1XFx1MDFGNVxcdTAyMzdcXHUwMkM2XFx1MDJDN1xcdTAyRDgtXFx1MDJERFxcdTAzMTFcXHUwMzkxLVxcdTAzQTFcXHUwM0EzLVxcdTAzQTlcXHUwM0IxLVxcdTAzQzlcXHUwM0QxXFx1MDNEMlxcdTAzRDVcXHUwM0Q2XFx1MDNEQ1xcdTAzRERcXHUwM0YwXFx1MDNGMVxcdTAzRjVcXHUwM0Y2XFx1MDQwMS1cXHUwNDBDXFx1MDQwRS1cXHUwNDRGXFx1MDQ1MS1cXHUwNDVDXFx1MDQ1RVxcdTA0NUZcXHUyMDAyLVxcdTIwMDVcXHUyMDA3LVxcdTIwMTBcXHUyMDEzLVxcdTIwMTZcXHUyMDE4LVxcdTIwMUFcXHUyMDFDLVxcdTIwMUVcXHUyMDIwLVxcdTIwMjJcXHUyMDI1XFx1MjAyNlxcdTIwMzAtXFx1MjAzNVxcdTIwMzlcXHUyMDNBXFx1MjAzRVxcdTIwNDFcXHUyMDQzXFx1MjA0NFxcdTIwNEZcXHUyMDU3XFx1MjA1Ri1cXHUyMDYzXFx1MjBBQ1xcdTIwREJcXHUyMERDXFx1MjEwMlxcdTIxMDVcXHUyMTBBLVxcdTIxMTNcXHUyMTE1LVxcdTIxMUVcXHUyMTIyXFx1MjEyNFxcdTIxMjctXFx1MjEyOVxcdTIxMkNcXHUyMTJEXFx1MjEyRi1cXHUyMTMxXFx1MjEzMy1cXHUyMTM4XFx1MjE0NS1cXHUyMTQ4XFx1MjE1My1cXHUyMTVFXFx1MjE5MC1cXHUyMTlCXFx1MjE5RC1cXHUyMUE3XFx1MjFBOS1cXHUyMUFFXFx1MjFCMC1cXHUyMUIzXFx1MjFCNS1cXHUyMUI3XFx1MjFCQS1cXHUyMURCXFx1MjFERFxcdTIxRTRcXHUyMUU1XFx1MjFGNVxcdTIxRkQtXFx1MjIwNVxcdTIyMDctXFx1MjIwOVxcdTIyMEJcXHUyMjBDXFx1MjIwRi1cXHUyMjE0XFx1MjIxNi1cXHUyMjE4XFx1MjIxQVxcdTIyMUQtXFx1MjIzOFxcdTIyM0EtXFx1MjI1N1xcdTIyNTlcXHUyMjVBXFx1MjI1Q1xcdTIyNUYtXFx1MjI2MlxcdTIyNjQtXFx1MjI4QlxcdTIyOEQtXFx1MjI5QlxcdTIyOUQtXFx1MjJBNVxcdTIyQTctXFx1MjJCMFxcdTIyQjItXFx1MjJCQlxcdTIyQkQtXFx1MjJEQlxcdTIyREUtXFx1MjJFM1xcdTIyRTYtXFx1MjJGN1xcdTIyRjktXFx1MjJGRVxcdTIzMDVcXHUyMzA2XFx1MjMwOC1cXHUyMzEwXFx1MjMxMlxcdTIzMTNcXHUyMzE1XFx1MjMxNlxcdTIzMUMtXFx1MjMxRlxcdTIzMjJcXHUyMzIzXFx1MjMyRFxcdTIzMkVcXHUyMzM2XFx1MjMzRFxcdTIzM0ZcXHUyMzdDXFx1MjNCMFxcdTIzQjFcXHUyM0I0LVxcdTIzQjZcXHUyM0RDLVxcdTIzREZcXHUyM0UyXFx1MjNFN1xcdTI0MjNcXHUyNEM4XFx1MjUwMFxcdTI1MDJcXHUyNTBDXFx1MjUxMFxcdTI1MTRcXHUyNTE4XFx1MjUxQ1xcdTI1MjRcXHUyNTJDXFx1MjUzNFxcdTI1M0NcXHUyNTUwLVxcdTI1NkNcXHUyNTgwXFx1MjU4NFxcdTI1ODhcXHUyNTkxLVxcdTI1OTNcXHUyNUExXFx1MjVBQVxcdTI1QUJcXHUyNUFEXFx1MjVBRVxcdTI1QjFcXHUyNUIzLVxcdTI1QjVcXHUyNUI4XFx1MjVCOVxcdTI1QkQtXFx1MjVCRlxcdTI1QzJcXHUyNUMzXFx1MjVDQVxcdTI1Q0JcXHUyNUVDXFx1MjVFRlxcdTI1RjgtXFx1MjVGQ1xcdTI2MDVcXHUyNjA2XFx1MjYwRVxcdTI2NDBcXHUyNjQyXFx1MjY2MFxcdTI2NjNcXHUyNjY1XFx1MjY2NlxcdTI2NkFcXHUyNjZELVxcdTI2NkZcXHUyNzEzXFx1MjcxN1xcdTI3MjBcXHUyNzM2XFx1Mjc1OFxcdTI3NzJcXHUyNzczXFx1MjdDOFxcdTI3QzlcXHUyN0U2LVxcdTI3RURcXHUyN0Y1LVxcdTI3RkFcXHUyN0ZDXFx1MjdGRlxcdTI5MDItXFx1MjkwNVxcdTI5MEMtXFx1MjkxM1xcdTI5MTZcXHUyOTE5LVxcdTI5MjBcXHUyOTIzLVxcdTI5MkFcXHUyOTMzXFx1MjkzNS1cXHUyOTM5XFx1MjkzQ1xcdTI5M0RcXHUyOTQ1XFx1Mjk0OC1cXHUyOTRCXFx1Mjk0RS1cXHUyOTc2XFx1Mjk3OFxcdTI5NzlcXHUyOTdCLVxcdTI5N0ZcXHUyOTg1XFx1Mjk4NlxcdTI5OEItXFx1Mjk5NlxcdTI5OUFcXHUyOTlDXFx1Mjk5RFxcdTI5QTQtXFx1MjlCN1xcdTI5QjlcXHUyOUJCXFx1MjlCQ1xcdTI5QkUtXFx1MjlDNVxcdTI5QzlcXHUyOUNELVxcdTI5RDBcXHUyOURDLVxcdTI5REVcXHUyOUUzLVxcdTI5RTVcXHUyOUVCXFx1MjlGNFxcdTI5RjZcXHUyQTAwLVxcdTJBMDJcXHUyQTA0XFx1MkEwNlxcdTJBMENcXHUyQTBEXFx1MkExMC1cXHUyQTE3XFx1MkEyMi1cXHUyQTI3XFx1MkEyOVxcdTJBMkFcXHUyQTJELVxcdTJBMzFcXHUyQTMzLVxcdTJBM0NcXHUyQTNGXFx1MkE0MFxcdTJBNDItXFx1MkE0RFxcdTJBNTBcXHUyQTUzLVxcdTJBNThcXHUyQTVBLVxcdTJBNURcXHUyQTVGXFx1MkE2NlxcdTJBNkFcXHUyQTZELVxcdTJBNzVcXHUyQTc3LVxcdTJBOUFcXHUyQTlELVxcdTJBQTJcXHUyQUE0LVxcdTJBQjBcXHUyQUIzLVxcdTJBQzhcXHUyQUNCXFx1MkFDQ1xcdTJBQ0YtXFx1MkFEQlxcdTJBRTRcXHUyQUU2LVxcdTJBRTlcXHUyQUVCLVxcdTJBRjNcXHUyQUZEXFx1RkIwMC1cXHVGQjA0XXxcXHVEODM1W1xcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdURDQ0ZcXHVERDA0XFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURENkJdL2c7XG5cdHZhciBlbmNvZGVNYXAgPSB7J1xceEFEJzonc2h5JywnXFx1MjAwQyc6J3p3bmonLCdcXHUyMDBEJzonendqJywnXFx1MjAwRSc6J2xybScsJ1xcdTIwNjMnOidpYycsJ1xcdTIwNjInOidpdCcsJ1xcdTIwNjEnOidhZicsJ1xcdTIwMEYnOidybG0nLCdcXHUyMDBCJzonWmVyb1dpZHRoU3BhY2UnLCdcXHUyMDYwJzonTm9CcmVhaycsJ1xcdTAzMTEnOidEb3duQnJldmUnLCdcXHUyMERCJzondGRvdCcsJ1xcdTIwREMnOidEb3REb3QnLCdcXHQnOidUYWInLCdcXG4nOidOZXdMaW5lJywnXFx1MjAwOCc6J3B1bmNzcCcsJ1xcdTIwNUYnOidNZWRpdW1TcGFjZScsJ1xcdTIwMDknOid0aGluc3AnLCdcXHUyMDBBJzonaGFpcnNwJywnXFx1MjAwNCc6J2Vtc3AxMycsJ1xcdTIwMDInOidlbnNwJywnXFx1MjAwNSc6J2Vtc3AxNCcsJ1xcdTIwMDMnOidlbXNwJywnXFx1MjAwNyc6J251bXNwJywnXFx4QTAnOiduYnNwJywnXFx1MjA1RlxcdTIwMEEnOidUaGlja1NwYWNlJywnXFx1MjAzRSc6J29saW5lJywnXyc6J2xvd2JhcicsJ1xcdTIwMTAnOidkYXNoJywnXFx1MjAxMyc6J25kYXNoJywnXFx1MjAxNCc6J21kYXNoJywnXFx1MjAxNSc6J2hvcmJhcicsJywnOidjb21tYScsJzsnOidzZW1pJywnXFx1MjA0Ric6J2JzZW1pJywnOic6J2NvbG9uJywnXFx1MkE3NCc6J0NvbG9uZScsJyEnOidleGNsJywnXFx4QTEnOidpZXhjbCcsJz8nOidxdWVzdCcsJ1xceEJGJzonaXF1ZXN0JywnLic6J3BlcmlvZCcsJ1xcdTIwMjUnOidubGRyJywnXFx1MjAyNic6J21sZHInLCdcXHhCNyc6J21pZGRvdCcsJ1xcJyc6J2Fwb3MnLCdcXHUyMDE4JzonbHNxdW8nLCdcXHUyMDE5JzoncnNxdW8nLCdcXHUyMDFBJzonc2JxdW8nLCdcXHUyMDM5JzonbHNhcXVvJywnXFx1MjAzQSc6J3JzYXF1bycsJ1wiJzoncXVvdCcsJ1xcdTIwMUMnOidsZHF1bycsJ1xcdTIwMUQnOidyZHF1bycsJ1xcdTIwMUUnOidiZHF1bycsJ1xceEFCJzonbGFxdW8nLCdcXHhCQic6J3JhcXVvJywnKCc6J2xwYXInLCcpJzoncnBhcicsJ1snOidsc3FiJywnXSc6J3JzcWInLCd7JzonbGN1YicsJ30nOidyY3ViJywnXFx1MjMwOCc6J2xjZWlsJywnXFx1MjMwOSc6J3JjZWlsJywnXFx1MjMwQSc6J2xmbG9vcicsJ1xcdTIzMEInOidyZmxvb3InLCdcXHUyOTg1JzonbG9wYXInLCdcXHUyOTg2Jzoncm9wYXInLCdcXHUyOThCJzonbGJya2UnLCdcXHUyOThDJzoncmJya2UnLCdcXHUyOThEJzonbGJya3NsdScsJ1xcdTI5OEUnOidyYnJrc2xkJywnXFx1Mjk4Ric6J2xicmtzbGQnLCdcXHUyOTkwJzoncmJya3NsdScsJ1xcdTI5OTEnOidsYW5nZCcsJ1xcdTI5OTInOidyYW5nZCcsJ1xcdTI5OTMnOidscGFybHQnLCdcXHUyOTk0JzoncnBhcmd0JywnXFx1Mjk5NSc6J2d0bFBhcicsJ1xcdTI5OTYnOidsdHJQYXInLCdcXHUyN0U2JzonbG9icmsnLCdcXHUyN0U3Jzoncm9icmsnLCdcXHUyN0U4JzonbGFuZycsJ1xcdTI3RTknOidyYW5nJywnXFx1MjdFQSc6J0xhbmcnLCdcXHUyN0VCJzonUmFuZycsJ1xcdTI3RUMnOidsb2FuZycsJ1xcdTI3RUQnOidyb2FuZycsJ1xcdTI3NzInOidsYmJyaycsJ1xcdTI3NzMnOidyYmJyaycsJ1xcdTIwMTYnOidWZXJ0JywnXFx4QTcnOidzZWN0JywnXFx4QjYnOidwYXJhJywnQCc6J2NvbW1hdCcsJyonOidhc3QnLCcvJzonc29sJywndW5kZWZpbmVkJzpudWxsLCcmJzonYW1wJywnIyc6J251bScsJyUnOidwZXJjbnQnLCdcXHUyMDMwJzoncGVybWlsJywnXFx1MjAzMSc6J3BlcnRlbmsnLCdcXHUyMDIwJzonZGFnZ2VyJywnXFx1MjAyMSc6J0RhZ2dlcicsJ1xcdTIwMjInOididWxsJywnXFx1MjA0Myc6J2h5YnVsbCcsJ1xcdTIwMzInOidwcmltZScsJ1xcdTIwMzMnOidQcmltZScsJ1xcdTIwMzQnOid0cHJpbWUnLCdcXHUyMDU3JzoncXByaW1lJywnXFx1MjAzNSc6J2JwcmltZScsJ1xcdTIwNDEnOidjYXJldCcsJ2AnOidncmF2ZScsJ1xceEI0JzonYWN1dGUnLCdcXHUwMkRDJzondGlsZGUnLCdeJzonSGF0JywnXFx4QUYnOidtYWNyJywnXFx1MDJEOCc6J2JyZXZlJywnXFx1MDJEOSc6J2RvdCcsJ1xceEE4JzonZGllJywnXFx1MDJEQSc6J3JpbmcnLCdcXHUwMkREJzonZGJsYWMnLCdcXHhCOCc6J2NlZGlsJywnXFx1MDJEQic6J29nb24nLCdcXHUwMkM2JzonY2lyYycsJ1xcdTAyQzcnOidjYXJvbicsJ1xceEIwJzonZGVnJywnXFx4QTknOidjb3B5JywnXFx4QUUnOidyZWcnLCdcXHUyMTE3JzonY29weXNyJywnXFx1MjExOCc6J3dwJywnXFx1MjExRSc6J3J4JywnXFx1MjEyNyc6J21obycsJ1xcdTIxMjknOidpaW90YScsJ1xcdTIxOTAnOidsYXJyJywnXFx1MjE5QSc6J25sYXJyJywnXFx1MjE5Mic6J3JhcnInLCdcXHUyMTlCJzonbnJhcnInLCdcXHUyMTkxJzondWFycicsJ1xcdTIxOTMnOidkYXJyJywnXFx1MjE5NCc6J2hhcnInLCdcXHUyMUFFJzonbmhhcnInLCdcXHUyMTk1JzondmFycicsJ1xcdTIxOTYnOidud2FycicsJ1xcdTIxOTcnOiduZWFycicsJ1xcdTIxOTgnOidzZWFycicsJ1xcdTIxOTknOidzd2FycicsJ1xcdTIxOUQnOidyYXJydycsJ1xcdTIxOURcXHUwMzM4JzonbnJhcnJ3JywnXFx1MjE5RSc6J0xhcnInLCdcXHUyMTlGJzonVWFycicsJ1xcdTIxQTAnOidSYXJyJywnXFx1MjFBMSc6J0RhcnInLCdcXHUyMUEyJzonbGFycnRsJywnXFx1MjFBMyc6J3JhcnJ0bCcsJ1xcdTIxQTQnOidtYXBzdG9sZWZ0JywnXFx1MjFBNSc6J21hcHN0b3VwJywnXFx1MjFBNic6J21hcCcsJ1xcdTIxQTcnOidtYXBzdG9kb3duJywnXFx1MjFBOSc6J2xhcnJoaycsJ1xcdTIxQUEnOidyYXJyaGsnLCdcXHUyMUFCJzonbGFycmxwJywnXFx1MjFBQyc6J3JhcnJscCcsJ1xcdTIxQUQnOidoYXJydycsJ1xcdTIxQjAnOidsc2gnLCdcXHUyMUIxJzoncnNoJywnXFx1MjFCMic6J2xkc2gnLCdcXHUyMUIzJzoncmRzaCcsJ1xcdTIxQjUnOidjcmFycicsJ1xcdTIxQjYnOidjdWxhcnInLCdcXHUyMUI3JzonY3VyYXJyJywnXFx1MjFCQSc6J29sYXJyJywnXFx1MjFCQic6J29yYXJyJywnXFx1MjFCQyc6J2xoYXJ1JywnXFx1MjFCRCc6J2xoYXJkJywnXFx1MjFCRSc6J3VoYXJyJywnXFx1MjFCRic6J3VoYXJsJywnXFx1MjFDMCc6J3JoYXJ1JywnXFx1MjFDMSc6J3JoYXJkJywnXFx1MjFDMic6J2RoYXJyJywnXFx1MjFDMyc6J2RoYXJsJywnXFx1MjFDNCc6J3JsYXJyJywnXFx1MjFDNSc6J3VkYXJyJywnXFx1MjFDNic6J2xyYXJyJywnXFx1MjFDNyc6J2xsYXJyJywnXFx1MjFDOCc6J3V1YXJyJywnXFx1MjFDOSc6J3JyYXJyJywnXFx1MjFDQSc6J2RkYXJyJywnXFx1MjFDQic6J2xyaGFyJywnXFx1MjFDQyc6J3JsaGFyJywnXFx1MjFEMCc6J2xBcnInLCdcXHUyMUNEJzonbmxBcnInLCdcXHUyMUQxJzondUFycicsJ1xcdTIxRDInOidyQXJyJywnXFx1MjFDRic6J25yQXJyJywnXFx1MjFEMyc6J2RBcnInLCdcXHUyMUQ0JzonaWZmJywnXFx1MjFDRSc6J25oQXJyJywnXFx1MjFENSc6J3ZBcnInLCdcXHUyMUQ2JzonbndBcnInLCdcXHUyMUQ3JzonbmVBcnInLCdcXHUyMUQ4Jzonc2VBcnInLCdcXHUyMUQ5Jzonc3dBcnInLCdcXHUyMURBJzonbEFhcnInLCdcXHUyMURCJzonckFhcnInLCdcXHUyMUREJzonemlncmFycicsJ1xcdTIxRTQnOidsYXJyYicsJ1xcdTIxRTUnOidyYXJyYicsJ1xcdTIxRjUnOidkdWFycicsJ1xcdTIxRkQnOidsb2FycicsJ1xcdTIxRkUnOidyb2FycicsJ1xcdTIxRkYnOidob2FycicsJ1xcdTIyMDAnOidmb3JhbGwnLCdcXHUyMjAxJzonY29tcCcsJ1xcdTIyMDInOidwYXJ0JywnXFx1MjIwMlxcdTAzMzgnOiducGFydCcsJ1xcdTIyMDMnOidleGlzdCcsJ1xcdTIyMDQnOiduZXhpc3QnLCdcXHUyMjA1JzonZW1wdHknLCdcXHUyMjA3JzonRGVsJywnXFx1MjIwOCc6J2luJywnXFx1MjIwOSc6J25vdGluJywnXFx1MjIwQic6J25pJywnXFx1MjIwQyc6J25vdG5pJywnXFx1MDNGNic6J2JlcHNpJywnXFx1MjIwRic6J3Byb2QnLCdcXHUyMjEwJzonY29wcm9kJywnXFx1MjIxMSc6J3N1bScsJysnOidwbHVzJywnXFx4QjEnOidwbScsJ1xceEY3JzonZGl2JywnXFx4RDcnOid0aW1lcycsJzwnOidsdCcsJ1xcdTIyNkUnOidubHQnLCc8XFx1MjBEMic6J252bHQnLCc9JzonZXF1YWxzJywnXFx1MjI2MCc6J25lJywnPVxcdTIwRTUnOidibmUnLCdcXHUyQTc1JzonRXF1YWwnLCc+JzonZ3QnLCdcXHUyMjZGJzonbmd0JywnPlxcdTIwRDInOidudmd0JywnXFx4QUMnOidub3QnLCd8JzondmVydCcsJ1xceEE2JzonYnJ2YmFyJywnXFx1MjIxMic6J21pbnVzJywnXFx1MjIxMyc6J21wJywnXFx1MjIxNCc6J3BsdXNkbycsJ1xcdTIwNDQnOidmcmFzbCcsJ1xcdTIyMTYnOidzZXRtbicsJ1xcdTIyMTcnOidsb3dhc3QnLCdcXHUyMjE4JzonY29tcGZuJywnXFx1MjIxQSc6J1NxcnQnLCdcXHUyMjFEJzoncHJvcCcsJ1xcdTIyMUUnOidpbmZpbicsJ1xcdTIyMUYnOidhbmdydCcsJ1xcdTIyMjAnOidhbmcnLCdcXHUyMjIwXFx1MjBEMic6J25hbmcnLCdcXHUyMjIxJzonYW5nbXNkJywnXFx1MjIyMic6J2FuZ3NwaCcsJ1xcdTIyMjMnOidtaWQnLCdcXHUyMjI0Jzonbm1pZCcsJ1xcdTIyMjUnOidwYXInLCdcXHUyMjI2JzonbnBhcicsJ1xcdTIyMjcnOidhbmQnLCdcXHUyMjI4Jzonb3InLCdcXHUyMjI5JzonY2FwJywnXFx1MjIyOVxcdUZFMDAnOidjYXBzJywnXFx1MjIyQSc6J2N1cCcsJ1xcdTIyMkFcXHVGRTAwJzonY3VwcycsJ1xcdTIyMkInOidpbnQnLCdcXHUyMjJDJzonSW50JywnXFx1MjIyRCc6J3RpbnQnLCdcXHUyQTBDJzoncWludCcsJ1xcdTIyMkUnOidvaW50JywnXFx1MjIyRic6J0NvbmludCcsJ1xcdTIyMzAnOidDY29uaW50JywnXFx1MjIzMSc6J2N3aW50JywnXFx1MjIzMic6J2N3Y29uaW50JywnXFx1MjIzMyc6J2F3Y29uaW50JywnXFx1MjIzNCc6J3RoZXJlNCcsJ1xcdTIyMzUnOidiZWNhdXMnLCdcXHUyMjM2JzoncmF0aW8nLCdcXHUyMjM3JzonQ29sb24nLCdcXHUyMjM4JzonbWludXNkJywnXFx1MjIzQSc6J21ERG90JywnXFx1MjIzQic6J2hvbXRodCcsJ1xcdTIyM0MnOidzaW0nLCdcXHUyMjQxJzonbnNpbScsJ1xcdTIyM0NcXHUyMEQyJzonbnZzaW0nLCdcXHUyMjNEJzonYnNpbScsJ1xcdTIyM0RcXHUwMzMxJzoncmFjZScsJ1xcdTIyM0UnOidhYycsJ1xcdTIyM0VcXHUwMzMzJzonYWNFJywnXFx1MjIzRic6J2FjZCcsJ1xcdTIyNDAnOid3cicsJ1xcdTIyNDInOidlc2ltJywnXFx1MjI0MlxcdTAzMzgnOiduZXNpbScsJ1xcdTIyNDMnOidzaW1lJywnXFx1MjI0NCc6J25zaW1lJywnXFx1MjI0NSc6J2NvbmcnLCdcXHUyMjQ3JzonbmNvbmcnLCdcXHUyMjQ2Jzonc2ltbmUnLCdcXHUyMjQ4JzonYXAnLCdcXHUyMjQ5JzonbmFwJywnXFx1MjI0QSc6J2FwZScsJ1xcdTIyNEInOidhcGlkJywnXFx1MjI0QlxcdTAzMzgnOiduYXBpZCcsJ1xcdTIyNEMnOidiY29uZycsJ1xcdTIyNEQnOidDdXBDYXAnLCdcXHUyMjZEJzonTm90Q3VwQ2FwJywnXFx1MjI0RFxcdTIwRDInOidudmFwJywnXFx1MjI0RSc6J2J1bXAnLCdcXHUyMjRFXFx1MDMzOCc6J25idW1wJywnXFx1MjI0Ric6J2J1bXBlJywnXFx1MjI0RlxcdTAzMzgnOiduYnVtcGUnLCdcXHUyMjUwJzonZG90ZXEnLCdcXHUyMjUwXFx1MDMzOCc6J25lZG90JywnXFx1MjI1MSc6J2VEb3QnLCdcXHUyMjUyJzonZWZEb3QnLCdcXHUyMjUzJzonZXJEb3QnLCdcXHUyMjU0JzonY29sb25lJywnXFx1MjI1NSc6J2Vjb2xvbicsJ1xcdTIyNTYnOidlY2lyJywnXFx1MjI1Nyc6J2NpcmUnLCdcXHUyMjU5Jzond2VkZ2VxJywnXFx1MjI1QSc6J3ZlZWVxJywnXFx1MjI1Qyc6J3RyaWUnLCdcXHUyMjVGJzonZXF1ZXN0JywnXFx1MjI2MSc6J2VxdWl2JywnXFx1MjI2Mic6J25lcXVpdicsJ1xcdTIyNjFcXHUyMEU1JzonYm5lcXVpdicsJ1xcdTIyNjQnOidsZScsJ1xcdTIyNzAnOidubGUnLCdcXHUyMjY0XFx1MjBEMic6J252bGUnLCdcXHUyMjY1JzonZ2UnLCdcXHUyMjcxJzonbmdlJywnXFx1MjI2NVxcdTIwRDInOidudmdlJywnXFx1MjI2Nic6J2xFJywnXFx1MjI2NlxcdTAzMzgnOidubEUnLCdcXHUyMjY3JzonZ0UnLCdcXHUyMjY3XFx1MDMzOCc6J25nRScsJ1xcdTIyNjhcXHVGRTAwJzonbHZuRScsJ1xcdTIyNjgnOidsbkUnLCdcXHUyMjY5JzonZ25FJywnXFx1MjI2OVxcdUZFMDAnOidndm5FJywnXFx1MjI2QSc6J2xsJywnXFx1MjI2QVxcdTAzMzgnOiduTHR2JywnXFx1MjI2QVxcdTIwRDInOiduTHQnLCdcXHUyMjZCJzonZ2cnLCdcXHUyMjZCXFx1MDMzOCc6J25HdHYnLCdcXHUyMjZCXFx1MjBEMic6J25HdCcsJ1xcdTIyNkMnOid0d2l4dCcsJ1xcdTIyNzInOidsc2ltJywnXFx1MjI3NCc6J25sc2ltJywnXFx1MjI3Myc6J2dzaW0nLCdcXHUyMjc1JzonbmdzaW0nLCdcXHUyMjc2JzonbGcnLCdcXHUyMjc4JzonbnRsZycsJ1xcdTIyNzcnOidnbCcsJ1xcdTIyNzknOidudGdsJywnXFx1MjI3QSc6J3ByJywnXFx1MjI4MCc6J25wcicsJ1xcdTIyN0InOidzYycsJ1xcdTIyODEnOiduc2MnLCdcXHUyMjdDJzoncHJjdWUnLCdcXHUyMkUwJzonbnByY3VlJywnXFx1MjI3RCc6J3NjY3VlJywnXFx1MjJFMSc6J25zY2N1ZScsJ1xcdTIyN0UnOidwcnNpbScsJ1xcdTIyN0YnOidzY3NpbScsJ1xcdTIyN0ZcXHUwMzM4JzonTm90U3VjY2VlZHNUaWxkZScsJ1xcdTIyODInOidzdWInLCdcXHUyMjg0JzonbnN1YicsJ1xcdTIyODJcXHUyMEQyJzondm5zdWInLCdcXHUyMjgzJzonc3VwJywnXFx1MjI4NSc6J25zdXAnLCdcXHUyMjgzXFx1MjBEMic6J3Zuc3VwJywnXFx1MjI4Nic6J3N1YmUnLCdcXHUyMjg4JzonbnN1YmUnLCdcXHUyMjg3Jzonc3VwZScsJ1xcdTIyODknOiduc3VwZScsJ1xcdTIyOEFcXHVGRTAwJzondnN1Ym5lJywnXFx1MjI4QSc6J3N1Ym5lJywnXFx1MjI4QlxcdUZFMDAnOid2c3VwbmUnLCdcXHUyMjhCJzonc3VwbmUnLCdcXHUyMjhEJzonY3VwZG90JywnXFx1MjI4RSc6J3VwbHVzJywnXFx1MjI4Ric6J3Nxc3ViJywnXFx1MjI4RlxcdTAzMzgnOidOb3RTcXVhcmVTdWJzZXQnLCdcXHUyMjkwJzonc3FzdXAnLCdcXHUyMjkwXFx1MDMzOCc6J05vdFNxdWFyZVN1cGVyc2V0JywnXFx1MjI5MSc6J3Nxc3ViZScsJ1xcdTIyRTInOiduc3FzdWJlJywnXFx1MjI5Mic6J3Nxc3VwZScsJ1xcdTIyRTMnOiduc3FzdXBlJywnXFx1MjI5Myc6J3NxY2FwJywnXFx1MjI5M1xcdUZFMDAnOidzcWNhcHMnLCdcXHUyMjk0Jzonc3FjdXAnLCdcXHUyMjk0XFx1RkUwMCc6J3NxY3VwcycsJ1xcdTIyOTUnOidvcGx1cycsJ1xcdTIyOTYnOidvbWludXMnLCdcXHUyMjk3Jzonb3RpbWVzJywnXFx1MjI5OCc6J29zb2wnLCdcXHUyMjk5Jzonb2RvdCcsJ1xcdTIyOUEnOidvY2lyJywnXFx1MjI5Qic6J29hc3QnLCdcXHUyMjlEJzonb2Rhc2gnLCdcXHUyMjlFJzoncGx1c2InLCdcXHUyMjlGJzonbWludXNiJywnXFx1MjJBMCc6J3RpbWVzYicsJ1xcdTIyQTEnOidzZG90YicsJ1xcdTIyQTInOid2ZGFzaCcsJ1xcdTIyQUMnOidudmRhc2gnLCdcXHUyMkEzJzonZGFzaHYnLCdcXHUyMkE0JzondG9wJywnXFx1MjJBNSc6J2JvdCcsJ1xcdTIyQTcnOidtb2RlbHMnLCdcXHUyMkE4JzondkRhc2gnLCdcXHUyMkFEJzonbnZEYXNoJywnXFx1MjJBOSc6J1ZkYXNoJywnXFx1MjJBRSc6J25WZGFzaCcsJ1xcdTIyQUEnOidWdmRhc2gnLCdcXHUyMkFCJzonVkRhc2gnLCdcXHUyMkFGJzonblZEYXNoJywnXFx1MjJCMCc6J3BydXJlbCcsJ1xcdTIyQjInOid2bHRyaScsJ1xcdTIyRUEnOidubHRyaScsJ1xcdTIyQjMnOid2cnRyaScsJ1xcdTIyRUInOiducnRyaScsJ1xcdTIyQjQnOidsdHJpZScsJ1xcdTIyRUMnOidubHRyaWUnLCdcXHUyMkI0XFx1MjBEMic6J252bHRyaWUnLCdcXHUyMkI1JzoncnRyaWUnLCdcXHUyMkVEJzonbnJ0cmllJywnXFx1MjJCNVxcdTIwRDInOidudnJ0cmllJywnXFx1MjJCNic6J29yaWdvZicsJ1xcdTIyQjcnOidpbW9mJywnXFx1MjJCOCc6J211bWFwJywnXFx1MjJCOSc6J2hlcmNvbicsJ1xcdTIyQkEnOidpbnRjYWwnLCdcXHUyMkJCJzondmVlYmFyJywnXFx1MjJCRCc6J2JhcnZlZScsJ1xcdTIyQkUnOidhbmdydHZiJywnXFx1MjJCRic6J2xydHJpJywnXFx1MjJDMCc6J1dlZGdlJywnXFx1MjJDMSc6J1ZlZScsJ1xcdTIyQzInOid4Y2FwJywnXFx1MjJDMyc6J3hjdXAnLCdcXHUyMkM0JzonZGlhbScsJ1xcdTIyQzUnOidzZG90JywnXFx1MjJDNic6J1N0YXInLCdcXHUyMkM3JzonZGl2b254JywnXFx1MjJDOCc6J2Jvd3RpZScsJ1xcdTIyQzknOidsdGltZXMnLCdcXHUyMkNBJzoncnRpbWVzJywnXFx1MjJDQic6J2x0aHJlZScsJ1xcdTIyQ0MnOidydGhyZWUnLCdcXHUyMkNEJzonYnNpbWUnLCdcXHUyMkNFJzonY3V2ZWUnLCdcXHUyMkNGJzonY3V3ZWQnLCdcXHUyMkQwJzonU3ViJywnXFx1MjJEMSc6J1N1cCcsJ1xcdTIyRDInOidDYXAnLCdcXHUyMkQzJzonQ3VwJywnXFx1MjJENCc6J2ZvcmsnLCdcXHUyMkQ1JzonZXBhcicsJ1xcdTIyRDYnOidsdGRvdCcsJ1xcdTIyRDcnOidndGRvdCcsJ1xcdTIyRDgnOidMbCcsJ1xcdTIyRDhcXHUwMzM4JzonbkxsJywnXFx1MjJEOSc6J0dnJywnXFx1MjJEOVxcdTAzMzgnOiduR2cnLCdcXHUyMkRBXFx1RkUwMCc6J2xlc2cnLCdcXHUyMkRBJzonbGVnJywnXFx1MjJEQic6J2dlbCcsJ1xcdTIyREJcXHVGRTAwJzonZ2VzbCcsJ1xcdTIyREUnOidjdWVwcicsJ1xcdTIyREYnOidjdWVzYycsJ1xcdTIyRTYnOidsbnNpbScsJ1xcdTIyRTcnOidnbnNpbScsJ1xcdTIyRTgnOidwcm5zaW0nLCdcXHUyMkU5Jzonc2Nuc2ltJywnXFx1MjJFRSc6J3ZlbGxpcCcsJ1xcdTIyRUYnOidjdGRvdCcsJ1xcdTIyRjAnOid1dGRvdCcsJ1xcdTIyRjEnOidkdGRvdCcsJ1xcdTIyRjInOidkaXNpbicsJ1xcdTIyRjMnOidpc2luc3YnLCdcXHUyMkY0JzonaXNpbnMnLCdcXHUyMkY1JzonaXNpbmRvdCcsJ1xcdTIyRjVcXHUwMzM4Jzonbm90aW5kb3QnLCdcXHUyMkY2Jzonbm90aW52YycsJ1xcdTIyRjcnOidub3RpbnZiJywnXFx1MjJGOSc6J2lzaW5FJywnXFx1MjJGOVxcdTAzMzgnOidub3RpbkUnLCdcXHUyMkZBJzonbmlzZCcsJ1xcdTIyRkInOid4bmlzJywnXFx1MjJGQyc6J25pcycsJ1xcdTIyRkQnOidub3RuaXZjJywnXFx1MjJGRSc6J25vdG5pdmInLCdcXHUyMzA1JzonYmFyd2VkJywnXFx1MjMwNic6J0JhcndlZCcsJ1xcdTIzMEMnOidkcmNyb3AnLCdcXHUyMzBEJzonZGxjcm9wJywnXFx1MjMwRSc6J3VyY3JvcCcsJ1xcdTIzMEYnOid1bGNyb3AnLCdcXHUyMzEwJzonYm5vdCcsJ1xcdTIzMTInOidwcm9mbGluZScsJ1xcdTIzMTMnOidwcm9mc3VyZicsJ1xcdTIzMTUnOid0ZWxyZWMnLCdcXHUyMzE2JzondGFyZ2V0JywnXFx1MjMxQyc6J3VsY29ybicsJ1xcdTIzMUQnOid1cmNvcm4nLCdcXHUyMzFFJzonZGxjb3JuJywnXFx1MjMxRic6J2RyY29ybicsJ1xcdTIzMjInOidmcm93bicsJ1xcdTIzMjMnOidzbWlsZScsJ1xcdTIzMkQnOidjeWxjdHknLCdcXHUyMzJFJzoncHJvZmFsYXInLCdcXHUyMzM2JzondG9wYm90JywnXFx1MjMzRCc6J292YmFyJywnXFx1MjMzRic6J3NvbGJhcicsJ1xcdTIzN0MnOidhbmd6YXJyJywnXFx1MjNCMCc6J2xtb3VzdCcsJ1xcdTIzQjEnOidybW91c3QnLCdcXHUyM0I0JzondGJyaycsJ1xcdTIzQjUnOidiYnJrJywnXFx1MjNCNic6J2Jicmt0YnJrJywnXFx1MjNEQyc6J092ZXJQYXJlbnRoZXNpcycsJ1xcdTIzREQnOidVbmRlclBhcmVudGhlc2lzJywnXFx1MjNERSc6J092ZXJCcmFjZScsJ1xcdTIzREYnOidVbmRlckJyYWNlJywnXFx1MjNFMic6J3RycGV6aXVtJywnXFx1MjNFNyc6J2VsaW50ZXJzJywnXFx1MjQyMyc6J2JsYW5rJywnXFx1MjUwMCc6J2JveGgnLCdcXHUyNTAyJzonYm94dicsJ1xcdTI1MEMnOidib3hkcicsJ1xcdTI1MTAnOidib3hkbCcsJ1xcdTI1MTQnOidib3h1cicsJ1xcdTI1MTgnOidib3h1bCcsJ1xcdTI1MUMnOidib3h2cicsJ1xcdTI1MjQnOidib3h2bCcsJ1xcdTI1MkMnOidib3hoZCcsJ1xcdTI1MzQnOidib3hodScsJ1xcdTI1M0MnOidib3h2aCcsJ1xcdTI1NTAnOidib3hIJywnXFx1MjU1MSc6J2JveFYnLCdcXHUyNTUyJzonYm94ZFInLCdcXHUyNTUzJzonYm94RHInLCdcXHUyNTU0JzonYm94RFInLCdcXHUyNTU1JzonYm94ZEwnLCdcXHUyNTU2JzonYm94RGwnLCdcXHUyNTU3JzonYm94REwnLCdcXHUyNTU4JzonYm94dVInLCdcXHUyNTU5JzonYm94VXInLCdcXHUyNTVBJzonYm94VVInLCdcXHUyNTVCJzonYm94dUwnLCdcXHUyNTVDJzonYm94VWwnLCdcXHUyNTVEJzonYm94VUwnLCdcXHUyNTVFJzonYm94dlInLCdcXHUyNTVGJzonYm94VnInLCdcXHUyNTYwJzonYm94VlInLCdcXHUyNTYxJzonYm94dkwnLCdcXHUyNTYyJzonYm94VmwnLCdcXHUyNTYzJzonYm94VkwnLCdcXHUyNTY0JzonYm94SGQnLCdcXHUyNTY1JzonYm94aEQnLCdcXHUyNTY2JzonYm94SEQnLCdcXHUyNTY3JzonYm94SHUnLCdcXHUyNTY4JzonYm94aFUnLCdcXHUyNTY5JzonYm94SFUnLCdcXHUyNTZBJzonYm94dkgnLCdcXHUyNTZCJzonYm94VmgnLCdcXHUyNTZDJzonYm94VkgnLCdcXHUyNTgwJzondWhibGsnLCdcXHUyNTg0JzonbGhibGsnLCdcXHUyNTg4JzonYmxvY2snLCdcXHUyNTkxJzonYmxrMTQnLCdcXHUyNTkyJzonYmxrMTInLCdcXHUyNTkzJzonYmxrMzQnLCdcXHUyNUExJzonc3F1JywnXFx1MjVBQSc6J3NxdWYnLCdcXHUyNUFCJzonRW1wdHlWZXJ5U21hbGxTcXVhcmUnLCdcXHUyNUFEJzoncmVjdCcsJ1xcdTI1QUUnOidtYXJrZXInLCdcXHUyNUIxJzonZmx0bnMnLCdcXHUyNUIzJzoneHV0cmknLCdcXHUyNUI0JzondXRyaWYnLCdcXHUyNUI1JzondXRyaScsJ1xcdTI1QjgnOidydHJpZicsJ1xcdTI1QjknOidydHJpJywnXFx1MjVCRCc6J3hkdHJpJywnXFx1MjVCRSc6J2R0cmlmJywnXFx1MjVCRic6J2R0cmknLCdcXHUyNUMyJzonbHRyaWYnLCdcXHUyNUMzJzonbHRyaScsJ1xcdTI1Q0EnOidsb3onLCdcXHUyNUNCJzonY2lyJywnXFx1MjVFQyc6J3RyaWRvdCcsJ1xcdTI1RUYnOid4Y2lyYycsJ1xcdTI1RjgnOid1bHRyaScsJ1xcdTI1RjknOid1cnRyaScsJ1xcdTI1RkEnOidsbHRyaScsJ1xcdTI1RkInOidFbXB0eVNtYWxsU3F1YXJlJywnXFx1MjVGQyc6J0ZpbGxlZFNtYWxsU3F1YXJlJywnXFx1MjYwNSc6J3N0YXJmJywnXFx1MjYwNic6J3N0YXInLCdcXHUyNjBFJzoncGhvbmUnLCdcXHUyNjQwJzonZmVtYWxlJywnXFx1MjY0Mic6J21hbGUnLCdcXHUyNjYwJzonc3BhZGVzJywnXFx1MjY2Myc6J2NsdWJzJywnXFx1MjY2NSc6J2hlYXJ0cycsJ1xcdTI2NjYnOidkaWFtcycsJ1xcdTI2NkEnOidzdW5nJywnXFx1MjcxMyc6J2NoZWNrJywnXFx1MjcxNyc6J2Nyb3NzJywnXFx1MjcyMCc6J21hbHQnLCdcXHUyNzM2Jzonc2V4dCcsJ1xcdTI3NTgnOidWZXJ0aWNhbFNlcGFyYXRvcicsJ1xcdTI3QzgnOidic29saHN1YicsJ1xcdTI3QzknOidzdXBoc29sJywnXFx1MjdGNSc6J3hsYXJyJywnXFx1MjdGNic6J3hyYXJyJywnXFx1MjdGNyc6J3hoYXJyJywnXFx1MjdGOCc6J3hsQXJyJywnXFx1MjdGOSc6J3hyQXJyJywnXFx1MjdGQSc6J3hoQXJyJywnXFx1MjdGQyc6J3htYXAnLCdcXHUyN0ZGJzonZHppZ3JhcnInLCdcXHUyOTAyJzonbnZsQXJyJywnXFx1MjkwMyc6J252ckFycicsJ1xcdTI5MDQnOidudkhhcnInLCdcXHUyOTA1JzonTWFwJywnXFx1MjkwQyc6J2xiYXJyJywnXFx1MjkwRCc6J3JiYXJyJywnXFx1MjkwRSc6J2xCYXJyJywnXFx1MjkwRic6J3JCYXJyJywnXFx1MjkxMCc6J1JCYXJyJywnXFx1MjkxMSc6J0REb3RyYWhkJywnXFx1MjkxMic6J1VwQXJyb3dCYXInLCdcXHUyOTEzJzonRG93bkFycm93QmFyJywnXFx1MjkxNic6J1JhcnJ0bCcsJ1xcdTI5MTknOidsYXRhaWwnLCdcXHUyOTFBJzoncmF0YWlsJywnXFx1MjkxQic6J2xBdGFpbCcsJ1xcdTI5MUMnOidyQXRhaWwnLCdcXHUyOTFEJzonbGFycmZzJywnXFx1MjkxRSc6J3JhcnJmcycsJ1xcdTI5MUYnOidsYXJyYmZzJywnXFx1MjkyMCc6J3JhcnJiZnMnLCdcXHUyOTIzJzonbndhcmhrJywnXFx1MjkyNCc6J25lYXJoaycsJ1xcdTI5MjUnOidzZWFyaGsnLCdcXHUyOTI2Jzonc3dhcmhrJywnXFx1MjkyNyc6J253bmVhcicsJ1xcdTI5MjgnOid0b2VhJywnXFx1MjkyOSc6J3Rvc2EnLCdcXHUyOTJBJzonc3dud2FyJywnXFx1MjkzMyc6J3JhcnJjJywnXFx1MjkzM1xcdTAzMzgnOiducmFycmMnLCdcXHUyOTM1JzonY3VkYXJycicsJ1xcdTI5MzYnOidsZGNhJywnXFx1MjkzNyc6J3JkY2EnLCdcXHUyOTM4JzonY3VkYXJybCcsJ1xcdTI5MzknOidsYXJycGwnLCdcXHUyOTNDJzonY3VyYXJybScsJ1xcdTI5M0QnOidjdWxhcnJwJywnXFx1Mjk0NSc6J3JhcnJwbCcsJ1xcdTI5NDgnOidoYXJyY2lyJywnXFx1Mjk0OSc6J1VhcnJvY2lyJywnXFx1Mjk0QSc6J2x1cmRzaGFyJywnXFx1Mjk0Qic6J2xkcnVzaGFyJywnXFx1Mjk0RSc6J0xlZnRSaWdodFZlY3RvcicsJ1xcdTI5NEYnOidSaWdodFVwRG93blZlY3RvcicsJ1xcdTI5NTAnOidEb3duTGVmdFJpZ2h0VmVjdG9yJywnXFx1Mjk1MSc6J0xlZnRVcERvd25WZWN0b3InLCdcXHUyOTUyJzonTGVmdFZlY3RvckJhcicsJ1xcdTI5NTMnOidSaWdodFZlY3RvckJhcicsJ1xcdTI5NTQnOidSaWdodFVwVmVjdG9yQmFyJywnXFx1Mjk1NSc6J1JpZ2h0RG93blZlY3RvckJhcicsJ1xcdTI5NTYnOidEb3duTGVmdFZlY3RvckJhcicsJ1xcdTI5NTcnOidEb3duUmlnaHRWZWN0b3JCYXInLCdcXHUyOTU4JzonTGVmdFVwVmVjdG9yQmFyJywnXFx1Mjk1OSc6J0xlZnREb3duVmVjdG9yQmFyJywnXFx1Mjk1QSc6J0xlZnRUZWVWZWN0b3InLCdcXHUyOTVCJzonUmlnaHRUZWVWZWN0b3InLCdcXHUyOTVDJzonUmlnaHRVcFRlZVZlY3RvcicsJ1xcdTI5NUQnOidSaWdodERvd25UZWVWZWN0b3InLCdcXHUyOTVFJzonRG93bkxlZnRUZWVWZWN0b3InLCdcXHUyOTVGJzonRG93blJpZ2h0VGVlVmVjdG9yJywnXFx1Mjk2MCc6J0xlZnRVcFRlZVZlY3RvcicsJ1xcdTI5NjEnOidMZWZ0RG93blRlZVZlY3RvcicsJ1xcdTI5NjInOidsSGFyJywnXFx1Mjk2Myc6J3VIYXInLCdcXHUyOTY0JzonckhhcicsJ1xcdTI5NjUnOidkSGFyJywnXFx1Mjk2Nic6J2x1cnVoYXInLCdcXHUyOTY3JzonbGRyZGhhcicsJ1xcdTI5NjgnOidydWx1aGFyJywnXFx1Mjk2OSc6J3JkbGRoYXInLCdcXHUyOTZBJzonbGhhcnVsJywnXFx1Mjk2Qic6J2xsaGFyZCcsJ1xcdTI5NkMnOidyaGFydWwnLCdcXHUyOTZEJzonbHJoYXJkJywnXFx1Mjk2RSc6J3VkaGFyJywnXFx1Mjk2Ric6J2R1aGFyJywnXFx1Mjk3MCc6J1JvdW5kSW1wbGllcycsJ1xcdTI5NzEnOidlcmFycicsJ1xcdTI5NzInOidzaW1yYXJyJywnXFx1Mjk3Myc6J2xhcnJzaW0nLCdcXHUyOTc0JzoncmFycnNpbScsJ1xcdTI5NzUnOidyYXJyYXAnLCdcXHUyOTc2JzonbHRsYXJyJywnXFx1Mjk3OCc6J2d0cmFycicsJ1xcdTI5NzknOidzdWJyYXJyJywnXFx1Mjk3Qic6J3N1cGxhcnInLCdcXHUyOTdDJzonbGZpc2h0JywnXFx1Mjk3RCc6J3JmaXNodCcsJ1xcdTI5N0UnOid1ZmlzaHQnLCdcXHUyOTdGJzonZGZpc2h0JywnXFx1Mjk5QSc6J3Z6aWd6YWcnLCdcXHUyOTlDJzondmFuZ3J0JywnXFx1Mjk5RCc6J2FuZ3J0dmJkJywnXFx1MjlBNCc6J2FuZ2UnLCdcXHUyOUE1JzoncmFuZ2UnLCdcXHUyOUE2JzonZHdhbmdsZScsJ1xcdTI5QTcnOid1d2FuZ2xlJywnXFx1MjlBOCc6J2FuZ21zZGFhJywnXFx1MjlBOSc6J2FuZ21zZGFiJywnXFx1MjlBQSc6J2FuZ21zZGFjJywnXFx1MjlBQic6J2FuZ21zZGFkJywnXFx1MjlBQyc6J2FuZ21zZGFlJywnXFx1MjlBRCc6J2FuZ21zZGFmJywnXFx1MjlBRSc6J2FuZ21zZGFnJywnXFx1MjlBRic6J2FuZ21zZGFoJywnXFx1MjlCMCc6J2JlbXB0eXYnLCdcXHUyOUIxJzonZGVtcHR5dicsJ1xcdTI5QjInOidjZW1wdHl2JywnXFx1MjlCMyc6J3JhZW1wdHl2JywnXFx1MjlCNCc6J2xhZW1wdHl2JywnXFx1MjlCNSc6J29oYmFyJywnXFx1MjlCNic6J29taWQnLCdcXHUyOUI3Jzonb3BhcicsJ1xcdTI5QjknOidvcGVycCcsJ1xcdTI5QkInOidvbGNyb3NzJywnXFx1MjlCQyc6J29kc29sZCcsJ1xcdTI5QkUnOidvbGNpcicsJ1xcdTI5QkYnOidvZmNpcicsJ1xcdTI5QzAnOidvbHQnLCdcXHUyOUMxJzonb2d0JywnXFx1MjlDMic6J2NpcnNjaXInLCdcXHUyOUMzJzonY2lyRScsJ1xcdTI5QzQnOidzb2xiJywnXFx1MjlDNSc6J2Jzb2xiJywnXFx1MjlDOSc6J2JveGJveCcsJ1xcdTI5Q0QnOid0cmlzYicsJ1xcdTI5Q0UnOidydHJpbHRyaScsJ1xcdTI5Q0YnOidMZWZ0VHJpYW5nbGVCYXInLCdcXHUyOUNGXFx1MDMzOCc6J05vdExlZnRUcmlhbmdsZUJhcicsJ1xcdTI5RDAnOidSaWdodFRyaWFuZ2xlQmFyJywnXFx1MjlEMFxcdTAzMzgnOidOb3RSaWdodFRyaWFuZ2xlQmFyJywnXFx1MjlEQyc6J2lpbmZpbicsJ1xcdTI5REQnOidpbmZpbnRpZScsJ1xcdTI5REUnOidudmluZmluJywnXFx1MjlFMyc6J2VwYXJzbCcsJ1xcdTI5RTQnOidzbWVwYXJzbCcsJ1xcdTI5RTUnOidlcXZwYXJzbCcsJ1xcdTI5RUInOidsb3pmJywnXFx1MjlGNCc6J1J1bGVEZWxheWVkJywnXFx1MjlGNic6J2Rzb2wnLCdcXHUyQTAwJzoneG9kb3QnLCdcXHUyQTAxJzoneG9wbHVzJywnXFx1MkEwMic6J3hvdGltZScsJ1xcdTJBMDQnOid4dXBsdXMnLCdcXHUyQTA2JzoneHNxY3VwJywnXFx1MkEwRCc6J2ZwYXJ0aW50JywnXFx1MkExMCc6J2NpcmZuaW50JywnXFx1MkExMSc6J2F3aW50JywnXFx1MkExMic6J3JwcG9saW50JywnXFx1MkExMyc6J3NjcG9saW50JywnXFx1MkExNCc6J25wb2xpbnQnLCdcXHUyQTE1JzoncG9pbnRpbnQnLCdcXHUyQTE2JzoncXVhdGludCcsJ1xcdTJBMTcnOidpbnRsYXJoaycsJ1xcdTJBMjInOidwbHVzY2lyJywnXFx1MkEyMyc6J3BsdXNhY2lyJywnXFx1MkEyNCc6J3NpbXBsdXMnLCdcXHUyQTI1JzoncGx1c2R1JywnXFx1MkEyNic6J3BsdXNzaW0nLCdcXHUyQTI3JzoncGx1c3R3bycsJ1xcdTJBMjknOidtY29tbWEnLCdcXHUyQTJBJzonbWludXNkdScsJ1xcdTJBMkQnOidsb3BsdXMnLCdcXHUyQTJFJzoncm9wbHVzJywnXFx1MkEyRic6J0Nyb3NzJywnXFx1MkEzMCc6J3RpbWVzZCcsJ1xcdTJBMzEnOid0aW1lc2JhcicsJ1xcdTJBMzMnOidzbWFzaHAnLCdcXHUyQTM0JzonbG90aW1lcycsJ1xcdTJBMzUnOidyb3RpbWVzJywnXFx1MkEzNic6J290aW1lc2FzJywnXFx1MkEzNyc6J090aW1lcycsJ1xcdTJBMzgnOidvZGl2JywnXFx1MkEzOSc6J3RyaXBsdXMnLCdcXHUyQTNBJzondHJpbWludXMnLCdcXHUyQTNCJzondHJpdGltZScsJ1xcdTJBM0MnOidpcHJvZCcsJ1xcdTJBM0YnOidhbWFsZycsJ1xcdTJBNDAnOidjYXBkb3QnLCdcXHUyQTQyJzonbmN1cCcsJ1xcdTJBNDMnOiduY2FwJywnXFx1MkE0NCc6J2NhcGFuZCcsJ1xcdTJBNDUnOidjdXBvcicsJ1xcdTJBNDYnOidjdXBjYXAnLCdcXHUyQTQ3JzonY2FwY3VwJywnXFx1MkE0OCc6J2N1cGJyY2FwJywnXFx1MkE0OSc6J2NhcGJyY3VwJywnXFx1MkE0QSc6J2N1cGN1cCcsJ1xcdTJBNEInOidjYXBjYXAnLCdcXHUyQTRDJzonY2N1cHMnLCdcXHUyQTREJzonY2NhcHMnLCdcXHUyQTUwJzonY2N1cHNzbScsJ1xcdTJBNTMnOidBbmQnLCdcXHUyQTU0JzonT3InLCdcXHUyQTU1JzonYW5kYW5kJywnXFx1MkE1Nic6J29yb3InLCdcXHUyQTU3Jzonb3JzbG9wZScsJ1xcdTJBNTgnOidhbmRzbG9wZScsJ1xcdTJBNUEnOidhbmR2JywnXFx1MkE1Qic6J29ydicsJ1xcdTJBNUMnOidhbmRkJywnXFx1MkE1RCc6J29yZCcsJ1xcdTJBNUYnOid3ZWRiYXInLCdcXHUyQTY2Jzonc2RvdGUnLCdcXHUyQTZBJzonc2ltZG90JywnXFx1MkE2RCc6J2Nvbmdkb3QnLCdcXHUyQTZEXFx1MDMzOCc6J25jb25nZG90JywnXFx1MkE2RSc6J2Vhc3RlcicsJ1xcdTJBNkYnOidhcGFjaXInLCdcXHUyQTcwJzonYXBFJywnXFx1MkE3MFxcdTAzMzgnOiduYXBFJywnXFx1MkE3MSc6J2VwbHVzJywnXFx1MkE3Mic6J3BsdXNlJywnXFx1MkE3Myc6J0VzaW0nLCdcXHUyQTc3JzonZUREb3QnLCdcXHUyQTc4JzonZXF1aXZERCcsJ1xcdTJBNzknOidsdGNpcicsJ1xcdTJBN0EnOidndGNpcicsJ1xcdTJBN0InOidsdHF1ZXN0JywnXFx1MkE3Qyc6J2d0cXVlc3QnLCdcXHUyQTdEJzonbGVzJywnXFx1MkE3RFxcdTAzMzgnOidubGVzJywnXFx1MkE3RSc6J2dlcycsJ1xcdTJBN0VcXHUwMzM4JzonbmdlcycsJ1xcdTJBN0YnOidsZXNkb3QnLCdcXHUyQTgwJzonZ2VzZG90JywnXFx1MkE4MSc6J2xlc2RvdG8nLCdcXHUyQTgyJzonZ2VzZG90bycsJ1xcdTJBODMnOidsZXNkb3RvcicsJ1xcdTJBODQnOidnZXNkb3RvbCcsJ1xcdTJBODUnOidsYXAnLCdcXHUyQTg2JzonZ2FwJywnXFx1MkE4Nyc6J2xuZScsJ1xcdTJBODgnOidnbmUnLCdcXHUyQTg5JzonbG5hcCcsJ1xcdTJBOEEnOidnbmFwJywnXFx1MkE4Qic6J2xFZycsJ1xcdTJBOEMnOidnRWwnLCdcXHUyQThEJzonbHNpbWUnLCdcXHUyQThFJzonZ3NpbWUnLCdcXHUyQThGJzonbHNpbWcnLCdcXHUyQTkwJzonZ3NpbWwnLCdcXHUyQTkxJzonbGdFJywnXFx1MkE5Mic6J2dsRScsJ1xcdTJBOTMnOidsZXNnZXMnLCdcXHUyQTk0JzonZ2VzbGVzJywnXFx1MkE5NSc6J2VscycsJ1xcdTJBOTYnOidlZ3MnLCdcXHUyQTk3JzonZWxzZG90JywnXFx1MkE5OCc6J2Vnc2RvdCcsJ1xcdTJBOTknOidlbCcsJ1xcdTJBOUEnOidlZycsJ1xcdTJBOUQnOidzaW1sJywnXFx1MkE5RSc6J3NpbWcnLCdcXHUyQTlGJzonc2ltbEUnLCdcXHUyQUEwJzonc2ltZ0UnLCdcXHUyQUExJzonTGVzc0xlc3MnLCdcXHUyQUExXFx1MDMzOCc6J05vdE5lc3RlZExlc3NMZXNzJywnXFx1MkFBMic6J0dyZWF0ZXJHcmVhdGVyJywnXFx1MkFBMlxcdTAzMzgnOidOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcicsJ1xcdTJBQTQnOidnbGonLCdcXHUyQUE1JzonZ2xhJywnXFx1MkFBNic6J2x0Y2MnLCdcXHUyQUE3JzonZ3RjYycsJ1xcdTJBQTgnOidsZXNjYycsJ1xcdTJBQTknOidnZXNjYycsJ1xcdTJBQUEnOidzbXQnLCdcXHUyQUFCJzonbGF0JywnXFx1MkFBQyc6J3NtdGUnLCdcXHUyQUFDXFx1RkUwMCc6J3NtdGVzJywnXFx1MkFBRCc6J2xhdGUnLCdcXHUyQUFEXFx1RkUwMCc6J2xhdGVzJywnXFx1MkFBRSc6J2J1bXBFJywnXFx1MkFBRic6J3ByZScsJ1xcdTJBQUZcXHUwMzM4JzonbnByZScsJ1xcdTJBQjAnOidzY2UnLCdcXHUyQUIwXFx1MDMzOCc6J25zY2UnLCdcXHUyQUIzJzoncHJFJywnXFx1MkFCNCc6J3NjRScsJ1xcdTJBQjUnOidwcm5FJywnXFx1MkFCNic6J3NjbkUnLCdcXHUyQUI3JzoncHJhcCcsJ1xcdTJBQjgnOidzY2FwJywnXFx1MkFCOSc6J3BybmFwJywnXFx1MkFCQSc6J3NjbmFwJywnXFx1MkFCQic6J1ByJywnXFx1MkFCQyc6J1NjJywnXFx1MkFCRCc6J3N1YmRvdCcsJ1xcdTJBQkUnOidzdXBkb3QnLCdcXHUyQUJGJzonc3VicGx1cycsJ1xcdTJBQzAnOidzdXBwbHVzJywnXFx1MkFDMSc6J3N1Ym11bHQnLCdcXHUyQUMyJzonc3VwbXVsdCcsJ1xcdTJBQzMnOidzdWJlZG90JywnXFx1MkFDNCc6J3N1cGVkb3QnLCdcXHUyQUM1Jzonc3ViRScsJ1xcdTJBQzVcXHUwMzM4JzonbnN1YkUnLCdcXHUyQUM2Jzonc3VwRScsJ1xcdTJBQzZcXHUwMzM4JzonbnN1cEUnLCdcXHUyQUM3Jzonc3Vic2ltJywnXFx1MkFDOCc6J3N1cHNpbScsJ1xcdTJBQ0JcXHVGRTAwJzondnN1Ym5FJywnXFx1MkFDQic6J3N1Ym5FJywnXFx1MkFDQ1xcdUZFMDAnOid2c3VwbkUnLCdcXHUyQUNDJzonc3VwbkUnLCdcXHUyQUNGJzonY3N1YicsJ1xcdTJBRDAnOidjc3VwJywnXFx1MkFEMSc6J2NzdWJlJywnXFx1MkFEMic6J2NzdXBlJywnXFx1MkFEMyc6J3N1YnN1cCcsJ1xcdTJBRDQnOidzdXBzdWInLCdcXHUyQUQ1Jzonc3Vic3ViJywnXFx1MkFENic6J3N1cHN1cCcsJ1xcdTJBRDcnOidzdXBoc3ViJywnXFx1MkFEOCc6J3N1cGRzdWInLCdcXHUyQUQ5JzonZm9ya3YnLCdcXHUyQURBJzondG9wZm9yaycsJ1xcdTJBREInOidtbGNwJywnXFx1MkFFNCc6J0Rhc2h2JywnXFx1MkFFNic6J1ZkYXNobCcsJ1xcdTJBRTcnOidCYXJ2JywnXFx1MkFFOCc6J3ZCYXInLCdcXHUyQUU5JzondkJhcnYnLCdcXHUyQUVCJzonVmJhcicsJ1xcdTJBRUMnOidOb3QnLCdcXHUyQUVEJzonYk5vdCcsJ1xcdTJBRUUnOidybm1pZCcsJ1xcdTJBRUYnOidjaXJtaWQnLCdcXHUyQUYwJzonbWlkY2lyJywnXFx1MkFGMSc6J3RvcGNpcicsJ1xcdTJBRjInOiduaHBhcicsJ1xcdTJBRjMnOidwYXJzaW0nLCdcXHUyQUZEJzoncGFyc2wnLCdcXHUyQUZEXFx1MjBFNSc6J25wYXJzbCcsJ1xcdTI2NkQnOidmbGF0JywnXFx1MjY2RSc6J25hdHVyJywnXFx1MjY2Ric6J3NoYXJwJywnXFx4QTQnOidjdXJyZW4nLCdcXHhBMic6J2NlbnQnLCckJzonZG9sbGFyJywnXFx4QTMnOidwb3VuZCcsJ1xceEE1JzoneWVuJywnXFx1MjBBQyc6J2V1cm8nLCdcXHhCOSc6J3N1cDEnLCdcXHhCRCc6J2hhbGYnLCdcXHUyMTUzJzonZnJhYzEzJywnXFx4QkMnOidmcmFjMTQnLCdcXHUyMTU1JzonZnJhYzE1JywnXFx1MjE1OSc6J2ZyYWMxNicsJ1xcdTIxNUInOidmcmFjMTgnLCdcXHhCMic6J3N1cDInLCdcXHUyMTU0JzonZnJhYzIzJywnXFx1MjE1Nic6J2ZyYWMyNScsJ1xceEIzJzonc3VwMycsJ1xceEJFJzonZnJhYzM0JywnXFx1MjE1Nyc6J2ZyYWMzNScsJ1xcdTIxNUMnOidmcmFjMzgnLCdcXHUyMTU4JzonZnJhYzQ1JywnXFx1MjE1QSc6J2ZyYWM1NicsJ1xcdTIxNUQnOidmcmFjNTgnLCdcXHUyMTVFJzonZnJhYzc4JywnXFx1RDgzNVxcdURDQjYnOidhc2NyJywnXFx1RDgzNVxcdURENTInOidhb3BmJywnXFx1RDgzNVxcdUREMUUnOidhZnInLCdcXHVEODM1XFx1REQzOCc6J0FvcGYnLCdcXHVEODM1XFx1REQwNCc6J0FmcicsJ1xcdUQ4MzVcXHVEQzlDJzonQXNjcicsJ1xceEFBJzonb3JkZicsJ1xceEUxJzonYWFjdXRlJywnXFx4QzEnOidBYWN1dGUnLCdcXHhFMCc6J2FncmF2ZScsJ1xceEMwJzonQWdyYXZlJywnXFx1MDEwMyc6J2FicmV2ZScsJ1xcdTAxMDInOidBYnJldmUnLCdcXHhFMic6J2FjaXJjJywnXFx4QzInOidBY2lyYycsJ1xceEU1JzonYXJpbmcnLCdcXHhDNSc6J2FuZ3N0JywnXFx4RTQnOidhdW1sJywnXFx4QzQnOidBdW1sJywnXFx4RTMnOidhdGlsZGUnLCdcXHhDMyc6J0F0aWxkZScsJ1xcdTAxMDUnOidhb2dvbicsJ1xcdTAxMDQnOidBb2dvbicsJ1xcdTAxMDEnOidhbWFjcicsJ1xcdTAxMDAnOidBbWFjcicsJ1xceEU2JzonYWVsaWcnLCdcXHhDNic6J0FFbGlnJywnXFx1RDgzNVxcdURDQjcnOidic2NyJywnXFx1RDgzNVxcdURENTMnOidib3BmJywnXFx1RDgzNVxcdUREMUYnOidiZnInLCdcXHVEODM1XFx1REQzOSc6J0JvcGYnLCdcXHUyMTJDJzonQnNjcicsJ1xcdUQ4MzVcXHVERDA1JzonQmZyJywnXFx1RDgzNVxcdUREMjAnOidjZnInLCdcXHVEODM1XFx1RENCOCc6J2NzY3InLCdcXHVEODM1XFx1REQ1NCc6J2NvcGYnLCdcXHUyMTJEJzonQ2ZyJywnXFx1RDgzNVxcdURDOUUnOidDc2NyJywnXFx1MjEwMic6J0NvcGYnLCdcXHUwMTA3JzonY2FjdXRlJywnXFx1MDEwNic6J0NhY3V0ZScsJ1xcdTAxMDknOidjY2lyYycsJ1xcdTAxMDgnOidDY2lyYycsJ1xcdTAxMEQnOidjY2Fyb24nLCdcXHUwMTBDJzonQ2Nhcm9uJywnXFx1MDEwQic6J2Nkb3QnLCdcXHUwMTBBJzonQ2RvdCcsJ1xceEU3JzonY2NlZGlsJywnXFx4QzcnOidDY2VkaWwnLCdcXHUyMTA1JzonaW5jYXJlJywnXFx1RDgzNVxcdUREMjEnOidkZnInLCdcXHUyMTQ2JzonZGQnLCdcXHVEODM1XFx1REQ1NSc6J2RvcGYnLCdcXHVEODM1XFx1RENCOSc6J2RzY3InLCdcXHVEODM1XFx1REM5Ric6J0RzY3InLCdcXHVEODM1XFx1REQwNyc6J0RmcicsJ1xcdTIxNDUnOidERCcsJ1xcdUQ4MzVcXHVERDNCJzonRG9wZicsJ1xcdTAxMEYnOidkY2Fyb24nLCdcXHUwMTBFJzonRGNhcm9uJywnXFx1MDExMSc6J2RzdHJvaycsJ1xcdTAxMTAnOidEc3Ryb2snLCdcXHhGMCc6J2V0aCcsJ1xceEQwJzonRVRIJywnXFx1MjE0Nyc6J2VlJywnXFx1MjEyRic6J2VzY3InLCdcXHVEODM1XFx1REQyMic6J2VmcicsJ1xcdUQ4MzVcXHVERDU2JzonZW9wZicsJ1xcdTIxMzAnOidFc2NyJywnXFx1RDgzNVxcdUREMDgnOidFZnInLCdcXHVEODM1XFx1REQzQyc6J0VvcGYnLCdcXHhFOSc6J2VhY3V0ZScsJ1xceEM5JzonRWFjdXRlJywnXFx4RTgnOidlZ3JhdmUnLCdcXHhDOCc6J0VncmF2ZScsJ1xceEVBJzonZWNpcmMnLCdcXHhDQSc6J0VjaXJjJywnXFx1MDExQic6J2VjYXJvbicsJ1xcdTAxMUEnOidFY2Fyb24nLCdcXHhFQic6J2V1bWwnLCdcXHhDQic6J0V1bWwnLCdcXHUwMTE3JzonZWRvdCcsJ1xcdTAxMTYnOidFZG90JywnXFx1MDExOSc6J2VvZ29uJywnXFx1MDExOCc6J0VvZ29uJywnXFx1MDExMyc6J2VtYWNyJywnXFx1MDExMic6J0VtYWNyJywnXFx1RDgzNVxcdUREMjMnOidmZnInLCdcXHVEODM1XFx1REQ1Nyc6J2ZvcGYnLCdcXHVEODM1XFx1RENCQic6J2ZzY3InLCdcXHVEODM1XFx1REQwOSc6J0ZmcicsJ1xcdUQ4MzVcXHVERDNEJzonRm9wZicsJ1xcdTIxMzEnOidGc2NyJywnXFx1RkIwMCc6J2ZmbGlnJywnXFx1RkIwMyc6J2ZmaWxpZycsJ1xcdUZCMDQnOidmZmxsaWcnLCdcXHVGQjAxJzonZmlsaWcnLCdmaic6J2ZqbGlnJywnXFx1RkIwMic6J2ZsbGlnJywnXFx1MDE5Mic6J2Zub2YnLCdcXHUyMTBBJzonZ3NjcicsJ1xcdUQ4MzVcXHVERDU4JzonZ29wZicsJ1xcdUQ4MzVcXHVERDI0JzonZ2ZyJywnXFx1RDgzNVxcdURDQTInOidHc2NyJywnXFx1RDgzNVxcdUREM0UnOidHb3BmJywnXFx1RDgzNVxcdUREMEEnOidHZnInLCdcXHUwMUY1JzonZ2FjdXRlJywnXFx1MDExRic6J2dicmV2ZScsJ1xcdTAxMUUnOidHYnJldmUnLCdcXHUwMTFEJzonZ2NpcmMnLCdcXHUwMTFDJzonR2NpcmMnLCdcXHUwMTIxJzonZ2RvdCcsJ1xcdTAxMjAnOidHZG90JywnXFx1MDEyMic6J0djZWRpbCcsJ1xcdUQ4MzVcXHVERDI1JzonaGZyJywnXFx1MjEwRSc6J3BsYW5ja2gnLCdcXHVEODM1XFx1RENCRCc6J2hzY3InLCdcXHVEODM1XFx1REQ1OSc6J2hvcGYnLCdcXHUyMTBCJzonSHNjcicsJ1xcdTIxMEMnOidIZnInLCdcXHUyMTBEJzonSG9wZicsJ1xcdTAxMjUnOidoY2lyYycsJ1xcdTAxMjQnOidIY2lyYycsJ1xcdTIxMEYnOidoYmFyJywnXFx1MDEyNyc6J2hzdHJvaycsJ1xcdTAxMjYnOidIc3Ryb2snLCdcXHVEODM1XFx1REQ1QSc6J2lvcGYnLCdcXHVEODM1XFx1REQyNic6J2lmcicsJ1xcdUQ4MzVcXHVEQ0JFJzonaXNjcicsJ1xcdTIxNDgnOidpaScsJ1xcdUQ4MzVcXHVERDQwJzonSW9wZicsJ1xcdTIxMTAnOidJc2NyJywnXFx1MjExMSc6J0ltJywnXFx4RUQnOidpYWN1dGUnLCdcXHhDRCc6J0lhY3V0ZScsJ1xceEVDJzonaWdyYXZlJywnXFx4Q0MnOidJZ3JhdmUnLCdcXHhFRSc6J2ljaXJjJywnXFx4Q0UnOidJY2lyYycsJ1xceEVGJzonaXVtbCcsJ1xceENGJzonSXVtbCcsJ1xcdTAxMjknOidpdGlsZGUnLCdcXHUwMTI4JzonSXRpbGRlJywnXFx1MDEzMCc6J0lkb3QnLCdcXHUwMTJGJzonaW9nb24nLCdcXHUwMTJFJzonSW9nb24nLCdcXHUwMTJCJzonaW1hY3InLCdcXHUwMTJBJzonSW1hY3InLCdcXHUwMTMzJzonaWpsaWcnLCdcXHUwMTMyJzonSUpsaWcnLCdcXHUwMTMxJzonaW1hdGgnLCdcXHVEODM1XFx1RENCRic6J2pzY3InLCdcXHVEODM1XFx1REQ1Qic6J2pvcGYnLCdcXHVEODM1XFx1REQyNyc6J2pmcicsJ1xcdUQ4MzVcXHVEQ0E1JzonSnNjcicsJ1xcdUQ4MzVcXHVERDBEJzonSmZyJywnXFx1RDgzNVxcdURENDEnOidKb3BmJywnXFx1MDEzNSc6J2pjaXJjJywnXFx1MDEzNCc6J0pjaXJjJywnXFx1MDIzNyc6J2ptYXRoJywnXFx1RDgzNVxcdURENUMnOidrb3BmJywnXFx1RDgzNVxcdURDQzAnOidrc2NyJywnXFx1RDgzNVxcdUREMjgnOidrZnInLCdcXHVEODM1XFx1RENBNic6J0tzY3InLCdcXHVEODM1XFx1REQ0Mic6J0tvcGYnLCdcXHVEODM1XFx1REQwRSc6J0tmcicsJ1xcdTAxMzcnOidrY2VkaWwnLCdcXHUwMTM2JzonS2NlZGlsJywnXFx1RDgzNVxcdUREMjknOidsZnInLCdcXHVEODM1XFx1RENDMSc6J2xzY3InLCdcXHUyMTEzJzonZWxsJywnXFx1RDgzNVxcdURENUQnOidsb3BmJywnXFx1MjExMic6J0xzY3InLCdcXHVEODM1XFx1REQwRic6J0xmcicsJ1xcdUQ4MzVcXHVERDQzJzonTG9wZicsJ1xcdTAxM0EnOidsYWN1dGUnLCdcXHUwMTM5JzonTGFjdXRlJywnXFx1MDEzRSc6J2xjYXJvbicsJ1xcdTAxM0QnOidMY2Fyb24nLCdcXHUwMTNDJzonbGNlZGlsJywnXFx1MDEzQic6J0xjZWRpbCcsJ1xcdTAxNDInOidsc3Ryb2snLCdcXHUwMTQxJzonTHN0cm9rJywnXFx1MDE0MCc6J2xtaWRvdCcsJ1xcdTAxM0YnOidMbWlkb3QnLCdcXHVEODM1XFx1REQyQSc6J21mcicsJ1xcdUQ4MzVcXHVERDVFJzonbW9wZicsJ1xcdUQ4MzVcXHVEQ0MyJzonbXNjcicsJ1xcdUQ4MzVcXHVERDEwJzonTWZyJywnXFx1RDgzNVxcdURENDQnOidNb3BmJywnXFx1MjEzMyc6J01zY3InLCdcXHVEODM1XFx1REQyQic6J25mcicsJ1xcdUQ4MzVcXHVERDVGJzonbm9wZicsJ1xcdUQ4MzVcXHVEQ0MzJzonbnNjcicsJ1xcdTIxMTUnOidOb3BmJywnXFx1RDgzNVxcdURDQTknOidOc2NyJywnXFx1RDgzNVxcdUREMTEnOidOZnInLCdcXHUwMTQ0JzonbmFjdXRlJywnXFx1MDE0Myc6J05hY3V0ZScsJ1xcdTAxNDgnOiduY2Fyb24nLCdcXHUwMTQ3JzonTmNhcm9uJywnXFx4RjEnOidudGlsZGUnLCdcXHhEMSc6J050aWxkZScsJ1xcdTAxNDYnOiduY2VkaWwnLCdcXHUwMTQ1JzonTmNlZGlsJywnXFx1MjExNic6J251bWVybycsJ1xcdTAxNEInOidlbmcnLCdcXHUwMTRBJzonRU5HJywnXFx1RDgzNVxcdURENjAnOidvb3BmJywnXFx1RDgzNVxcdUREMkMnOidvZnInLCdcXHUyMTM0Jzonb3NjcicsJ1xcdUQ4MzVcXHVEQ0FBJzonT3NjcicsJ1xcdUQ4MzVcXHVERDEyJzonT2ZyJywnXFx1RDgzNVxcdURENDYnOidPb3BmJywnXFx4QkEnOidvcmRtJywnXFx4RjMnOidvYWN1dGUnLCdcXHhEMyc6J09hY3V0ZScsJ1xceEYyJzonb2dyYXZlJywnXFx4RDInOidPZ3JhdmUnLCdcXHhGNCc6J29jaXJjJywnXFx4RDQnOidPY2lyYycsJ1xceEY2Jzonb3VtbCcsJ1xceEQ2JzonT3VtbCcsJ1xcdTAxNTEnOidvZGJsYWMnLCdcXHUwMTUwJzonT2RibGFjJywnXFx4RjUnOidvdGlsZGUnLCdcXHhENSc6J090aWxkZScsJ1xceEY4Jzonb3NsYXNoJywnXFx4RDgnOidPc2xhc2gnLCdcXHUwMTREJzonb21hY3InLCdcXHUwMTRDJzonT21hY3InLCdcXHUwMTUzJzonb2VsaWcnLCdcXHUwMTUyJzonT0VsaWcnLCdcXHVEODM1XFx1REQyRCc6J3BmcicsJ1xcdUQ4MzVcXHVEQ0M1JzoncHNjcicsJ1xcdUQ4MzVcXHVERDYxJzoncG9wZicsJ1xcdTIxMTknOidQb3BmJywnXFx1RDgzNVxcdUREMTMnOidQZnInLCdcXHVEODM1XFx1RENBQic6J1BzY3InLCdcXHVEODM1XFx1REQ2Mic6J3FvcGYnLCdcXHVEODM1XFx1REQyRSc6J3FmcicsJ1xcdUQ4MzVcXHVEQ0M2JzoncXNjcicsJ1xcdUQ4MzVcXHVEQ0FDJzonUXNjcicsJ1xcdUQ4MzVcXHVERDE0JzonUWZyJywnXFx1MjExQSc6J1FvcGYnLCdcXHUwMTM4Jzona2dyZWVuJywnXFx1RDgzNVxcdUREMkYnOidyZnInLCdcXHVEODM1XFx1REQ2Myc6J3JvcGYnLCdcXHVEODM1XFx1RENDNyc6J3JzY3InLCdcXHUyMTFCJzonUnNjcicsJ1xcdTIxMUMnOidSZScsJ1xcdTIxMUQnOidSb3BmJywnXFx1MDE1NSc6J3JhY3V0ZScsJ1xcdTAxNTQnOidSYWN1dGUnLCdcXHUwMTU5JzoncmNhcm9uJywnXFx1MDE1OCc6J1JjYXJvbicsJ1xcdTAxNTcnOidyY2VkaWwnLCdcXHUwMTU2JzonUmNlZGlsJywnXFx1RDgzNVxcdURENjQnOidzb3BmJywnXFx1RDgzNVxcdURDQzgnOidzc2NyJywnXFx1RDgzNVxcdUREMzAnOidzZnInLCdcXHVEODM1XFx1REQ0QSc6J1NvcGYnLCdcXHVEODM1XFx1REQxNic6J1NmcicsJ1xcdUQ4MzVcXHVEQ0FFJzonU3NjcicsJ1xcdTI0QzgnOidvUycsJ1xcdTAxNUInOidzYWN1dGUnLCdcXHUwMTVBJzonU2FjdXRlJywnXFx1MDE1RCc6J3NjaXJjJywnXFx1MDE1Qyc6J1NjaXJjJywnXFx1MDE2MSc6J3NjYXJvbicsJ1xcdTAxNjAnOidTY2Fyb24nLCdcXHUwMTVGJzonc2NlZGlsJywnXFx1MDE1RSc6J1NjZWRpbCcsJ1xceERGJzonc3psaWcnLCdcXHVEODM1XFx1REQzMSc6J3RmcicsJ1xcdUQ4MzVcXHVEQ0M5JzondHNjcicsJ1xcdUQ4MzVcXHVERDY1JzondG9wZicsJ1xcdUQ4MzVcXHVEQ0FGJzonVHNjcicsJ1xcdUQ4MzVcXHVERDE3JzonVGZyJywnXFx1RDgzNVxcdURENEInOidUb3BmJywnXFx1MDE2NSc6J3RjYXJvbicsJ1xcdTAxNjQnOidUY2Fyb24nLCdcXHUwMTYzJzondGNlZGlsJywnXFx1MDE2Mic6J1RjZWRpbCcsJ1xcdTIxMjInOid0cmFkZScsJ1xcdTAxNjcnOid0c3Ryb2snLCdcXHUwMTY2JzonVHN0cm9rJywnXFx1RDgzNVxcdURDQ0EnOid1c2NyJywnXFx1RDgzNVxcdURENjYnOid1b3BmJywnXFx1RDgzNVxcdUREMzInOid1ZnInLCdcXHVEODM1XFx1REQ0Qyc6J1VvcGYnLCdcXHVEODM1XFx1REQxOCc6J1VmcicsJ1xcdUQ4MzVcXHVEQ0IwJzonVXNjcicsJ1xceEZBJzondWFjdXRlJywnXFx4REEnOidVYWN1dGUnLCdcXHhGOSc6J3VncmF2ZScsJ1xceEQ5JzonVWdyYXZlJywnXFx1MDE2RCc6J3VicmV2ZScsJ1xcdTAxNkMnOidVYnJldmUnLCdcXHhGQic6J3VjaXJjJywnXFx4REInOidVY2lyYycsJ1xcdTAxNkYnOid1cmluZycsJ1xcdTAxNkUnOidVcmluZycsJ1xceEZDJzondXVtbCcsJ1xceERDJzonVXVtbCcsJ1xcdTAxNzEnOid1ZGJsYWMnLCdcXHUwMTcwJzonVWRibGFjJywnXFx1MDE2OSc6J3V0aWxkZScsJ1xcdTAxNjgnOidVdGlsZGUnLCdcXHUwMTczJzondW9nb24nLCdcXHUwMTcyJzonVW9nb24nLCdcXHUwMTZCJzondW1hY3InLCdcXHUwMTZBJzonVW1hY3InLCdcXHVEODM1XFx1REQzMyc6J3ZmcicsJ1xcdUQ4MzVcXHVERDY3Jzondm9wZicsJ1xcdUQ4MzVcXHVEQ0NCJzondnNjcicsJ1xcdUQ4MzVcXHVERDE5JzonVmZyJywnXFx1RDgzNVxcdURENEQnOidWb3BmJywnXFx1RDgzNVxcdURDQjEnOidWc2NyJywnXFx1RDgzNVxcdURENjgnOid3b3BmJywnXFx1RDgzNVxcdURDQ0MnOid3c2NyJywnXFx1RDgzNVxcdUREMzQnOid3ZnInLCdcXHVEODM1XFx1RENCMic6J1dzY3InLCdcXHVEODM1XFx1REQ0RSc6J1dvcGYnLCdcXHVEODM1XFx1REQxQSc6J1dmcicsJ1xcdTAxNzUnOid3Y2lyYycsJ1xcdTAxNzQnOidXY2lyYycsJ1xcdUQ4MzVcXHVERDM1JzoneGZyJywnXFx1RDgzNVxcdURDQ0QnOid4c2NyJywnXFx1RDgzNVxcdURENjknOid4b3BmJywnXFx1RDgzNVxcdURENEYnOidYb3BmJywnXFx1RDgzNVxcdUREMUInOidYZnInLCdcXHVEODM1XFx1RENCMyc6J1hzY3InLCdcXHVEODM1XFx1REQzNic6J3lmcicsJ1xcdUQ4MzVcXHVEQ0NFJzoneXNjcicsJ1xcdUQ4MzVcXHVERDZBJzoneW9wZicsJ1xcdUQ4MzVcXHVEQ0I0JzonWXNjcicsJ1xcdUQ4MzVcXHVERDFDJzonWWZyJywnXFx1RDgzNVxcdURENTAnOidZb3BmJywnXFx4RkQnOid5YWN1dGUnLCdcXHhERCc6J1lhY3V0ZScsJ1xcdTAxNzcnOid5Y2lyYycsJ1xcdTAxNzYnOidZY2lyYycsJ1xceEZGJzoneXVtbCcsJ1xcdTAxNzgnOidZdW1sJywnXFx1RDgzNVxcdURDQ0YnOid6c2NyJywnXFx1RDgzNVxcdUREMzcnOid6ZnInLCdcXHVEODM1XFx1REQ2Qic6J3pvcGYnLCdcXHUyMTI4JzonWmZyJywnXFx1MjEyNCc6J1pvcGYnLCdcXHVEODM1XFx1RENCNSc6J1pzY3InLCdcXHUwMTdBJzonemFjdXRlJywnXFx1MDE3OSc6J1phY3V0ZScsJ1xcdTAxN0UnOid6Y2Fyb24nLCdcXHUwMTdEJzonWmNhcm9uJywnXFx1MDE3Qyc6J3pkb3QnLCdcXHUwMTdCJzonWmRvdCcsJ1xcdTAxQjUnOidpbXBlZCcsJ1xceEZFJzondGhvcm4nLCdcXHhERSc6J1RIT1JOJywnXFx1MDE0OSc6J25hcG9zJywnXFx1MDNCMSc6J2FscGhhJywnXFx1MDM5MSc6J0FscGhhJywnXFx1MDNCMic6J2JldGEnLCdcXHUwMzkyJzonQmV0YScsJ1xcdTAzQjMnOidnYW1tYScsJ1xcdTAzOTMnOidHYW1tYScsJ1xcdTAzQjQnOidkZWx0YScsJ1xcdTAzOTQnOidEZWx0YScsJ1xcdTAzQjUnOidlcHNpJywnXFx1MDNGNSc6J2Vwc2l2JywnXFx1MDM5NSc6J0Vwc2lsb24nLCdcXHUwM0REJzonZ2FtbWFkJywnXFx1MDNEQyc6J0dhbW1hZCcsJ1xcdTAzQjYnOid6ZXRhJywnXFx1MDM5Nic6J1pldGEnLCdcXHUwM0I3JzonZXRhJywnXFx1MDM5Nyc6J0V0YScsJ1xcdTAzQjgnOid0aGV0YScsJ1xcdTAzRDEnOid0aGV0YXYnLCdcXHUwMzk4JzonVGhldGEnLCdcXHUwM0I5JzonaW90YScsJ1xcdTAzOTknOidJb3RhJywnXFx1MDNCQSc6J2thcHBhJywnXFx1MDNGMCc6J2thcHBhdicsJ1xcdTAzOUEnOidLYXBwYScsJ1xcdTAzQkInOidsYW1iZGEnLCdcXHUwMzlCJzonTGFtYmRhJywnXFx1MDNCQyc6J211JywnXFx4QjUnOidtaWNybycsJ1xcdTAzOUMnOidNdScsJ1xcdTAzQkQnOidudScsJ1xcdTAzOUQnOidOdScsJ1xcdTAzQkUnOid4aScsJ1xcdTAzOUUnOidYaScsJ1xcdTAzQkYnOidvbWljcm9uJywnXFx1MDM5Ric6J09taWNyb24nLCdcXHUwM0MwJzoncGknLCdcXHUwM0Q2JzoncGl2JywnXFx1MDNBMCc6J1BpJywnXFx1MDNDMSc6J3JobycsJ1xcdTAzRjEnOidyaG92JywnXFx1MDNBMSc6J1JobycsJ1xcdTAzQzMnOidzaWdtYScsJ1xcdTAzQTMnOidTaWdtYScsJ1xcdTAzQzInOidzaWdtYWYnLCdcXHUwM0M0JzondGF1JywnXFx1MDNBNCc6J1RhdScsJ1xcdTAzQzUnOid1cHNpJywnXFx1MDNBNSc6J1Vwc2lsb24nLCdcXHUwM0QyJzonVXBzaScsJ1xcdTAzQzYnOidwaGknLCdcXHUwM0Q1JzoncGhpdicsJ1xcdTAzQTYnOidQaGknLCdcXHUwM0M3JzonY2hpJywnXFx1MDNBNyc6J0NoaScsJ1xcdTAzQzgnOidwc2knLCdcXHUwM0E4JzonUHNpJywnXFx1MDNDOSc6J29tZWdhJywnXFx1MDNBOSc6J29obScsJ1xcdTA0MzAnOidhY3knLCdcXHUwNDEwJzonQWN5JywnXFx1MDQzMSc6J2JjeScsJ1xcdTA0MTEnOidCY3knLCdcXHUwNDMyJzondmN5JywnXFx1MDQxMic6J1ZjeScsJ1xcdTA0MzMnOidnY3knLCdcXHUwNDEzJzonR2N5JywnXFx1MDQ1Myc6J2dqY3knLCdcXHUwNDAzJzonR0pjeScsJ1xcdTA0MzQnOidkY3knLCdcXHUwNDE0JzonRGN5JywnXFx1MDQ1Mic6J2RqY3knLCdcXHUwNDAyJzonREpjeScsJ1xcdTA0MzUnOidpZWN5JywnXFx1MDQxNSc6J0lFY3knLCdcXHUwNDUxJzonaW9jeScsJ1xcdTA0MDEnOidJT2N5JywnXFx1MDQ1NCc6J2p1a2N5JywnXFx1MDQwNCc6J0p1a2N5JywnXFx1MDQzNic6J3poY3knLCdcXHUwNDE2JzonWkhjeScsJ1xcdTA0MzcnOid6Y3knLCdcXHUwNDE3JzonWmN5JywnXFx1MDQ1NSc6J2RzY3knLCdcXHUwNDA1JzonRFNjeScsJ1xcdTA0MzgnOidpY3knLCdcXHUwNDE4JzonSWN5JywnXFx1MDQ1Nic6J2l1a2N5JywnXFx1MDQwNic6J0l1a2N5JywnXFx1MDQ1Nyc6J3lpY3knLCdcXHUwNDA3JzonWUljeScsJ1xcdTA0MzknOidqY3knLCdcXHUwNDE5JzonSmN5JywnXFx1MDQ1OCc6J2pzZXJjeScsJ1xcdTA0MDgnOidKc2VyY3knLCdcXHUwNDNBJzona2N5JywnXFx1MDQxQSc6J0tjeScsJ1xcdTA0NUMnOidramN5JywnXFx1MDQwQyc6J0tKY3knLCdcXHUwNDNCJzonbGN5JywnXFx1MDQxQic6J0xjeScsJ1xcdTA0NTknOidsamN5JywnXFx1MDQwOSc6J0xKY3knLCdcXHUwNDNDJzonbWN5JywnXFx1MDQxQyc6J01jeScsJ1xcdTA0M0QnOiduY3knLCdcXHUwNDFEJzonTmN5JywnXFx1MDQ1QSc6J25qY3knLCdcXHUwNDBBJzonTkpjeScsJ1xcdTA0M0UnOidvY3knLCdcXHUwNDFFJzonT2N5JywnXFx1MDQzRic6J3BjeScsJ1xcdTA0MUYnOidQY3knLCdcXHUwNDQwJzoncmN5JywnXFx1MDQyMCc6J1JjeScsJ1xcdTA0NDEnOidzY3knLCdcXHUwNDIxJzonU2N5JywnXFx1MDQ0Mic6J3RjeScsJ1xcdTA0MjInOidUY3knLCdcXHUwNDVCJzondHNoY3knLCdcXHUwNDBCJzonVFNIY3knLCdcXHUwNDQzJzondWN5JywnXFx1MDQyMyc6J1VjeScsJ1xcdTA0NUUnOid1YnJjeScsJ1xcdTA0MEUnOidVYnJjeScsJ1xcdTA0NDQnOidmY3knLCdcXHUwNDI0JzonRmN5JywnXFx1MDQ0NSc6J2toY3knLCdcXHUwNDI1JzonS0hjeScsJ1xcdTA0NDYnOid0c2N5JywnXFx1MDQyNic6J1RTY3knLCdcXHUwNDQ3JzonY2hjeScsJ1xcdTA0MjcnOidDSGN5JywnXFx1MDQ1Ric6J2R6Y3knLCdcXHUwNDBGJzonRFpjeScsJ1xcdTA0NDgnOidzaGN5JywnXFx1MDQyOCc6J1NIY3knLCdcXHUwNDQ5Jzonc2hjaGN5JywnXFx1MDQyOSc6J1NIQ0hjeScsJ1xcdTA0NEEnOidoYXJkY3knLCdcXHUwNDJBJzonSEFSRGN5JywnXFx1MDQ0Qic6J3ljeScsJ1xcdTA0MkInOidZY3knLCdcXHUwNDRDJzonc29mdGN5JywnXFx1MDQyQyc6J1NPRlRjeScsJ1xcdTA0NEQnOidlY3knLCdcXHUwNDJEJzonRWN5JywnXFx1MDQ0RSc6J3l1Y3knLCdcXHUwNDJFJzonWVVjeScsJ1xcdTA0NEYnOid5YWN5JywnXFx1MDQyRic6J1lBY3knLCdcXHUyMTM1JzonYWxlcGgnLCdcXHUyMTM2JzonYmV0aCcsJ1xcdTIxMzcnOidnaW1lbCcsJ1xcdTIxMzgnOidkYWxldGgnfTtcblxuXHR2YXIgcmVnZXhFc2NhcGUgPSAvW1wiJic8PmBdL2c7XG5cdHZhciBlc2NhcGVNYXAgPSB7XG5cdFx0J1wiJzogJyZxdW90OycsXG5cdFx0JyYnOiAnJmFtcDsnLFxuXHRcdCdcXCcnOiAnJiN4Mjc7Jyxcblx0XHQnPCc6ICcmbHQ7Jyxcblx0XHQvLyBTZWUgaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzOiBpbiBIVE1MLCB0aGVcblx0XHQvLyBmb2xsb3dpbmcgaXMgbm90IHN0cmljdGx5IG5lY2Vzc2FyeSB1bmxlc3MgaXTigJlzIHBhcnQgb2YgYSB0YWcgb3IgYW5cblx0XHQvLyB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFdl4oCZcmUgb25seSBlc2NhcGluZyBpdCB0byBzdXBwb3J0IHRob3NlXG5cdFx0Ly8gc2l0dWF0aW9ucywgYW5kIGZvciBYTUwgc3VwcG9ydC5cblx0XHQnPic6ICcmZ3Q7Jyxcblx0XHQvLyBJbiBJbnRlcm5ldCBFeHBsb3JlciDiiaQgOCwgdGhlIGJhY2t0aWNrIGNoYXJhY3RlciBjYW4gYmUgdXNlZFxuXHRcdC8vIHRvIGJyZWFrIG91dCBvZiAodW4pcXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZXMgb3IgSFRNTCBjb21tZW50cy5cblx0XHQvLyBTZWUgaHR0cDovL2h0bWw1c2VjLm9yZy8jMTAyLCBodHRwOi8vaHRtbDVzZWMub3JnLyMxMDgsIGFuZFxuXHRcdC8vIGh0dHA6Ly9odG1sNXNlYy5vcmcvIzEzMy5cblx0XHQnYCc6ICcmI3g2MDsnXG5cdH07XG5cblx0dmFyIHJlZ2V4SW52YWxpZEVudGl0eSA9IC8mIyg/Olt4WF1bXmEtZkEtRjAtOV18W14wLTl4WF0pLztcblx0dmFyIHJlZ2V4SW52YWxpZFJhd0NvZGVQb2ludCA9IC9bXFwwLVxceDA4XFx4MEJcXHgwRS1cXHgxRlxceDdGLVxceDlGXFx1RkREMC1cXHVGREVGXFx1RkZGRVxcdUZGRkZdfFtcXHVEODNGXFx1RDg3RlxcdUQ4QkZcXHVEOEZGXFx1RDkzRlxcdUQ5N0ZcXHVEOUJGXFx1RDlGRlxcdURBM0ZcXHVEQTdGXFx1REFCRlxcdURBRkZcXHVEQjNGXFx1REI3RlxcdURCQkZcXHVEQkZGXVtcXHVERkZFXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vO1xuXHR2YXIgcmVnZXhEZWNvZGUgPSAvJihDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsfERvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvd3xDbG9ja3dpc2VDb250b3VySW50ZWdyYWx8Tm90TmVzdGVkR3JlYXRlckdyZWF0ZXJ8Tm90U3F1YXJlU3VwZXJzZXRFcXVhbHxEaWFjcml0aWNhbERvdWJsZUFjdXRlfE5vdFJpZ2h0VHJpYW5nbGVFcXVhbHxOb3RTdWNjZWVkc1NsYW50RXF1YWx8Tm90UHJlY2VkZXNTbGFudEVxdWFsfENsb3NlQ3VybHlEb3VibGVRdW90ZXxOZWdhdGl2ZVZlcnlUaGluU3BhY2V8RG91YmxlQ29udG91ckludGVncmFsfEZpbGxlZFZlcnlTbWFsbFNxdWFyZXxDYXBpdGFsRGlmZmVyZW50aWFsRHxPcGVuQ3VybHlEb3VibGVRdW90ZXxFbXB0eVZlcnlTbWFsbFNxdWFyZXxOZXN0ZWRHcmVhdGVyR3JlYXRlcnxEb3VibGVMb25nUmlnaHRBcnJvd3xOb3RMZWZ0VHJpYW5nbGVFcXVhbHxOb3RHcmVhdGVyU2xhbnRFcXVhbHxSZXZlcnNlVXBFcXVpbGlicml1bXxEb3VibGVMZWZ0UmlnaHRBcnJvd3xOb3RTcXVhcmVTdWJzZXRFcXVhbHxOb3REb3VibGVWZXJ0aWNhbEJhcnxSaWdodEFycm93TGVmdEFycm93fE5vdEdyZWF0ZXJGdWxsRXF1YWx8Tm90UmlnaHRUcmlhbmdsZUJhcnxTcXVhcmVTdXBlcnNldEVxdWFsfERvd25MZWZ0UmlnaHRWZWN0b3J8RG91YmxlTG9uZ0xlZnRBcnJvd3xsZWZ0cmlnaHRzcXVpZ2Fycm93fExlZnRBcnJvd1JpZ2h0QXJyb3d8TmVnYXRpdmVNZWRpdW1TcGFjZXxibGFja3RyaWFuZ2xlcmlnaHR8UmlnaHREb3duVmVjdG9yQmFyfFByZWNlZGVzU2xhbnRFcXVhbHxSaWdodERvdWJsZUJyYWNrZXR8U3VjY2VlZHNTbGFudEVxdWFsfE5vdExlZnRUcmlhbmdsZUJhcnxSaWdodFRyaWFuZ2xlRXF1YWx8U3F1YXJlSW50ZXJzZWN0aW9ufFJpZ2h0RG93blRlZVZlY3RvcnxSZXZlcnNlRXF1aWxpYnJpdW18TmVnYXRpdmVUaGlja1NwYWNlfGxvbmdsZWZ0cmlnaHRhcnJvd3xMb25nbGVmdHJpZ2h0YXJyb3d8TG9uZ0xlZnRSaWdodEFycm93fERvd25SaWdodFRlZVZlY3RvcnxEb3duUmlnaHRWZWN0b3JCYXJ8R3JlYXRlclNsYW50RXF1YWx8U3F1YXJlU3Vic2V0RXF1YWx8TGVmdERvd25WZWN0b3JCYXJ8TGVmdERvdWJsZUJyYWNrZXR8VmVydGljYWxTZXBhcmF0b3J8cmlnaHRsZWZ0aGFycG9vbnN8Tm90R3JlYXRlckdyZWF0ZXJ8Tm90U3F1YXJlU3VwZXJzZXR8YmxhY2t0cmlhbmdsZWxlZnR8YmxhY2t0cmlhbmdsZWRvd258TmVnYXRpdmVUaGluU3BhY2V8TGVmdERvd25UZWVWZWN0b3J8Tm90TGVzc1NsYW50RXF1YWx8bGVmdHJpZ2h0aGFycG9vbnN8RG91YmxlVXBEb3duQXJyb3d8RG91YmxlVmVydGljYWxCYXJ8TGVmdFRyaWFuZ2xlRXF1YWx8RmlsbGVkU21hbGxTcXVhcmV8dHdvaGVhZHJpZ2h0YXJyb3d8Tm90TmVzdGVkTGVzc0xlc3N8RG93bkxlZnRUZWVWZWN0b3J8RG93bkxlZnRWZWN0b3JCYXJ8UmlnaHRBbmdsZUJyYWNrZXR8Tm90VGlsZGVGdWxsRXF1YWx8Tm90UmV2ZXJzZUVsZW1lbnR8UmlnaHRVcERvd25WZWN0b3J8RGlhY3JpdGljYWxUaWxkZXxOb3RTdWNjZWVkc1RpbGRlfGNpcmNsZWFycm93cmlnaHR8Tm90UHJlY2VkZXNFcXVhbHxyaWdodGhhcnBvb25kb3dufERvdWJsZVJpZ2h0QXJyb3d8Tm90U3VjY2VlZHNFcXVhbHxOb25CcmVha2luZ1NwYWNlfE5vdFJpZ2h0VHJpYW5nbGV8TGVzc0VxdWFsR3JlYXRlcnxSaWdodFVwVGVlVmVjdG9yfExlZnRBbmdsZUJyYWNrZXR8R3JlYXRlckZ1bGxFcXVhbHxEb3duQXJyb3dVcEFycm93fFJpZ2h0VXBWZWN0b3JCYXJ8dHdvaGVhZGxlZnRhcnJvd3xHcmVhdGVyRXF1YWxMZXNzfGRvd25oYXJwb29ucmlnaHR8UmlnaHRUcmlhbmdsZUJhcnxudHJpYW5nbGVyaWdodGVxfE5vdFN1cGVyc2V0RXF1YWx8TGVmdFVwRG93blZlY3RvcnxEaWFjcml0aWNhbEFjdXRlfHJpZ2h0cmlnaHRhcnJvd3N8dmFydHJpYW5nbGVyaWdodHxVcEFycm93RG93bkFycm93fERpYWNyaXRpY2FsR3JhdmV8VW5kZXJQYXJlbnRoZXNpc3xFbXB0eVNtYWxsU3F1YXJlfExlZnRVcFZlY3RvckJhcnxsZWZ0cmlnaHRhcnJvd3N8RG93blJpZ2h0VmVjdG9yfGRvd25oYXJwb29ubGVmdHx0cmlhbmdsZXJpZ2h0ZXF8U2hvcnRSaWdodEFycm93fE92ZXJQYXJlbnRoZXNpc3xEb3VibGVMZWZ0QXJyb3d8RG91YmxlRG93bkFycm93fE5vdFNxdWFyZVN1YnNldHxiaWd0cmlhbmdsZWRvd258bnRyaWFuZ2xlbGVmdGVxfFVwcGVyUmlnaHRBcnJvd3xjdXJ2ZWFycm93cmlnaHR8dmFydHJpYW5nbGVsZWZ0fE5vdExlZnRUcmlhbmdsZXxubGVmdHJpZ2h0YXJyb3d8TG93ZXJSaWdodEFycm93fE5vdEh1bXBEb3duSHVtcHxOb3RHcmVhdGVyVGlsZGV8cmlnaHR0aHJlZXRpbWVzfExlZnRVcFRlZVZlY3RvcnxOb3RHcmVhdGVyRXF1YWx8c3RyYWlnaHRlcHNpbG9ufExlZnRUcmlhbmdsZUJhcnxyaWdodHNxdWlnYXJyb3d8Q29udG91ckludGVncmFsfHJpZ2h0bGVmdGFycm93c3xDbG9zZUN1cmx5UXVvdGV8UmlnaHREb3duVmVjdG9yfExlZnRSaWdodFZlY3RvcnxuTGVmdHJpZ2h0YXJyb3d8bGVmdGhhcnBvb25kb3dufGNpcmNsZWFycm93bGVmdHxTcXVhcmVTdXBlcnNldHxPcGVuQ3VybHlRdW90ZXxob29rcmlnaHRhcnJvd3xIb3Jpem9udGFsTGluZXxEaWFjcml0aWNhbERvdHxOb3RMZXNzR3JlYXRlcnxudHJpYW5nbGVyaWdodHxEb3VibGVSaWdodFRlZXxJbnZpc2libGVDb21tYXxJbnZpc2libGVUaW1lc3xMb3dlckxlZnRBcnJvd3xEb3duTGVmdFZlY3RvcnxOb3RTdWJzZXRFcXVhbHxjdXJ2ZWFycm93bGVmdHx0cmlhbmdsZWxlZnRlcXxOb3RWZXJ0aWNhbEJhcnxUaWxkZUZ1bGxFcXVhbHxkb3duZG93bmFycm93c3xOb3RHcmVhdGVyTGVzc3xSaWdodFRlZVZlY3RvcnxaZXJvV2lkdGhTcGFjZXxsb29wYXJyb3dyaWdodHxMb25nUmlnaHRBcnJvd3xkb3VibGViYXJ3ZWRnZXxTaG9ydExlZnRBcnJvd3xTaG9ydERvd25BcnJvd3xSaWdodFZlY3RvckJhcnxHcmVhdGVyR3JlYXRlcnxSZXZlcnNlRWxlbWVudHxyaWdodGhhcnBvb251cHxMZXNzU2xhbnRFcXVhbHxsZWZ0dGhyZWV0aW1lc3x1cGhhcnBvb25yaWdodHxyaWdodGFycm93dGFpbHxMZWZ0RG93blZlY3RvcnxMb25ncmlnaHRhcnJvd3xOZXN0ZWRMZXNzTGVzc3xVcHBlckxlZnRBcnJvd3xuc2hvcnRwYXJhbGxlbHxsZWZ0bGVmdGFycm93c3xsZWZ0cmlnaHRhcnJvd3xMZWZ0cmlnaHRhcnJvd3xMZWZ0UmlnaHRBcnJvd3xsb25ncmlnaHRhcnJvd3x1cGhhcnBvb25sZWZ0fFJpZ2h0QXJyb3dCYXJ8QXBwbHlGdW5jdGlvbnxMZWZ0VGVlVmVjdG9yfGxlZnRhcnJvd3RhaWx8Tm90RXF1YWxUaWxkZXx2YXJzdWJzZXRuZXFxfHZhcnN1cHNldG5lcXF8UmlnaHRUZWVBcnJvd3xTdWNjZWVkc0VxdWFsfFN1Y2NlZWRzVGlsZGV8TGVmdFZlY3RvckJhcnxTdXBlcnNldEVxdWFsfGhvb2tsZWZ0YXJyb3d8RGlmZmVyZW50aWFsRHxWZXJ0aWNhbFRpbGRlfFZlcnlUaGluU3BhY2V8YmxhY2t0cmlhbmdsZXxiaWd0cmlhbmdsZXVwfExlc3NGdWxsRXF1YWx8ZGl2aWRlb250aW1lc3xsZWZ0aGFycG9vbnVwfFVwRXF1aWxpYnJpdW18bnRyaWFuZ2xlbGVmdHxSaWdodFRyaWFuZ2xlfG1lYXN1cmVkYW5nbGV8c2hvcnRwYXJhbGxlbHxsb25nbGVmdGFycm93fExvbmdsZWZ0YXJyb3d8TG9uZ0xlZnRBcnJvd3xEb3VibGVMZWZ0VGVlfFBvaW5jYXJlcGxhbmV8UHJlY2VkZXNFcXVhbHx0cmlhbmdsZXJpZ2h0fERvdWJsZVVwQXJyb3d8UmlnaHRVcFZlY3RvcnxmYWxsaW5nZG90c2VxfGxvb3BhcnJvd2xlZnR8UHJlY2VkZXNUaWxkZXxOb3RUaWxkZUVxdWFsfE5vdFRpbGRlVGlsZGV8c21hbGxzZXRtaW51c3xQcm9wb3J0aW9uYWx8dHJpYW5nbGVsZWZ0fHRyaWFuZ2xlZG93bnxVbmRlckJyYWNrZXR8Tm90SHVtcEVxdWFsfGV4cG9uZW50aWFsZXxFeHBvbmVudGlhbEV8Tm90TGVzc1RpbGRlfEhpbGJlcnRTcGFjZXxSaWdodENlaWxpbmd8YmxhY2tsb3plbmdlfHZhcnN1cHNldG5lcXxIdW1wRG93bkh1bXB8R3JlYXRlckVxdWFsfFZlcnRpY2FsTGluZXxMZWZ0VGVlQXJyb3d8Tm90TGVzc0VxdWFsfERvd25UZWVBcnJvd3xMZWZ0VHJpYW5nbGV8dmFyc3Vic2V0bmVxfEludGVyc2VjdGlvbnxOb3RDb25ncnVlbnR8RG93bkFycm93QmFyfExlZnRVcFZlY3RvcnxMZWZ0QXJyb3dCYXJ8cmlzaW5nZG90c2VxfEdyZWF0ZXJUaWxkZXxSb3VuZEltcGxpZXN8U3F1YXJlU3Vic2V0fFNob3J0VXBBcnJvd3xOb3RTdXBlcnNldHxxdWF0ZXJuaW9uc3xwcmVjbmFwcHJveHxiYWNrZXBzaWxvbnxwcmVjY3VybHllcXxPdmVyQnJhY2tldHxibGFja3NxdWFyZXxNZWRpdW1TcGFjZXxWZXJ0aWNhbEJhcnxjaXJjbGVkY2lyY3xjaXJjbGVkZGFzaHxDaXJjbGVNaW51c3xDaXJjbGVUaW1lc3xMZXNzR3JlYXRlcnxjdXJseWVxcHJlY3xjdXJseWVxc3VjY3xkaWFtb25kc3VpdHxVcERvd25BcnJvd3xVcGRvd25hcnJvd3xSdWxlRGVsYXllZHxScmlnaHRhcnJvd3x1cGRvd25hcnJvd3xSaWdodFZlY3RvcnxuUmlnaHRhcnJvd3xucmlnaHRhcnJvd3xlcXNsYW50bGVzc3xMZWZ0Q2VpbGluZ3xFcXVpbGlicml1bXxTbWFsbENpcmNsZXxleHBlY3RhdGlvbnxOb3RTdWNjZWVkc3x0aGlja2FwcHJveHxHcmVhdGVyTGVzc3xTcXVhcmVVbmlvbnxOb3RQcmVjZWRlc3xOb3RMZXNzTGVzc3xzdHJhaWdodHBoaXxzdWNjbmFwcHJveHxzdWNjY3VybHllcXxTdWJzZXRFcXVhbHxzcXN1cHNldGVxfFByb3BvcnRpb258TGFwbGFjZXRyZnxJbWFnaW5hcnlJfHN1cHNldG5lcXF8Tm90R3JlYXRlcnxndHJlcXFsZXNzfE5vdEVsZW1lbnR8VGhpY2tTcGFjZXxUaWxkZUVxdWFsfFRpbGRlVGlsZGV8Rm91cmllcnRyZnxybW91c3RhY2hlfEVxdWFsVGlsZGV8ZXFzbGFudGd0cnxVbmRlckJyYWNlfExlZnRWZWN0b3J8VXBBcnJvd0JhcnxuTGVmdGFycm93fG5zdWJzZXRlcXF8c3Vic2V0bmVxcXxuc3Vwc2V0ZXFxfG5sZWZ0YXJyb3d8c3VjY2FwcHJveHxsZXNzYXBwcm94fFVwVGVlQXJyb3d8dXB1cGFycm93c3xjdXJseXdlZGdlfGxlc3NlcXFndHJ8dmFyZXBzaWxvbnx2YXJub3RoaW5nfFJpZ2h0Rmxvb3J8Y29tcGxlbWVudHxDaXJjbGVQbHVzfHNxc3Vic2V0ZXF8TGxlZnRhcnJvd3xjaXJjbGVkYXN0fFJpZ2h0QXJyb3d8UmlnaHRhcnJvd3xyaWdodGFycm93fGxtb3VzdGFjaGV8QmVybm91bGxpc3xwcmVjYXBwcm94fG1hcHN0b2xlZnR8bWFwc3RvZG93bnxsb25nbWFwc3RvfGRvdHNxdWFyZXxkb3duYXJyb3d8RG91YmxlRG90fG5zdWJzZXRlcXxzdXBzZXRuZXF8bGVmdGFycm93fG5zdXBzZXRlcXxzdWJzZXRuZXF8VGhpblNwYWNlfG5nZXFzbGFudHxzdWJzZXRlcXF8SHVtcEVxdWFsfE5vdFN1YnNldHx0cmlhbmdsZXF8Tm90Q3VwQ2FwfGxlc3NlcWd0cnxoZWFydHN1aXR8VHJpcGxlRG90fExlZnRhcnJvd3xDb3Byb2R1Y3R8Q29uZ3J1ZW50fHZhcnByb3B0b3xjb21wbGV4ZXN8Z3ZlcnRuZXFxfExlZnRBcnJvd3xMZXNzVGlsZGV8c3Vwc2V0ZXFxfE1pbnVzUGx1c3xDaXJjbGVEb3R8bmxlcXNsYW50fE5vdEV4aXN0c3xndHJlcWxlc3N8bnBhcmFsbGVsfFVuaW9uUGx1c3xMZWZ0Rmxvb3J8Y2hlY2ttYXJrfENlbnRlckRvdHxjZW50ZXJkb3R8TWVsbGludHJmfGd0cmFwcHJveHxiaWdvdGltZXN8T3ZlckJyYWNlfHNwYWRlc3VpdHx0aGVyZWZvcmV8cGl0Y2hmb3JrfHJhdGlvbmFsc3xQbHVzTWludXN8QmFja3NsYXNofFRoZXJlZm9yZXxEb3duQnJldmV8YmFja3NpbWVxfGJhY2twcmltZXxEb3duQXJyb3d8bnNob3J0bWlkfERvd25hcnJvd3xsdmVydG5lcXF8ZXF2cGFyc2x8aW1hZ2xpbmV8aW1hZ3BhcnR8aW5maW50aWV8aW50ZWdlcnN8SW50ZWdyYWx8aW50ZXJjYWx8TGVzc0xlc3N8VWFycm9jaXJ8aW50bGFyaGt8c3FzdXBzZXR8YW5nbXNkYWZ8c3FzdWJzZXR8bGxjb3JuZXJ8dmFydGhldGF8Y3VwYnJjYXB8bG5hcHByb3h8U3VwZXJzZXR8U3VjaFRoYXR8c3VjY25zaW18c3VjY25lcXF8YW5nbXNkYWd8YmlndXBsdXN8Y3VybHl2ZWV8dHJwZXppdW18U3VjY2VlZHN8Tm90VGlsZGV8Ymlnd2VkZ2V8YW5nbXNkYWh8YW5ncnR2YmR8dHJpbWludXN8Y3djb25pbnR8ZnBhcnRpbnR8bHJjb3JuZXJ8c21lcGFyc2x8c3Vic2V0ZXF8dXJjb3JuZXJ8bHVyZHNoYXJ8bGFlbXB0eXZ8RERvdHJhaGR8YXBwcm94ZXF8bGRydXNoYXJ8YXdjb25pbnR8bWFwc3RvdXB8YmFja2Nvbmd8c2hvcnRtaWR8dHJpYW5nbGV8Z2Vxc2xhbnR8Z2VzZG90b2x8dGltZXNiYXJ8Y2lyY2xlZFJ8Y2lyY2xlZFN8c2V0bWludXN8bXVsdGltYXB8bmF0dXJhbHN8c2Nwb2xpbnR8bmNvbmdkb3R8UmlnaHRUZWV8Ym94bWludXN8Z25hcHByb3h8Ym94dGltZXN8YW5kc2xvcGV8dGhpY2tzaW18YW5nbXNkYWF8dmFyc2lnbWF8Y2lyZm5pbnR8cnRyaWx0cml8YW5nbXNkYWJ8cnBwb2xpbnR8YW5nbXNkYWN8YmFyd2VkZ2V8ZHJia2Fyb3d8Y2x1YnN1aXR8dGhldGFzeW18YnNvbGhzdWJ8Y2FwYnJjdXB8ZHppZ3JhcnJ8ZG90ZXFkb3R8RG90RXF1YWx8ZG90bWludXN8VW5kZXJCYXJ8Tm90RXF1YWx8cmVhbHBhcnR8b3RpbWVzYXN8dWxjb3JuZXJ8aGtzZWFyb3d8aGtzd2Fyb3d8cGFyYWxsZWx8UGFydGlhbER8ZWxpbnRlcnN8ZW1wdHlzZXR8cGx1c2FjaXJ8YmJya3Ricmt8YW5nbXNkYWR8cG9pbnRpbnR8Ymlnb3BsdXN8YW5nbXNkYWV8UHJlY2VkZXN8Ymlnc3FjdXB8dmFya2FwcGF8bm90aW5kb3R8c3Vwc2V0ZXF8cHJlY25lcXF8cHJlY25zaW18cHJvZmFsYXJ8cHJvZmxpbmV8cHJvZnN1cmZ8bGVxc2xhbnR8bGVzZG90b3J8cmFlbXB0eXZ8c3VicGx1c3xub3RuaXZifG5vdG5pdmN8c3VicmFycnx6aWdyYXJyfHZ6aWd6YWd8c3VibXVsdHxzdWJlZG90fEVsZW1lbnR8YmV0d2VlbnxjaXJzY2lyfGxhcnJiZnN8bGFycnNpbXxsb3RpbWVzfGxicmtzbGR8bGJya3NsdXxsb3plbmdlfGxkcmRoYXJ8ZGJrYXJvd3xiaWdjaXJjfGVwc2lsb258c2ltcmFycnxzaW1wbHVzfGx0cXVlc3R8RXBzaWxvbnxsdXJ1aGFyfGd0cXVlc3R8bWFsdGVzZXxucG9saW50fGVxY29sb258bnByZWNlcXxiaWdvZG90fGRkYWdnZXJ8Z3RybGVzc3xibmVxdWl2fGhhcnJjaXJ8ZGRvdHNlcXxlcXVpdkREfGJhY2tzaW18ZGVtcHR5dnxuc3FzdWJlfG5zcXN1cGV8VXBzaWxvbnxuc3Vic2V0fHVwc2lsb258bWludXNkdXxuc3VjY2VxfHN3YXJyb3d8bnN1cHNldHxjb2xvbmVxfHNlYXJyb3d8Ym94cGx1c3xuYXBwcm94fG5hdHVyYWx8YXN5bXBlcXxhbGVmc3ltfGNvbmdkb3R8bmVhcnJvd3xiaWdzdGFyfGRpYW1vbmR8c3VwcGx1c3x0cml0aW1lfExlZnRUZWV8bnZpbmZpbnx0cmlwbHVzfE5ld0xpbmV8bnZsdHJpZXxudnJ0cmllfG53YXJyb3d8bmV4aXN0c3xEaWFtb25kfHJ1bHVoYXJ8SW1wbGllc3xzdXBtdWx0fGFuZ3phcnJ8c3VwbGFycnxzdXBoc3VifHF1ZXN0ZXF8YmVjYXVzZXxkaWdhbW1hfEJlY2F1c2V8b2xjcm9zc3xiZW1wdHl2fG9taWNyb258T21pY3Jvbnxyb3RpbWVzfE5vQnJlYWt8aW50cHJvZHxhbmdydHZifG9yZGVyb2Z8dXdhbmdsZXxzdXBoc29sfGxlc2RvdG98b3JzbG9wZXxEb3duVGVlfHJlYWxpbmV8Y3VkYXJybHxyZGxkaGFyfE92ZXJCYXJ8c3VwZWRvdHxsZXNzZG90fHN1cGRzdWJ8dG9wZm9ya3xzdWNjc2ltfHJicmtzbHV8cmJya3NsZHxwZXJ0ZW5rfGN1ZGFycnJ8aXNpbmRvdHxwbGFuY2tofGxlc3NndHJ8cGx1c2NpcnxnZXNkb3RvfHBsdXNzaW18cGx1c3R3b3xsZXNzc2ltfGN1bGFycnB8cmFycnNpbXxDYXlsZXlzfG5vdGludmF8bm90aW52Ynxub3RpbnZjfFVwQXJyb3d8VXBhcnJvd3x1cGFycm93fE5vdExlc3N8ZHdhbmdsZXxwcmVjc2ltfFByb2R1Y3R8Y3VyYXJybXxDY29uaW50fGRvdHBsdXN8cmFycmJmc3xjY3Vwc3NtfENlZGlsbGF8Y2VtcHR5dnxub3RuaXZhfHF1YXRpbnR8ZnJhYzM1fGZyYWMzOHxmcmFjNDV8ZnJhYzU2fGZyYWM1OHxmcmFjNzh8dHJpZG90fHhvcGx1c3xnYWN1dGV8Z2FtbWFkfEdhbW1hZHxsZmlzaHR8bGZsb29yfGJpZ2N1cHxzcXN1cGV8Z2JyZXZlfEdicmV2ZXxsaGFydWx8c3FzdWJlfHNxY3Vwc3xHY2VkaWx8YXBhY2lyfGxsaGFyZHxsbWlkb3R8TG1pZG90fGxtb3VzdHxhbmRhbmR8c3FjYXBzfGFwcHJveHxBYnJldmV8c3BhZGVzfGNpcmNlcXx0cHJpbWV8ZGl2aWRlfHRvcGNpcnxBc3NpZ258dG9wYm90fGdlc2RvdHxkaXZvbnh8eHVwbHVzfHRpbWVzZHxnZXNsZXN8YXRpbGRlfHNvbGJhcnxTT0ZUY3l8bG9wbHVzfHRpbWVzYnxsb3dhc3R8bG93YmFyfGRsY29ybnxkbGNyb3B8c29mdGN5fGRvbGxhcnxscGFybHR8dGhrc2ltfGxyaGFyZHxBdGlsZGV8bHNhcXVvfHNtYXNocHxiaWd2ZWV8dGhpbnNwfHdyZWF0aHxia2Fyb3d8bHNxdW9yfGxzdHJva3xMc3Ryb2t8bHRocmVlfGx0aW1lc3xsdGxhcnJ8RG90RG90fHNpbWRvdHxsdHJQYXJ8d2VpZXJwfHhzcWN1cHxhbmdtc2R8c2lnbWF2fHNpZ21hZnx6ZWV0cmZ8WmNhcm9ufHpjYXJvbnxtYXBzdG98dnN1cG5lfHRoZXRhdnxjaXJtaWR8bWFya2VyfG1jb21tYXxaYWN1dGV8dnN1Ym5FfHRoZXJlNHxndGxQYXJ8dnN1Ym5lfGJvdHRvbXxndHJhcnJ8U0hDSGN5fHNoY2hjeXxtaWRhc3R8bWlkY2lyfG1pZGRvdHxtaW51c2J8bWludXNkfGd0cmRvdHxib3d0aWV8c2Zyb3dufG1ucGx1c3xtb2RlbHN8Y29sb25lfHNlc3dhcnxDb2xvbmV8bXN0cG9zfHNlYXJoa3xndHJzaW18bmFjdXRlfE5hY3V0ZXxib3hib3h8dGVscmVjfGhhaXJzcHxUY2VkaWx8bmJ1bXBlfHNjbnNpbXxuY2Fyb258TmNhcm9ufG5jZWRpbHxOY2VkaWx8aGFtaWx0fFNjZWRpbHxuZWFyaGt8aGFyZGN5fEhBUkRjeXx0Y2VkaWx8VGNhcm9ufGNvbW1hdHxuZXF1aXZ8bmVzZWFyfHRjYXJvbnx0YXJnZXR8aGVhcnRzfG5leGlzdHx2YXJyaG98c2NlZGlsfFNjYXJvbnxzY2Fyb258aGVsbGlwfFNhY3V0ZXxzYWN1dGV8aGVyY29ufHN3bndhcnxjb21wZm58cnRpbWVzfHJ0aHJlZXxyc3F1b3J8cnNhcXVvfHphY3V0ZXx3ZWRnZXF8aG9tdGh0fGJhcnZlZXxiYXJ3ZWR8QmFyd2VkfHJwYXJndHxob3JiYXJ8Y29uaW50fHN3YXJoa3xyb3BsdXN8bmx0cmllfGhzbGFzaHxoc3Ryb2t8SHN0cm9rfHJtb3VzdHxDb25pbnR8YnByaW1lfGh5YnVsbHxoeXBoZW58aWFjdXRlfElhY3V0ZXxzdXBzdXB8c3Vwc3VifHN1cHNpbXx2YXJwaGl8Y29wcm9kfGJydmJhcnxhZ3JhdmV8U3Vwc2V0fHN1cHNldHxpZ3JhdmV8SWdyYXZlfG5vdGluRXxBZ3JhdmV8aWlpaW50fGlpbmZpbnxjb3B5c3J8d2VkYmFyfFZlcmJhcnx2YW5ncnR8YmVjYXVzfGluY2FyZXx2ZXJiYXJ8aW5vZG90fGJ1bGxldHxkcmNvcm58aW50Y2FsfGRyY3JvcHxjdWxhcnJ8dmVsbGlwfFV0aWxkZXxidW1wZXF8Y3VwY2FwfGRzdHJva3xEc3Ryb2t8Q3VwQ2FwfGN1cGN1cHxjdXBkb3R8ZWFjdXRlfEVhY3V0ZXxzdXBkb3R8aXF1ZXN0fGVhc3RlcnxlY2Fyb258RWNhcm9ufGVjb2xvbnxpc2luc3Z8dXRpbGRlfGl0aWxkZXxJdGlsZGV8Y3VyYXJyfHN1Y2NlcXxCdW1wZXF8Y2FjdXRlfHVsY3JvcHxucGFyc2x8Q2FjdXRlfG5wcmN1ZXxlZ3JhdmV8RWdyYXZlfG5yYXJyY3xucmFycnd8c3Vic3VwfHN1YnN1YnxucnRyaWV8anNlcmN5fG5zY2N1ZXxKc2VyY3l8a2FwcGF2fGtjZWRpbHxLY2VkaWx8c3Vic2ltfHVsY29ybnxuc2ltZXF8ZWdzZG90fHZlZWJhcnxrZ3JlZW58Y2FwYW5kfGVsc2RvdHxTdWJzZXR8c3Vic2V0fGN1cnJlbnxhYWN1dGV8bGFjdXRlfExhY3V0ZXxlbXB0eXZ8bnRpbGRlfE50aWxkZXxsYWdyYW58bGFtYmRhfExhbWJkYXxjYXBjYXB8VWdyYXZlfGxhbmdsZXxzdWJkb3R8ZW1zcDEzfG51bWVyb3xlbXNwMTR8bnZkYXNofG52RGFzaHxuVmRhc2h8blZEYXNofHVncmF2ZXx1ZmlzaHR8bnZIYXJyfGxhcnJmc3xudmxBcnJ8bGFycmhrfGxhcnJscHxsYXJycGx8bnZyQXJyfFVkYmxhY3xud2FyaGt8bGFycnRsfG53bmVhcnxvYWN1dGV8T2FjdXRlfGxhdGFpbHxsQXRhaWx8c3N0YXJmfGxicmFjZXxvZGJsYWN8T2RibGFjfGxicmFja3x1ZGJsYWN8b2Rzb2xkfGVwYXJzbHxsY2Fyb258TGNhcm9ufG9ncmF2ZXxPZ3JhdmV8bGNlZGlsfExjZWRpbHxBYWN1dGV8c3NtaWxlfHNzZXRtbnxzcXVhcmZ8bGRxdW9yfGNhcGN1cHxvbWludXN8Y3lsY3R5fHJoYXJ1bHxlcWNpcmN8ZGFnZ2VyfHJmbG9vcnxyZmlzaHR8RGFnZ2VyfGRhbGV0aHxlcXVhbHN8b3JpZ29mfGNhcGRvdHxlcXVlc3R8ZGNhcm9ufERjYXJvbnxyZHF1b3J8b3NsYXNofE9zbGFzaHxvdGlsZGV8T3RpbGRlfG90aW1lc3xPdGltZXN8dXJjcm9wfFVicmV2ZXx1YnJldmV8WWFjdXRlfFVhY3V0ZXx1YWN1dGV8UmNlZGlsfHJjZWRpbHx1cmNvcm58cGFyc2ltfFJjYXJvbnxWZGFzaGx8cmNhcm9ufFRzdHJva3xwZXJjbnR8cGVyaW9kfHBlcm1pbHxFeGlzdHN8eWFjdXRlfHJicmFja3xyYnJhY2V8cGhtbWF0fGNjYXJvbnxDY2Fyb258cGxhbmNrfGNjZWRpbHxwbGFua3Z8dHN0cm9rfGZlbWFsZXxwbHVzZG98cGx1c2R1fGZmaWxpZ3xwbHVzbW58ZmZsbGlnfENjZWRpbHxyQXRhaWx8ZGZpc2h0fGJlcm5vdXxyYXRhaWx8UmFycnRsfHJhcnJ0bHxhbmdzcGh8cmFycnBsfHJhcnJscHxyYXJyaGt8eHdlZGdlfHhvdGltZXxmb3JhbGx8Rm9yQWxsfFZ2ZGFzaHx2c3VwbkV8cHJlY2VxfGJpZ2NhcHxmcmFjMTJ8ZnJhYzEzfGZyYWMxNHxwcmltZXN8cmFycmZzfHBybnNpbXxmcmFjMTV8U3F1YXJlfGZyYWMxNnxzcXVhcmV8bGVzZG90fGZyYWMxOHxmcmFjMjN8cHJvcHRvfHBydXJlbHxyYXJyYXB8cmFuZ2xlfHB1bmNzcHxmcmFjMjV8UmFjdXRlfHFwcmltZXxyYWN1dGV8bGVzZ2VzfGZyYWMzNHxhYnJldmV8QUVsaWd8ZXFzaW18dXRkb3R8c2V0bW58dXJ0cml8RXF1YWx8VXJpbmd8c2VBcnJ8dXJpbmd8c2VhcnJ8ZGFzaHZ8RGFzaHZ8bXVtYXB8bmFibGF8aW9nb258SW9nb258c2RvdGV8c2RvdGJ8c2NzaW18bmFwaWR8bmFwb3N8ZXF1aXZ8bmF0dXJ8QWNpcmN8ZGJsYWN8ZXJhcnJ8bmJ1bXB8aXByb2R8ZXJEb3R8dWNpcmN8YXdpbnR8ZXNkb3R8YW5ncnR8bmNvbmd8aXNpbkV8c2NuYXB8U2NpcmN8c2NpcmN8bmRhc2h8aXNpbnN8VWJyY3l8bmVhcnJ8bmVBcnJ8aXNpbnZ8bmVkb3R8dWJyY3l8YWN1dGV8WWNpcmN8aXVrY3l8SXVrY3l8eHV0cml8bmVzaW18Y2FyZXR8amNpcmN8SmNpcmN8Y2Fyb258dHdpeHR8ZGRhcnJ8c2NjdWV8ZXhpc3R8am1hdGh8c2JxdW98bmdlcXF8YW5nc3R8Y2NhcHN8bGNlaWx8bmdzaW18VXBUZWV8ZGVsdGF8RGVsdGF8cnRyaWZ8bmhhcnJ8bmhBcnJ8bmhwYXJ8cnRyaWV8anVrY3l8SnVrY3l8a2FwcGF8cnNxdW98S2FwcGF8bmxhcnJ8bmxBcnJ8VFNIY3l8cnJhcnJ8YW9nb258QW9nb258ZmZsaWd8eHJhcnJ8dHNoY3l8Y2NpcmN8bmxlcXF8ZmlsaWd8dXBzaWh8bmxlc3N8ZGhhcmx8bmxzaW18ZmpsaWd8cm9wYXJ8bmx0cml8ZGhhcnJ8cm9icmt8cm9hcnJ8ZmxsaWd8Zmx0bnN8cm9hbmd8cm5taWR8c3VibkV8c3VibmV8bEFhcnJ8dHJpc2J8Q2NpcmN8YWNpcmN8Y2N1cHN8Ymxhbmt8VkRhc2h8Zm9ya3Z8VmRhc2h8bGFuZ2R8Y2VkaWx8YmxrMTJ8YmxrMTR8bGFxdW98c3RybnN8ZGlhbXN8bm90aW58dkRhc2h8bGFycmJ8YmxrMzR8YmxvY2t8ZGlzaW58dXBsdXN8dmRhc2h8dkJhcnZ8YWVsaWd8c3RhcmZ8V2VkZ2V8Y2hlY2t8eHJBcnJ8bGF0ZXN8bGJhcnJ8bEJhcnJ8bm90bml8bGJicmt8YmNvbmd8ZnJhc2x8bGJya2V8ZnJvd258dnJ0cml8dnByb3B8dm5zdXB8Z2FtbWF8R2FtbWF8d2VkZ2V8eG9kb3R8YmRxdW98c3JhcnJ8ZG90ZXF8bGRxdW98Ym94ZGx8Ym94ZEx8Z2NpcmN8R2NpcmN8Ym94RGx8Ym94REx8Ym94ZHJ8Ym94ZFJ8Ym94RHJ8VFJBREV8dHJhZGV8cmxoYXJ8Ym94RFJ8dm5zdWJ8bnBhcnR8dmx0cml8cmxhcnJ8Ym94aGR8Ym94aER8bnByZWN8Z2VzY2N8bnJhcnJ8bnJBcnJ8Ym94SGR8Ym94SER8Ym94aHV8Ym94aFV8bnJ0cml8Ym94SHV8Y2x1YnN8Ym94SFV8dGltZXN8Y29sb258Q29sb258Z2ltZWx8eGxBcnJ8VGlsZGV8bnNpbWV8dGlsZGV8bnNtaWR8bnNwYXJ8VEhPUk58dGhvcm58eGxhcnJ8bnN1YmV8bnN1YkV8dGhrYXB8eGhBcnJ8Y29tbWF8bnN1Y2N8Ym94dWx8Ym94dUx8bnN1cGV8bnN1cEV8Z25lcXF8Z25zaW18Ym94VWx8Ym94VUx8Z3JhdmV8Ym94dXJ8Ym94dVJ8Ym94VXJ8Ym94VVJ8bGVzY2N8YW5nbGV8YmVwc2l8Ym94dmh8dmFycGl8Ym94dkh8bnVtc3B8VGhldGF8Z3NpbWV8Z3NpbWx8dGhldGF8Ym94Vmh8Ym94Vkh8Ym94dmx8Z3RjaXJ8Z3Rkb3R8Ym94dkx8Ym94Vmx8Ym94Vkx8Y3JhcnJ8Y3Jvc3N8Q3Jvc3N8bnZzaW18Ym94dnJ8bndhcnJ8bndBcnJ8c3FzdXB8ZHRkb3R8VW9nb258bGhhcmR8bGhhcnV8ZHRyaWZ8b2NpcmN8T2NpcmN8bGhibGt8ZHVhcnJ8b2Rhc2h8c3FzdWJ8SGFjZWt8c3FjdXB8bGxhcnJ8ZHVoYXJ8b2VsaWd8T0VsaWd8b2ZjaXJ8Ym94dlJ8dW9nb258bGx0cml8Ym94VnJ8Y3N1YmV8dXVhcnJ8b2hiYXJ8Y3N1cGV8Y3Rkb3R8b2xhcnJ8b2xjaXJ8aGFycnd8b2xpbmV8c3FjYXB8b21hY3J8T21hY3J8b21lZ2F8T21lZ2F8Ym94VlJ8YWxlcGh8bG5lcXF8bG5zaW18bG9hbmd8bG9hcnJ8cmhhcnV8bG9icmt8aGNpcmN8b3BlcnB8b3BsdXN8cmhhcmR8SGNpcmN8b3JhcnJ8VW5pb258b3JkZXJ8ZWNpcmN8RWNpcmN8Y3VlcHJ8c3psaWd8Y3Vlc2N8YnJldmV8cmVhbHN8ZUREb3R8QnJldmV8aG9hcnJ8bG9wYXJ8dXRyaWZ8cmRxdW98VW1hY3J8dW1hY3J8ZWZEb3R8c3dBcnJ8dWx0cml8YWxwaGF8cmNlaWx8b3ZiYXJ8c3dhcnJ8V2NpcmN8d2NpcmN8c210ZXN8c21pbGV8YnNlbWl8bHJhcnJ8YXJpbmd8cGFyc2x8bHJoYXJ8YnNpbWV8dWhibGt8bHJ0cml8Y3Vwb3J8QXJpbmd8dWhhcnJ8dWhhcmx8c2xhcnJ8cmJya2V8YnNvbGJ8bHNpbWV8cmJicmt8UkJhcnJ8bHNpbWd8cGhvbmV8ckJhcnJ8cmJhcnJ8aWNpcmN8bHNxdW98SWNpcmN8ZW1hY3J8RW1hY3J8cmF0aW98c2ltbmV8cGx1c2J8c2ltbEV8c2ltZ0V8c2ltZXF8cGx1c2V8bHRjaXJ8bHRkb3R8ZW1wdHl8eGhhcnJ8eGR0cml8aWV4Y2x8QWxwaGF8bHRyaWV8cmFycnd8cG91bmR8bHRyaWZ8eGNpcmN8YnVtcGV8cHJjdWV8YnVtcEV8YXN5bXB8YW1hY3J8Y3V2ZWV8U2lnbWF8c2lnbWF8aWlpbnR8dWRoYXJ8aWlvdGF8aWpsaWd8SUpsaWd8c3VwbkV8aW1hY3J8SW1hY3J8cHJpbWV8UHJpbWV8aW1hZ2V8cHJuYXB8ZW9nb258RW9nb258cmFycmN8bWRhc2h8bUREb3R8Y3V3ZWR8aW1hdGh8c3VwbmV8aW1wZWR8QW1hY3J8dWRhcnJ8cHJzaW18bWljcm98cmFycmJ8Y3dpbnR8cmFxdW98aW5maW58ZXBsdXN8cmFuZ2V8cmFuZ2R8VWNpcmN8cmFkaWN8bWludXN8YW1hbGd8dmVlZXF8ckFhcnJ8ZXBzaXZ8eWNpcmN8cXVlc3R8c2hhcnB8cXVvdHx6d25qfFFzY3J8cmFjZXxxc2NyfFFvcGZ8cW9wZnxxaW50fHJhbmd8UmFuZ3xac2NyfHpzY3J8Wm9wZnx6b3BmfHJhcnJ8ckFycnxSYXJyfFBzY3J8cHNjcnxwcm9wfHByb2R8cHJuRXxwcmVjfFpIY3l8emhjeXxwcmFwfFpldGF8emV0YXxQb3BmfHBvcGZ8WmRvdHxwbHVzfHpkb3R8WXVtbHx5dW1sfHBoaXZ8WVVjeXx5dWN5fFlzY3J8eXNjcnxwZXJwfFlvcGZ8eW9wZnxwYXJ0fHBhcmF8WUljeXxPdW1sfHJjdWJ8eWljeXxZQWN5fHJkY2F8b3VtbHxvc29sfE9zY3J8cmRzaHx5YWN5fHJlYWx8b3Njcnx4dmVlfGFuZGR8cmVjdHxhbmR2fFhzY3J8b3JvcnxvcmRtfG9yZGZ8eHNjcnxhbmdlfGFvcGZ8QW9wZnxySGFyfFhvcGZ8b3BhcnxPb3BmfHhvcGZ8eG5pc3xyaG92fG9vcGZ8b21pZHx4bWFwfG9pbnR8YXBpZHxhcG9zfG9nb258YXNjcnxBc2NyfG9kb3R8b2Rpdnx4Y3VwfHhjYXB8b2NpcnxvYXN0fG52bHR8bnZsZXxudmd0fG52Z2V8bnZhcHxXc2NyfHdzY3J8YXVtbHxudGxnfG50Z2x8bnN1cHxuc3VifG5zaW18TnNjcnxuc2NyfG5zY2V8V29wZnxyaW5nfG5wcmV8d29wZnxucGFyfEF1bWx8QmFydnxiYnJrfE5vcGZ8bm9wZnxubWlkfG5MdHZ8YmV0YXxyb3BmfFJvcGZ8QmV0YXxiZXRofG5sZXN8cnBhcnxubGVxfGJub3R8Yk5vdHxubGRyfE5KY3l8cnNjcnxSc2NyfFZzY3J8dnNjcnxyc3FifG5qY3l8Ym9wZnxuaXNkfEJvcGZ8cnRyaXxWb3BmfG5HdHZ8bmd0cnx2b3BmfGJveGh8Ym94SHxib3h2fG5nZXN8bmdlcXxib3hWfGJzY3J8c2NhcHxCc2NyfGJzaW18VmVydHx2ZXJ0fGJzb2x8YnVsbHxidW1wfGNhcHN8Y2RvdHxuY3VwfHNjbkV8bmNhcHxuYnNwfG5hcEV8Q2RvdHxjZW50fHNkb3R8VmJhcnxuYW5nfHZCYXJ8Y2hjeXxNc2NyfG1zY3J8c2VjdHxzZW1pfENIY3l8TW9wZnxtb3BmfHNleHR8Y2lyY3xjaXJlfG1sZHJ8bWxjcHxjaXJFfGNvbXB8c2hjeXxTSGN5fHZBcnJ8dmFycnxjb25nfGNvcGZ8Q29wZnxjb3B5fENPUFl8bWFsdHxtYWxlfG1hY3J8bHZuRXxjc2NyfGx0cml8c2ltZXxsdGNjfHNpbWd8Q3NjcnxzaW1sfGNzdWJ8VXVtbHxsc3FifGxzaW18dXVtbHxjc3VwfExzY3J8bHNjcnx1dHJpfHNtaWR8bHBhcnxjdXBzfHNtdGV8bG96ZnxkYXJyfExvcGZ8VXNjcnxzb2xifGxvcGZ8c29wZnxTb3BmfGxuZXF8dXNjcnxzcGFyfGRBcnJ8bG5hcHxEYXJyfGRhc2h8U3FydHxMSmN5fGxqY3l8bEhhcnxkSGFyfFVwc2l8dXBzaXxkaWFtfGxlc2d8ZGpjeXxESmN5fGxlcXF8ZG9wZnxEb3BmfGRzY3J8RHNjcnxkc2N5fGxkc2h8bGRjYXxzcXVmfERTY3l8c3NjcnxTc2NyfGRzb2x8bGN1YnxsYXRlfHN0YXJ8U3RhcnxVb3BmfExhcnJ8bEFycnxsYXJyfHVvcGZ8ZHRyaXxkemN5fHN1YmV8c3ViRXxMYW5nfGxhbmd8S3Njcnxrc2NyfEtvcGZ8a29wZnxLSmN5fGtqY3l8S0hjeXxraGN5fERaY3l8ZWNpcnxlZG90fGVEb3R8SnNjcnxqc2NyfHN1Y2N8Sm9wZnxqb3BmfEVkb3R8dUhhcnxlbXNwfGVuc3B8SXVtbHxpdW1sfGVvcGZ8aXNpbnxJc2NyfGlzY3J8RW9wZnxlcGFyfHN1bmd8ZXBzaXxlc2NyfHN1cDF8c3VwMnxzdXAzfElvdGF8aW90YXxzdXBlfHN1cEV8SW9wZnxpb3BmfElPY3l8aW9jeXxFc2NyfGVzaW18RXNpbXxpbW9mfFVhcnJ8UVVPVHx1QXJyfHVhcnJ8ZXVtbHxJRWN5fGllY3l8SWRvdHxFdW1sfGV1cm98ZXhjbHxIc2NyfGhzY3J8SG9wZnxob3BmfFRTY3l8dHNjeXxUc2NyfGhiYXJ8dHNjcnxmbGF0fHRicmt8Zm5vZnxoQXJyfGhhcnJ8aGFsZnxmb3BmfEZvcGZ8dGRvdHxndm5FfGZvcmt8dHJpZXxndGNjfGZzY3J8RnNjcnxnZG90fGdzaW18R3Njcnxnc2NyfEdvcGZ8Z29wZnxnbmVxfEdkb3R8dG9zYXxnbmFwfFRvcGZ8dG9wZnxnZXFxfHRvZWF8R0pjeXxnamN5fHRpbnR8Z2VzbHxtaWR8U2ZyfGdnZ3x0b3B8Z2VzfGdsYXxnbEV8Z2xqfGdlcXxnbmV8Z0VsfGdlbHxnbkV8R2N5fGdjeXxnYXB8VGZyfHRmcnxUY3l8dGN5fEhhdHxUYXV8RmZyfHRhdXxUYWJ8aGZyfEhmcnxmZnJ8RmN5fGZjeXxpY3l8SWN5fGlmZnxFVEh8ZXRofGlmcnxJZnJ8RXRhfGV0YXxpbnR8SW50fFN1cHxzdXB8dWN5fFVjeXxTdW18c3VtfGpjeXxFTkd8dWZyfFVmcnxlbmd8SmN5fGpmcnxlbHN8ZWxsfGVnc3xFZnJ8ZWZyfEpmcnx1bWx8a2N5fEtjeXxFY3l8ZWN5fGtmcnxLZnJ8bGFwfFN1YnxzdWJ8bGF0fGxjeXxMY3l8bGVnfERvdHxkb3R8bEVnfGxlcXxsZXN8c3F1fGRpdnxkaWV8bGZyfExmcnxsZ0V8RGZyfGRmcnxEZWx8ZGVnfERjeXxkY3l8bG5lfGxuRXxzb2x8bG96fHNtdHxDdXB8bHJtfGN1cHxsc2h8THNofHNpbXxzaHl8bWFwfE1hcHxtY3l8TWN5fG1mcnxNZnJ8bWhvfGdmcnxHZnJ8c2ZyfGNpcnxDaGl8Y2hpfG5hcHxDZnJ8dmN5fFZjeXxjZnJ8U2N5fHNjeXxuY3l8TmN5fHZlZXxWZWV8Q2FwfGNhcHxuZnJ8c2NFfHNjZXxOZnJ8bmdlfG5nRXxuR2d8dmZyfFZmcnxuZ3R8Ym90fG5HdHxuaXN8bml2fFJzaHxyc2h8bmxlfG5sRXxibmV8QmZyfGJmcnxuTGx8bmx0fG5MdHxCY3l8YmN5fG5vdHxOb3R8cmxtfHdmcnxXZnJ8bnByfG5zY3xudW18b2N5fGFzdHxPY3l8b2ZyfHhmcnxYZnJ8T2ZyfG9ndHxvaG18YXBFfG9sdHxSaG98YXBlfHJob3xSZnJ8cmZyfG9yZHxSRUd8YW5nfHJlZ3xvcnZ8QW5kfGFuZHxBTVB8UmN5fGFtcHxBZnJ8eWN5fFljeXx5ZW58eWZyfFlmcnxyY3l8cGFyfHBjeXxQY3l8cGZyfFBmcnxwaGl8UGhpfGFmcnxBY3l8YWN5fHpjeXxaY3l8cGl2fGFjRXxhY2R8emZyfFpmcnxwcmV8cHJFfHBzaXxQc2l8cWZyfFFmcnx6d2p8T3J8Z2V8R2d8Z3R8Z2d8ZWx8b1N8bHR8THR8TFR8UmV8bGd8Z2x8ZWd8bmV8SW18aXR8bGV8RER8d3B8d3J8bnV8TnV8ZGR8bEV8U2N8c2N8cGl8UGl8ZWV8YWZ8bGx8TGx8cnh8Z0V8eGl8cG18WGl8aWN8cHJ8UHJ8aW58bml8bXB8bXV8YWN8TXV8b3J8YXB8R3R8R1R8aWkpO3wmKEFhY3V0ZXxBZ3JhdmV8QXRpbGRlfENjZWRpbHxFYWN1dGV8RWdyYXZlfElhY3V0ZXxJZ3JhdmV8TnRpbGRlfE9hY3V0ZXxPZ3JhdmV8T3NsYXNofE90aWxkZXxVYWN1dGV8VWdyYXZlfFlhY3V0ZXxhYWN1dGV8YWdyYXZlfGF0aWxkZXxicnZiYXJ8Y2NlZGlsfGN1cnJlbnxkaXZpZGV8ZWFjdXRlfGVncmF2ZXxmcmFjMTJ8ZnJhYzE0fGZyYWMzNHxpYWN1dGV8aWdyYXZlfGlxdWVzdHxtaWRkb3R8bnRpbGRlfG9hY3V0ZXxvZ3JhdmV8b3NsYXNofG90aWxkZXxwbHVzbW58dWFjdXRlfHVncmF2ZXx5YWN1dGV8QUVsaWd8QWNpcmN8QXJpbmd8RWNpcmN8SWNpcmN8T2NpcmN8VEhPUk58VWNpcmN8YWNpcmN8YWN1dGV8YWVsaWd8YXJpbmd8Y2VkaWx8ZWNpcmN8aWNpcmN8aWV4Y2x8bGFxdW98bWljcm98b2NpcmN8cG91bmR8cmFxdW98c3psaWd8dGhvcm58dGltZXN8dWNpcmN8QXVtbHxDT1BZfEV1bWx8SXVtbHxPdW1sfFFVT1R8VXVtbHxhdW1sfGNlbnR8Y29weXxldW1sfGl1bWx8bWFjcnxuYnNwfG9yZGZ8b3JkbXxvdW1sfHBhcmF8cXVvdHxzZWN0fHN1cDF8c3VwMnxzdXAzfHV1bWx8eXVtbHxBTVB8RVRIfFJFR3xhbXB8ZGVnfGV0aHxub3R8cmVnfHNoeXx1bWx8eWVufEdUfExUfGd0fGx0KSg/ITspKFs9YS16QS1aMC05XT8pfCYjKFswLTldKykoOz8pfCYjW3hYXShbYS1mQS1GMC05XSspKDs/KXwmKFswLTlhLXpBLVpdKykvZztcblx0dmFyIGRlY29kZU1hcCA9IHsnYWFjdXRlJzonXFx4RTEnLCdBYWN1dGUnOidcXHhDMScsJ2FicmV2ZSc6J1xcdTAxMDMnLCdBYnJldmUnOidcXHUwMTAyJywnYWMnOidcXHUyMjNFJywnYWNkJzonXFx1MjIzRicsJ2FjRSc6J1xcdTIyM0VcXHUwMzMzJywnYWNpcmMnOidcXHhFMicsJ0FjaXJjJzonXFx4QzInLCdhY3V0ZSc6J1xceEI0JywnYWN5JzonXFx1MDQzMCcsJ0FjeSc6J1xcdTA0MTAnLCdhZWxpZyc6J1xceEU2JywnQUVsaWcnOidcXHhDNicsJ2FmJzonXFx1MjA2MScsJ2Fmcic6J1xcdUQ4MzVcXHVERDFFJywnQWZyJzonXFx1RDgzNVxcdUREMDQnLCdhZ3JhdmUnOidcXHhFMCcsJ0FncmF2ZSc6J1xceEMwJywnYWxlZnN5bSc6J1xcdTIxMzUnLCdhbGVwaCc6J1xcdTIxMzUnLCdhbHBoYSc6J1xcdTAzQjEnLCdBbHBoYSc6J1xcdTAzOTEnLCdhbWFjcic6J1xcdTAxMDEnLCdBbWFjcic6J1xcdTAxMDAnLCdhbWFsZyc6J1xcdTJBM0YnLCdhbXAnOicmJywnQU1QJzonJicsJ2FuZCc6J1xcdTIyMjcnLCdBbmQnOidcXHUyQTUzJywnYW5kYW5kJzonXFx1MkE1NScsJ2FuZGQnOidcXHUyQTVDJywnYW5kc2xvcGUnOidcXHUyQTU4JywnYW5kdic6J1xcdTJBNUEnLCdhbmcnOidcXHUyMjIwJywnYW5nZSc6J1xcdTI5QTQnLCdhbmdsZSc6J1xcdTIyMjAnLCdhbmdtc2QnOidcXHUyMjIxJywnYW5nbXNkYWEnOidcXHUyOUE4JywnYW5nbXNkYWInOidcXHUyOUE5JywnYW5nbXNkYWMnOidcXHUyOUFBJywnYW5nbXNkYWQnOidcXHUyOUFCJywnYW5nbXNkYWUnOidcXHUyOUFDJywnYW5nbXNkYWYnOidcXHUyOUFEJywnYW5nbXNkYWcnOidcXHUyOUFFJywnYW5nbXNkYWgnOidcXHUyOUFGJywnYW5ncnQnOidcXHUyMjFGJywnYW5ncnR2Yic6J1xcdTIyQkUnLCdhbmdydHZiZCc6J1xcdTI5OUQnLCdhbmdzcGgnOidcXHUyMjIyJywnYW5nc3QnOidcXHhDNScsJ2FuZ3phcnInOidcXHUyMzdDJywnYW9nb24nOidcXHUwMTA1JywnQW9nb24nOidcXHUwMTA0JywnYW9wZic6J1xcdUQ4MzVcXHVERDUyJywnQW9wZic6J1xcdUQ4MzVcXHVERDM4JywnYXAnOidcXHUyMjQ4JywnYXBhY2lyJzonXFx1MkE2RicsJ2FwZSc6J1xcdTIyNEEnLCdhcEUnOidcXHUyQTcwJywnYXBpZCc6J1xcdTIyNEInLCdhcG9zJzonXFwnJywnQXBwbHlGdW5jdGlvbic6J1xcdTIwNjEnLCdhcHByb3gnOidcXHUyMjQ4JywnYXBwcm94ZXEnOidcXHUyMjRBJywnYXJpbmcnOidcXHhFNScsJ0FyaW5nJzonXFx4QzUnLCdhc2NyJzonXFx1RDgzNVxcdURDQjYnLCdBc2NyJzonXFx1RDgzNVxcdURDOUMnLCdBc3NpZ24nOidcXHUyMjU0JywnYXN0JzonKicsJ2FzeW1wJzonXFx1MjI0OCcsJ2FzeW1wZXEnOidcXHUyMjREJywnYXRpbGRlJzonXFx4RTMnLCdBdGlsZGUnOidcXHhDMycsJ2F1bWwnOidcXHhFNCcsJ0F1bWwnOidcXHhDNCcsJ2F3Y29uaW50JzonXFx1MjIzMycsJ2F3aW50JzonXFx1MkExMScsJ2JhY2tjb25nJzonXFx1MjI0QycsJ2JhY2tlcHNpbG9uJzonXFx1MDNGNicsJ2JhY2twcmltZSc6J1xcdTIwMzUnLCdiYWNrc2ltJzonXFx1MjIzRCcsJ2JhY2tzaW1lcSc6J1xcdTIyQ0QnLCdCYWNrc2xhc2gnOidcXHUyMjE2JywnQmFydic6J1xcdTJBRTcnLCdiYXJ2ZWUnOidcXHUyMkJEJywnYmFyd2VkJzonXFx1MjMwNScsJ0JhcndlZCc6J1xcdTIzMDYnLCdiYXJ3ZWRnZSc6J1xcdTIzMDUnLCdiYnJrJzonXFx1MjNCNScsJ2Jicmt0YnJrJzonXFx1MjNCNicsJ2Jjb25nJzonXFx1MjI0QycsJ2JjeSc6J1xcdTA0MzEnLCdCY3knOidcXHUwNDExJywnYmRxdW8nOidcXHUyMDFFJywnYmVjYXVzJzonXFx1MjIzNScsJ2JlY2F1c2UnOidcXHUyMjM1JywnQmVjYXVzZSc6J1xcdTIyMzUnLCdiZW1wdHl2JzonXFx1MjlCMCcsJ2JlcHNpJzonXFx1MDNGNicsJ2Jlcm5vdSc6J1xcdTIxMkMnLCdCZXJub3VsbGlzJzonXFx1MjEyQycsJ2JldGEnOidcXHUwM0IyJywnQmV0YSc6J1xcdTAzOTInLCdiZXRoJzonXFx1MjEzNicsJ2JldHdlZW4nOidcXHUyMjZDJywnYmZyJzonXFx1RDgzNVxcdUREMUYnLCdCZnInOidcXHVEODM1XFx1REQwNScsJ2JpZ2NhcCc6J1xcdTIyQzInLCdiaWdjaXJjJzonXFx1MjVFRicsJ2JpZ2N1cCc6J1xcdTIyQzMnLCdiaWdvZG90JzonXFx1MkEwMCcsJ2JpZ29wbHVzJzonXFx1MkEwMScsJ2JpZ290aW1lcyc6J1xcdTJBMDInLCdiaWdzcWN1cCc6J1xcdTJBMDYnLCdiaWdzdGFyJzonXFx1MjYwNScsJ2JpZ3RyaWFuZ2xlZG93bic6J1xcdTI1QkQnLCdiaWd0cmlhbmdsZXVwJzonXFx1MjVCMycsJ2JpZ3VwbHVzJzonXFx1MkEwNCcsJ2JpZ3ZlZSc6J1xcdTIyQzEnLCdiaWd3ZWRnZSc6J1xcdTIyQzAnLCdia2Fyb3cnOidcXHUyOTBEJywnYmxhY2tsb3plbmdlJzonXFx1MjlFQicsJ2JsYWNrc3F1YXJlJzonXFx1MjVBQScsJ2JsYWNrdHJpYW5nbGUnOidcXHUyNUI0JywnYmxhY2t0cmlhbmdsZWRvd24nOidcXHUyNUJFJywnYmxhY2t0cmlhbmdsZWxlZnQnOidcXHUyNUMyJywnYmxhY2t0cmlhbmdsZXJpZ2h0JzonXFx1MjVCOCcsJ2JsYW5rJzonXFx1MjQyMycsJ2JsazEyJzonXFx1MjU5MicsJ2JsazE0JzonXFx1MjU5MScsJ2JsazM0JzonXFx1MjU5MycsJ2Jsb2NrJzonXFx1MjU4OCcsJ2JuZSc6Jz1cXHUyMEU1JywnYm5lcXVpdic6J1xcdTIyNjFcXHUyMEU1JywnYm5vdCc6J1xcdTIzMTAnLCdiTm90JzonXFx1MkFFRCcsJ2JvcGYnOidcXHVEODM1XFx1REQ1MycsJ0JvcGYnOidcXHVEODM1XFx1REQzOScsJ2JvdCc6J1xcdTIyQTUnLCdib3R0b20nOidcXHUyMkE1JywnYm93dGllJzonXFx1MjJDOCcsJ2JveGJveCc6J1xcdTI5QzknLCdib3hkbCc6J1xcdTI1MTAnLCdib3hkTCc6J1xcdTI1NTUnLCdib3hEbCc6J1xcdTI1NTYnLCdib3hETCc6J1xcdTI1NTcnLCdib3hkcic6J1xcdTI1MEMnLCdib3hkUic6J1xcdTI1NTInLCdib3hEcic6J1xcdTI1NTMnLCdib3hEUic6J1xcdTI1NTQnLCdib3hoJzonXFx1MjUwMCcsJ2JveEgnOidcXHUyNTUwJywnYm94aGQnOidcXHUyNTJDJywnYm94aEQnOidcXHUyNTY1JywnYm94SGQnOidcXHUyNTY0JywnYm94SEQnOidcXHUyNTY2JywnYm94aHUnOidcXHUyNTM0JywnYm94aFUnOidcXHUyNTY4JywnYm94SHUnOidcXHUyNTY3JywnYm94SFUnOidcXHUyNTY5JywnYm94bWludXMnOidcXHUyMjlGJywnYm94cGx1cyc6J1xcdTIyOUUnLCdib3h0aW1lcyc6J1xcdTIyQTAnLCdib3h1bCc6J1xcdTI1MTgnLCdib3h1TCc6J1xcdTI1NUInLCdib3hVbCc6J1xcdTI1NUMnLCdib3hVTCc6J1xcdTI1NUQnLCdib3h1cic6J1xcdTI1MTQnLCdib3h1Uic6J1xcdTI1NTgnLCdib3hVcic6J1xcdTI1NTknLCdib3hVUic6J1xcdTI1NUEnLCdib3h2JzonXFx1MjUwMicsJ2JveFYnOidcXHUyNTUxJywnYm94dmgnOidcXHUyNTNDJywnYm94dkgnOidcXHUyNTZBJywnYm94VmgnOidcXHUyNTZCJywnYm94VkgnOidcXHUyNTZDJywnYm94dmwnOidcXHUyNTI0JywnYm94dkwnOidcXHUyNTYxJywnYm94VmwnOidcXHUyNTYyJywnYm94VkwnOidcXHUyNTYzJywnYm94dnInOidcXHUyNTFDJywnYm94dlInOidcXHUyNTVFJywnYm94VnInOidcXHUyNTVGJywnYm94VlInOidcXHUyNTYwJywnYnByaW1lJzonXFx1MjAzNScsJ2JyZXZlJzonXFx1MDJEOCcsJ0JyZXZlJzonXFx1MDJEOCcsJ2JydmJhcic6J1xceEE2JywnYnNjcic6J1xcdUQ4MzVcXHVEQ0I3JywnQnNjcic6J1xcdTIxMkMnLCdic2VtaSc6J1xcdTIwNEYnLCdic2ltJzonXFx1MjIzRCcsJ2JzaW1lJzonXFx1MjJDRCcsJ2Jzb2wnOidcXFxcJywnYnNvbGInOidcXHUyOUM1JywnYnNvbGhzdWInOidcXHUyN0M4JywnYnVsbCc6J1xcdTIwMjInLCdidWxsZXQnOidcXHUyMDIyJywnYnVtcCc6J1xcdTIyNEUnLCdidW1wZSc6J1xcdTIyNEYnLCdidW1wRSc6J1xcdTJBQUUnLCdidW1wZXEnOidcXHUyMjRGJywnQnVtcGVxJzonXFx1MjI0RScsJ2NhY3V0ZSc6J1xcdTAxMDcnLCdDYWN1dGUnOidcXHUwMTA2JywnY2FwJzonXFx1MjIyOScsJ0NhcCc6J1xcdTIyRDInLCdjYXBhbmQnOidcXHUyQTQ0JywnY2FwYnJjdXAnOidcXHUyQTQ5JywnY2FwY2FwJzonXFx1MkE0QicsJ2NhcGN1cCc6J1xcdTJBNDcnLCdjYXBkb3QnOidcXHUyQTQwJywnQ2FwaXRhbERpZmZlcmVudGlhbEQnOidcXHUyMTQ1JywnY2Fwcyc6J1xcdTIyMjlcXHVGRTAwJywnY2FyZXQnOidcXHUyMDQxJywnY2Fyb24nOidcXHUwMkM3JywnQ2F5bGV5cyc6J1xcdTIxMkQnLCdjY2Fwcyc6J1xcdTJBNEQnLCdjY2Fyb24nOidcXHUwMTBEJywnQ2Nhcm9uJzonXFx1MDEwQycsJ2NjZWRpbCc6J1xceEU3JywnQ2NlZGlsJzonXFx4QzcnLCdjY2lyYyc6J1xcdTAxMDknLCdDY2lyYyc6J1xcdTAxMDgnLCdDY29uaW50JzonXFx1MjIzMCcsJ2NjdXBzJzonXFx1MkE0QycsJ2NjdXBzc20nOidcXHUyQTUwJywnY2RvdCc6J1xcdTAxMEInLCdDZG90JzonXFx1MDEwQScsJ2NlZGlsJzonXFx4QjgnLCdDZWRpbGxhJzonXFx4QjgnLCdjZW1wdHl2JzonXFx1MjlCMicsJ2NlbnQnOidcXHhBMicsJ2NlbnRlcmRvdCc6J1xceEI3JywnQ2VudGVyRG90JzonXFx4QjcnLCdjZnInOidcXHVEODM1XFx1REQyMCcsJ0Nmcic6J1xcdTIxMkQnLCdjaGN5JzonXFx1MDQ0NycsJ0NIY3knOidcXHUwNDI3JywnY2hlY2snOidcXHUyNzEzJywnY2hlY2ttYXJrJzonXFx1MjcxMycsJ2NoaSc6J1xcdTAzQzcnLCdDaGknOidcXHUwM0E3JywnY2lyJzonXFx1MjVDQicsJ2NpcmMnOidcXHUwMkM2JywnY2lyY2VxJzonXFx1MjI1NycsJ2NpcmNsZWFycm93bGVmdCc6J1xcdTIxQkEnLCdjaXJjbGVhcnJvd3JpZ2h0JzonXFx1MjFCQicsJ2NpcmNsZWRhc3QnOidcXHUyMjlCJywnY2lyY2xlZGNpcmMnOidcXHUyMjlBJywnY2lyY2xlZGRhc2gnOidcXHUyMjlEJywnQ2lyY2xlRG90JzonXFx1MjI5OScsJ2NpcmNsZWRSJzonXFx4QUUnLCdjaXJjbGVkUyc6J1xcdTI0QzgnLCdDaXJjbGVNaW51cyc6J1xcdTIyOTYnLCdDaXJjbGVQbHVzJzonXFx1MjI5NScsJ0NpcmNsZVRpbWVzJzonXFx1MjI5NycsJ2NpcmUnOidcXHUyMjU3JywnY2lyRSc6J1xcdTI5QzMnLCdjaXJmbmludCc6J1xcdTJBMTAnLCdjaXJtaWQnOidcXHUyQUVGJywnY2lyc2Npcic6J1xcdTI5QzInLCdDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnOidcXHUyMjMyJywnQ2xvc2VDdXJseURvdWJsZVF1b3RlJzonXFx1MjAxRCcsJ0Nsb3NlQ3VybHlRdW90ZSc6J1xcdTIwMTknLCdjbHVicyc6J1xcdTI2NjMnLCdjbHVic3VpdCc6J1xcdTI2NjMnLCdjb2xvbic6JzonLCdDb2xvbic6J1xcdTIyMzcnLCdjb2xvbmUnOidcXHUyMjU0JywnQ29sb25lJzonXFx1MkE3NCcsJ2NvbG9uZXEnOidcXHUyMjU0JywnY29tbWEnOicsJywnY29tbWF0JzonQCcsJ2NvbXAnOidcXHUyMjAxJywnY29tcGZuJzonXFx1MjIxOCcsJ2NvbXBsZW1lbnQnOidcXHUyMjAxJywnY29tcGxleGVzJzonXFx1MjEwMicsJ2NvbmcnOidcXHUyMjQ1JywnY29uZ2RvdCc6J1xcdTJBNkQnLCdDb25ncnVlbnQnOidcXHUyMjYxJywnY29uaW50JzonXFx1MjIyRScsJ0NvbmludCc6J1xcdTIyMkYnLCdDb250b3VySW50ZWdyYWwnOidcXHUyMjJFJywnY29wZic6J1xcdUQ4MzVcXHVERDU0JywnQ29wZic6J1xcdTIxMDInLCdjb3Byb2QnOidcXHUyMjEwJywnQ29wcm9kdWN0JzonXFx1MjIxMCcsJ2NvcHknOidcXHhBOScsJ0NPUFknOidcXHhBOScsJ2NvcHlzcic6J1xcdTIxMTcnLCdDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsJzonXFx1MjIzMycsJ2NyYXJyJzonXFx1MjFCNScsJ2Nyb3NzJzonXFx1MjcxNycsJ0Nyb3NzJzonXFx1MkEyRicsJ2NzY3InOidcXHVEODM1XFx1RENCOCcsJ0NzY3InOidcXHVEODM1XFx1REM5RScsJ2NzdWInOidcXHUyQUNGJywnY3N1YmUnOidcXHUyQUQxJywnY3N1cCc6J1xcdTJBRDAnLCdjc3VwZSc6J1xcdTJBRDInLCdjdGRvdCc6J1xcdTIyRUYnLCdjdWRhcnJsJzonXFx1MjkzOCcsJ2N1ZGFycnInOidcXHUyOTM1JywnY3VlcHInOidcXHUyMkRFJywnY3Vlc2MnOidcXHUyMkRGJywnY3VsYXJyJzonXFx1MjFCNicsJ2N1bGFycnAnOidcXHUyOTNEJywnY3VwJzonXFx1MjIyQScsJ0N1cCc6J1xcdTIyRDMnLCdjdXBicmNhcCc6J1xcdTJBNDgnLCdjdXBjYXAnOidcXHUyQTQ2JywnQ3VwQ2FwJzonXFx1MjI0RCcsJ2N1cGN1cCc6J1xcdTJBNEEnLCdjdXBkb3QnOidcXHUyMjhEJywnY3Vwb3InOidcXHUyQTQ1JywnY3Vwcyc6J1xcdTIyMkFcXHVGRTAwJywnY3VyYXJyJzonXFx1MjFCNycsJ2N1cmFycm0nOidcXHUyOTNDJywnY3VybHllcXByZWMnOidcXHUyMkRFJywnY3VybHllcXN1Y2MnOidcXHUyMkRGJywnY3VybHl2ZWUnOidcXHUyMkNFJywnY3VybHl3ZWRnZSc6J1xcdTIyQ0YnLCdjdXJyZW4nOidcXHhBNCcsJ2N1cnZlYXJyb3dsZWZ0JzonXFx1MjFCNicsJ2N1cnZlYXJyb3dyaWdodCc6J1xcdTIxQjcnLCdjdXZlZSc6J1xcdTIyQ0UnLCdjdXdlZCc6J1xcdTIyQ0YnLCdjd2NvbmludCc6J1xcdTIyMzInLCdjd2ludCc6J1xcdTIyMzEnLCdjeWxjdHknOidcXHUyMzJEJywnZGFnZ2VyJzonXFx1MjAyMCcsJ0RhZ2dlcic6J1xcdTIwMjEnLCdkYWxldGgnOidcXHUyMTM4JywnZGFycic6J1xcdTIxOTMnLCdkQXJyJzonXFx1MjFEMycsJ0RhcnInOidcXHUyMUExJywnZGFzaCc6J1xcdTIwMTAnLCdkYXNodic6J1xcdTIyQTMnLCdEYXNodic6J1xcdTJBRTQnLCdkYmthcm93JzonXFx1MjkwRicsJ2RibGFjJzonXFx1MDJERCcsJ2RjYXJvbic6J1xcdTAxMEYnLCdEY2Fyb24nOidcXHUwMTBFJywnZGN5JzonXFx1MDQzNCcsJ0RjeSc6J1xcdTA0MTQnLCdkZCc6J1xcdTIxNDYnLCdERCc6J1xcdTIxNDUnLCdkZGFnZ2VyJzonXFx1MjAyMScsJ2RkYXJyJzonXFx1MjFDQScsJ0REb3RyYWhkJzonXFx1MjkxMScsJ2Rkb3RzZXEnOidcXHUyQTc3JywnZGVnJzonXFx4QjAnLCdEZWwnOidcXHUyMjA3JywnZGVsdGEnOidcXHUwM0I0JywnRGVsdGEnOidcXHUwMzk0JywnZGVtcHR5dic6J1xcdTI5QjEnLCdkZmlzaHQnOidcXHUyOTdGJywnZGZyJzonXFx1RDgzNVxcdUREMjEnLCdEZnInOidcXHVEODM1XFx1REQwNycsJ2RIYXInOidcXHUyOTY1JywnZGhhcmwnOidcXHUyMUMzJywnZGhhcnInOidcXHUyMUMyJywnRGlhY3JpdGljYWxBY3V0ZSc6J1xceEI0JywnRGlhY3JpdGljYWxEb3QnOidcXHUwMkQ5JywnRGlhY3JpdGljYWxEb3VibGVBY3V0ZSc6J1xcdTAyREQnLCdEaWFjcml0aWNhbEdyYXZlJzonYCcsJ0RpYWNyaXRpY2FsVGlsZGUnOidcXHUwMkRDJywnZGlhbSc6J1xcdTIyQzQnLCdkaWFtb25kJzonXFx1MjJDNCcsJ0RpYW1vbmQnOidcXHUyMkM0JywnZGlhbW9uZHN1aXQnOidcXHUyNjY2JywnZGlhbXMnOidcXHUyNjY2JywnZGllJzonXFx4QTgnLCdEaWZmZXJlbnRpYWxEJzonXFx1MjE0NicsJ2RpZ2FtbWEnOidcXHUwM0REJywnZGlzaW4nOidcXHUyMkYyJywnZGl2JzonXFx4RjcnLCdkaXZpZGUnOidcXHhGNycsJ2RpdmlkZW9udGltZXMnOidcXHUyMkM3JywnZGl2b254JzonXFx1MjJDNycsJ2RqY3knOidcXHUwNDUyJywnREpjeSc6J1xcdTA0MDInLCdkbGNvcm4nOidcXHUyMzFFJywnZGxjcm9wJzonXFx1MjMwRCcsJ2RvbGxhcic6JyQnLCdkb3BmJzonXFx1RDgzNVxcdURENTUnLCdEb3BmJzonXFx1RDgzNVxcdUREM0InLCdkb3QnOidcXHUwMkQ5JywnRG90JzonXFx4QTgnLCdEb3REb3QnOidcXHUyMERDJywnZG90ZXEnOidcXHUyMjUwJywnZG90ZXFkb3QnOidcXHUyMjUxJywnRG90RXF1YWwnOidcXHUyMjUwJywnZG90bWludXMnOidcXHUyMjM4JywnZG90cGx1cyc6J1xcdTIyMTQnLCdkb3RzcXVhcmUnOidcXHUyMkExJywnZG91YmxlYmFyd2VkZ2UnOidcXHUyMzA2JywnRG91YmxlQ29udG91ckludGVncmFsJzonXFx1MjIyRicsJ0RvdWJsZURvdCc6J1xceEE4JywnRG91YmxlRG93bkFycm93JzonXFx1MjFEMycsJ0RvdWJsZUxlZnRBcnJvdyc6J1xcdTIxRDAnLCdEb3VibGVMZWZ0UmlnaHRBcnJvdyc6J1xcdTIxRDQnLCdEb3VibGVMZWZ0VGVlJzonXFx1MkFFNCcsJ0RvdWJsZUxvbmdMZWZ0QXJyb3cnOidcXHUyN0Y4JywnRG91YmxlTG9uZ0xlZnRSaWdodEFycm93JzonXFx1MjdGQScsJ0RvdWJsZUxvbmdSaWdodEFycm93JzonXFx1MjdGOScsJ0RvdWJsZVJpZ2h0QXJyb3cnOidcXHUyMUQyJywnRG91YmxlUmlnaHRUZWUnOidcXHUyMkE4JywnRG91YmxlVXBBcnJvdyc6J1xcdTIxRDEnLCdEb3VibGVVcERvd25BcnJvdyc6J1xcdTIxRDUnLCdEb3VibGVWZXJ0aWNhbEJhcic6J1xcdTIyMjUnLCdkb3duYXJyb3cnOidcXHUyMTkzJywnRG93bmFycm93JzonXFx1MjFEMycsJ0Rvd25BcnJvdyc6J1xcdTIxOTMnLCdEb3duQXJyb3dCYXInOidcXHUyOTEzJywnRG93bkFycm93VXBBcnJvdyc6J1xcdTIxRjUnLCdEb3duQnJldmUnOidcXHUwMzExJywnZG93bmRvd25hcnJvd3MnOidcXHUyMUNBJywnZG93bmhhcnBvb25sZWZ0JzonXFx1MjFDMycsJ2Rvd25oYXJwb29ucmlnaHQnOidcXHUyMUMyJywnRG93bkxlZnRSaWdodFZlY3Rvcic6J1xcdTI5NTAnLCdEb3duTGVmdFRlZVZlY3Rvcic6J1xcdTI5NUUnLCdEb3duTGVmdFZlY3Rvcic6J1xcdTIxQkQnLCdEb3duTGVmdFZlY3RvckJhcic6J1xcdTI5NTYnLCdEb3duUmlnaHRUZWVWZWN0b3InOidcXHUyOTVGJywnRG93blJpZ2h0VmVjdG9yJzonXFx1MjFDMScsJ0Rvd25SaWdodFZlY3RvckJhcic6J1xcdTI5NTcnLCdEb3duVGVlJzonXFx1MjJBNCcsJ0Rvd25UZWVBcnJvdyc6J1xcdTIxQTcnLCdkcmJrYXJvdyc6J1xcdTI5MTAnLCdkcmNvcm4nOidcXHUyMzFGJywnZHJjcm9wJzonXFx1MjMwQycsJ2RzY3InOidcXHVEODM1XFx1RENCOScsJ0RzY3InOidcXHVEODM1XFx1REM5RicsJ2RzY3knOidcXHUwNDU1JywnRFNjeSc6J1xcdTA0MDUnLCdkc29sJzonXFx1MjlGNicsJ2RzdHJvayc6J1xcdTAxMTEnLCdEc3Ryb2snOidcXHUwMTEwJywnZHRkb3QnOidcXHUyMkYxJywnZHRyaSc6J1xcdTI1QkYnLCdkdHJpZic6J1xcdTI1QkUnLCdkdWFycic6J1xcdTIxRjUnLCdkdWhhcic6J1xcdTI5NkYnLCdkd2FuZ2xlJzonXFx1MjlBNicsJ2R6Y3knOidcXHUwNDVGJywnRFpjeSc6J1xcdTA0MEYnLCdkemlncmFycic6J1xcdTI3RkYnLCdlYWN1dGUnOidcXHhFOScsJ0VhY3V0ZSc6J1xceEM5JywnZWFzdGVyJzonXFx1MkE2RScsJ2VjYXJvbic6J1xcdTAxMUInLCdFY2Fyb24nOidcXHUwMTFBJywnZWNpcic6J1xcdTIyNTYnLCdlY2lyYyc6J1xceEVBJywnRWNpcmMnOidcXHhDQScsJ2Vjb2xvbic6J1xcdTIyNTUnLCdlY3knOidcXHUwNDREJywnRWN5JzonXFx1MDQyRCcsJ2VERG90JzonXFx1MkE3NycsJ2Vkb3QnOidcXHUwMTE3JywnZURvdCc6J1xcdTIyNTEnLCdFZG90JzonXFx1MDExNicsJ2VlJzonXFx1MjE0NycsJ2VmRG90JzonXFx1MjI1MicsJ2Vmcic6J1xcdUQ4MzVcXHVERDIyJywnRWZyJzonXFx1RDgzNVxcdUREMDgnLCdlZyc6J1xcdTJBOUEnLCdlZ3JhdmUnOidcXHhFOCcsJ0VncmF2ZSc6J1xceEM4JywnZWdzJzonXFx1MkE5NicsJ2Vnc2RvdCc6J1xcdTJBOTgnLCdlbCc6J1xcdTJBOTknLCdFbGVtZW50JzonXFx1MjIwOCcsJ2VsaW50ZXJzJzonXFx1MjNFNycsJ2VsbCc6J1xcdTIxMTMnLCdlbHMnOidcXHUyQTk1JywnZWxzZG90JzonXFx1MkE5NycsJ2VtYWNyJzonXFx1MDExMycsJ0VtYWNyJzonXFx1MDExMicsJ2VtcHR5JzonXFx1MjIwNScsJ2VtcHR5c2V0JzonXFx1MjIwNScsJ0VtcHR5U21hbGxTcXVhcmUnOidcXHUyNUZCJywnZW1wdHl2JzonXFx1MjIwNScsJ0VtcHR5VmVyeVNtYWxsU3F1YXJlJzonXFx1MjVBQicsJ2Vtc3AnOidcXHUyMDAzJywnZW1zcDEzJzonXFx1MjAwNCcsJ2Vtc3AxNCc6J1xcdTIwMDUnLCdlbmcnOidcXHUwMTRCJywnRU5HJzonXFx1MDE0QScsJ2Vuc3AnOidcXHUyMDAyJywnZW9nb24nOidcXHUwMTE5JywnRW9nb24nOidcXHUwMTE4JywnZW9wZic6J1xcdUQ4MzVcXHVERDU2JywnRW9wZic6J1xcdUQ4MzVcXHVERDNDJywnZXBhcic6J1xcdTIyRDUnLCdlcGFyc2wnOidcXHUyOUUzJywnZXBsdXMnOidcXHUyQTcxJywnZXBzaSc6J1xcdTAzQjUnLCdlcHNpbG9uJzonXFx1MDNCNScsJ0Vwc2lsb24nOidcXHUwMzk1JywnZXBzaXYnOidcXHUwM0Y1JywnZXFjaXJjJzonXFx1MjI1NicsJ2VxY29sb24nOidcXHUyMjU1JywnZXFzaW0nOidcXHUyMjQyJywnZXFzbGFudGd0cic6J1xcdTJBOTYnLCdlcXNsYW50bGVzcyc6J1xcdTJBOTUnLCdFcXVhbCc6J1xcdTJBNzUnLCdlcXVhbHMnOic9JywnRXF1YWxUaWxkZSc6J1xcdTIyNDInLCdlcXVlc3QnOidcXHUyMjVGJywnRXF1aWxpYnJpdW0nOidcXHUyMUNDJywnZXF1aXYnOidcXHUyMjYxJywnZXF1aXZERCc6J1xcdTJBNzgnLCdlcXZwYXJzbCc6J1xcdTI5RTUnLCdlcmFycic6J1xcdTI5NzEnLCdlckRvdCc6J1xcdTIyNTMnLCdlc2NyJzonXFx1MjEyRicsJ0VzY3InOidcXHUyMTMwJywnZXNkb3QnOidcXHUyMjUwJywnZXNpbSc6J1xcdTIyNDInLCdFc2ltJzonXFx1MkE3MycsJ2V0YSc6J1xcdTAzQjcnLCdFdGEnOidcXHUwMzk3JywnZXRoJzonXFx4RjAnLCdFVEgnOidcXHhEMCcsJ2V1bWwnOidcXHhFQicsJ0V1bWwnOidcXHhDQicsJ2V1cm8nOidcXHUyMEFDJywnZXhjbCc6JyEnLCdleGlzdCc6J1xcdTIyMDMnLCdFeGlzdHMnOidcXHUyMjAzJywnZXhwZWN0YXRpb24nOidcXHUyMTMwJywnZXhwb25lbnRpYWxlJzonXFx1MjE0NycsJ0V4cG9uZW50aWFsRSc6J1xcdTIxNDcnLCdmYWxsaW5nZG90c2VxJzonXFx1MjI1MicsJ2ZjeSc6J1xcdTA0NDQnLCdGY3knOidcXHUwNDI0JywnZmVtYWxlJzonXFx1MjY0MCcsJ2ZmaWxpZyc6J1xcdUZCMDMnLCdmZmxpZyc6J1xcdUZCMDAnLCdmZmxsaWcnOidcXHVGQjA0JywnZmZyJzonXFx1RDgzNVxcdUREMjMnLCdGZnInOidcXHVEODM1XFx1REQwOScsJ2ZpbGlnJzonXFx1RkIwMScsJ0ZpbGxlZFNtYWxsU3F1YXJlJzonXFx1MjVGQycsJ0ZpbGxlZFZlcnlTbWFsbFNxdWFyZSc6J1xcdTI1QUEnLCdmamxpZyc6J2ZqJywnZmxhdCc6J1xcdTI2NkQnLCdmbGxpZyc6J1xcdUZCMDInLCdmbHRucyc6J1xcdTI1QjEnLCdmbm9mJzonXFx1MDE5MicsJ2ZvcGYnOidcXHVEODM1XFx1REQ1NycsJ0ZvcGYnOidcXHVEODM1XFx1REQzRCcsJ2ZvcmFsbCc6J1xcdTIyMDAnLCdGb3JBbGwnOidcXHUyMjAwJywnZm9yayc6J1xcdTIyRDQnLCdmb3Jrdic6J1xcdTJBRDknLCdGb3VyaWVydHJmJzonXFx1MjEzMScsJ2ZwYXJ0aW50JzonXFx1MkEwRCcsJ2ZyYWMxMic6J1xceEJEJywnZnJhYzEzJzonXFx1MjE1MycsJ2ZyYWMxNCc6J1xceEJDJywnZnJhYzE1JzonXFx1MjE1NScsJ2ZyYWMxNic6J1xcdTIxNTknLCdmcmFjMTgnOidcXHUyMTVCJywnZnJhYzIzJzonXFx1MjE1NCcsJ2ZyYWMyNSc6J1xcdTIxNTYnLCdmcmFjMzQnOidcXHhCRScsJ2ZyYWMzNSc6J1xcdTIxNTcnLCdmcmFjMzgnOidcXHUyMTVDJywnZnJhYzQ1JzonXFx1MjE1OCcsJ2ZyYWM1Nic6J1xcdTIxNUEnLCdmcmFjNTgnOidcXHUyMTVEJywnZnJhYzc4JzonXFx1MjE1RScsJ2ZyYXNsJzonXFx1MjA0NCcsJ2Zyb3duJzonXFx1MjMyMicsJ2ZzY3InOidcXHVEODM1XFx1RENCQicsJ0ZzY3InOidcXHUyMTMxJywnZ2FjdXRlJzonXFx1MDFGNScsJ2dhbW1hJzonXFx1MDNCMycsJ0dhbW1hJzonXFx1MDM5MycsJ2dhbW1hZCc6J1xcdTAzREQnLCdHYW1tYWQnOidcXHUwM0RDJywnZ2FwJzonXFx1MkE4NicsJ2dicmV2ZSc6J1xcdTAxMUYnLCdHYnJldmUnOidcXHUwMTFFJywnR2NlZGlsJzonXFx1MDEyMicsJ2djaXJjJzonXFx1MDExRCcsJ0djaXJjJzonXFx1MDExQycsJ2djeSc6J1xcdTA0MzMnLCdHY3knOidcXHUwNDEzJywnZ2RvdCc6J1xcdTAxMjEnLCdHZG90JzonXFx1MDEyMCcsJ2dlJzonXFx1MjI2NScsJ2dFJzonXFx1MjI2NycsJ2dlbCc6J1xcdTIyREInLCdnRWwnOidcXHUyQThDJywnZ2VxJzonXFx1MjI2NScsJ2dlcXEnOidcXHUyMjY3JywnZ2Vxc2xhbnQnOidcXHUyQTdFJywnZ2VzJzonXFx1MkE3RScsJ2dlc2NjJzonXFx1MkFBOScsJ2dlc2RvdCc6J1xcdTJBODAnLCdnZXNkb3RvJzonXFx1MkE4MicsJ2dlc2RvdG9sJzonXFx1MkE4NCcsJ2dlc2wnOidcXHUyMkRCXFx1RkUwMCcsJ2dlc2xlcyc6J1xcdTJBOTQnLCdnZnInOidcXHVEODM1XFx1REQyNCcsJ0dmcic6J1xcdUQ4MzVcXHVERDBBJywnZ2cnOidcXHUyMjZCJywnR2cnOidcXHUyMkQ5JywnZ2dnJzonXFx1MjJEOScsJ2dpbWVsJzonXFx1MjEzNycsJ2dqY3knOidcXHUwNDUzJywnR0pjeSc6J1xcdTA0MDMnLCdnbCc6J1xcdTIyNzcnLCdnbGEnOidcXHUyQUE1JywnZ2xFJzonXFx1MkE5MicsJ2dsaic6J1xcdTJBQTQnLCdnbmFwJzonXFx1MkE4QScsJ2duYXBwcm94JzonXFx1MkE4QScsJ2duZSc6J1xcdTJBODgnLCdnbkUnOidcXHUyMjY5JywnZ25lcSc6J1xcdTJBODgnLCdnbmVxcSc6J1xcdTIyNjknLCdnbnNpbSc6J1xcdTIyRTcnLCdnb3BmJzonXFx1RDgzNVxcdURENTgnLCdHb3BmJzonXFx1RDgzNVxcdUREM0UnLCdncmF2ZSc6J2AnLCdHcmVhdGVyRXF1YWwnOidcXHUyMjY1JywnR3JlYXRlckVxdWFsTGVzcyc6J1xcdTIyREInLCdHcmVhdGVyRnVsbEVxdWFsJzonXFx1MjI2NycsJ0dyZWF0ZXJHcmVhdGVyJzonXFx1MkFBMicsJ0dyZWF0ZXJMZXNzJzonXFx1MjI3NycsJ0dyZWF0ZXJTbGFudEVxdWFsJzonXFx1MkE3RScsJ0dyZWF0ZXJUaWxkZSc6J1xcdTIyNzMnLCdnc2NyJzonXFx1MjEwQScsJ0dzY3InOidcXHVEODM1XFx1RENBMicsJ2dzaW0nOidcXHUyMjczJywnZ3NpbWUnOidcXHUyQThFJywnZ3NpbWwnOidcXHUyQTkwJywnZ3QnOic+JywnR3QnOidcXHUyMjZCJywnR1QnOic+JywnZ3RjYyc6J1xcdTJBQTcnLCdndGNpcic6J1xcdTJBN0EnLCdndGRvdCc6J1xcdTIyRDcnLCdndGxQYXInOidcXHUyOTk1JywnZ3RxdWVzdCc6J1xcdTJBN0MnLCdndHJhcHByb3gnOidcXHUyQTg2JywnZ3RyYXJyJzonXFx1Mjk3OCcsJ2d0cmRvdCc6J1xcdTIyRDcnLCdndHJlcWxlc3MnOidcXHUyMkRCJywnZ3RyZXFxbGVzcyc6J1xcdTJBOEMnLCdndHJsZXNzJzonXFx1MjI3NycsJ2d0cnNpbSc6J1xcdTIyNzMnLCdndmVydG5lcXEnOidcXHUyMjY5XFx1RkUwMCcsJ2d2bkUnOidcXHUyMjY5XFx1RkUwMCcsJ0hhY2VrJzonXFx1MDJDNycsJ2hhaXJzcCc6J1xcdTIwMEEnLCdoYWxmJzonXFx4QkQnLCdoYW1pbHQnOidcXHUyMTBCJywnaGFyZGN5JzonXFx1MDQ0QScsJ0hBUkRjeSc6J1xcdTA0MkEnLCdoYXJyJzonXFx1MjE5NCcsJ2hBcnInOidcXHUyMUQ0JywnaGFycmNpcic6J1xcdTI5NDgnLCdoYXJydyc6J1xcdTIxQUQnLCdIYXQnOideJywnaGJhcic6J1xcdTIxMEYnLCdoY2lyYyc6J1xcdTAxMjUnLCdIY2lyYyc6J1xcdTAxMjQnLCdoZWFydHMnOidcXHUyNjY1JywnaGVhcnRzdWl0JzonXFx1MjY2NScsJ2hlbGxpcCc6J1xcdTIwMjYnLCdoZXJjb24nOidcXHUyMkI5JywnaGZyJzonXFx1RDgzNVxcdUREMjUnLCdIZnInOidcXHUyMTBDJywnSGlsYmVydFNwYWNlJzonXFx1MjEwQicsJ2hrc2Vhcm93JzonXFx1MjkyNScsJ2hrc3dhcm93JzonXFx1MjkyNicsJ2hvYXJyJzonXFx1MjFGRicsJ2hvbXRodCc6J1xcdTIyM0InLCdob29rbGVmdGFycm93JzonXFx1MjFBOScsJ2hvb2tyaWdodGFycm93JzonXFx1MjFBQScsJ2hvcGYnOidcXHVEODM1XFx1REQ1OScsJ0hvcGYnOidcXHUyMTBEJywnaG9yYmFyJzonXFx1MjAxNScsJ0hvcml6b250YWxMaW5lJzonXFx1MjUwMCcsJ2hzY3InOidcXHVEODM1XFx1RENCRCcsJ0hzY3InOidcXHUyMTBCJywnaHNsYXNoJzonXFx1MjEwRicsJ2hzdHJvayc6J1xcdTAxMjcnLCdIc3Ryb2snOidcXHUwMTI2JywnSHVtcERvd25IdW1wJzonXFx1MjI0RScsJ0h1bXBFcXVhbCc6J1xcdTIyNEYnLCdoeWJ1bGwnOidcXHUyMDQzJywnaHlwaGVuJzonXFx1MjAxMCcsJ2lhY3V0ZSc6J1xceEVEJywnSWFjdXRlJzonXFx4Q0QnLCdpYyc6J1xcdTIwNjMnLCdpY2lyYyc6J1xceEVFJywnSWNpcmMnOidcXHhDRScsJ2ljeSc6J1xcdTA0MzgnLCdJY3knOidcXHUwNDE4JywnSWRvdCc6J1xcdTAxMzAnLCdpZWN5JzonXFx1MDQzNScsJ0lFY3knOidcXHUwNDE1JywnaWV4Y2wnOidcXHhBMScsJ2lmZic6J1xcdTIxRDQnLCdpZnInOidcXHVEODM1XFx1REQyNicsJ0lmcic6J1xcdTIxMTEnLCdpZ3JhdmUnOidcXHhFQycsJ0lncmF2ZSc6J1xceENDJywnaWknOidcXHUyMTQ4JywnaWlpaW50JzonXFx1MkEwQycsJ2lpaW50JzonXFx1MjIyRCcsJ2lpbmZpbic6J1xcdTI5REMnLCdpaW90YSc6J1xcdTIxMjknLCdpamxpZyc6J1xcdTAxMzMnLCdJSmxpZyc6J1xcdTAxMzInLCdJbSc6J1xcdTIxMTEnLCdpbWFjcic6J1xcdTAxMkInLCdJbWFjcic6J1xcdTAxMkEnLCdpbWFnZSc6J1xcdTIxMTEnLCdJbWFnaW5hcnlJJzonXFx1MjE0OCcsJ2ltYWdsaW5lJzonXFx1MjExMCcsJ2ltYWdwYXJ0JzonXFx1MjExMScsJ2ltYXRoJzonXFx1MDEzMScsJ2ltb2YnOidcXHUyMkI3JywnaW1wZWQnOidcXHUwMUI1JywnSW1wbGllcyc6J1xcdTIxRDInLCdpbic6J1xcdTIyMDgnLCdpbmNhcmUnOidcXHUyMTA1JywnaW5maW4nOidcXHUyMjFFJywnaW5maW50aWUnOidcXHUyOUREJywnaW5vZG90JzonXFx1MDEzMScsJ2ludCc6J1xcdTIyMkInLCdJbnQnOidcXHUyMjJDJywnaW50Y2FsJzonXFx1MjJCQScsJ2ludGVnZXJzJzonXFx1MjEyNCcsJ0ludGVncmFsJzonXFx1MjIyQicsJ2ludGVyY2FsJzonXFx1MjJCQScsJ0ludGVyc2VjdGlvbic6J1xcdTIyQzInLCdpbnRsYXJoayc6J1xcdTJBMTcnLCdpbnRwcm9kJzonXFx1MkEzQycsJ0ludmlzaWJsZUNvbW1hJzonXFx1MjA2MycsJ0ludmlzaWJsZVRpbWVzJzonXFx1MjA2MicsJ2lvY3knOidcXHUwNDUxJywnSU9jeSc6J1xcdTA0MDEnLCdpb2dvbic6J1xcdTAxMkYnLCdJb2dvbic6J1xcdTAxMkUnLCdpb3BmJzonXFx1RDgzNVxcdURENUEnLCdJb3BmJzonXFx1RDgzNVxcdURENDAnLCdpb3RhJzonXFx1MDNCOScsJ0lvdGEnOidcXHUwMzk5JywnaXByb2QnOidcXHUyQTNDJywnaXF1ZXN0JzonXFx4QkYnLCdpc2NyJzonXFx1RDgzNVxcdURDQkUnLCdJc2NyJzonXFx1MjExMCcsJ2lzaW4nOidcXHUyMjA4JywnaXNpbmRvdCc6J1xcdTIyRjUnLCdpc2luRSc6J1xcdTIyRjknLCdpc2lucyc6J1xcdTIyRjQnLCdpc2luc3YnOidcXHUyMkYzJywnaXNpbnYnOidcXHUyMjA4JywnaXQnOidcXHUyMDYyJywnaXRpbGRlJzonXFx1MDEyOScsJ0l0aWxkZSc6J1xcdTAxMjgnLCdpdWtjeSc6J1xcdTA0NTYnLCdJdWtjeSc6J1xcdTA0MDYnLCdpdW1sJzonXFx4RUYnLCdJdW1sJzonXFx4Q0YnLCdqY2lyYyc6J1xcdTAxMzUnLCdKY2lyYyc6J1xcdTAxMzQnLCdqY3knOidcXHUwNDM5JywnSmN5JzonXFx1MDQxOScsJ2pmcic6J1xcdUQ4MzVcXHVERDI3JywnSmZyJzonXFx1RDgzNVxcdUREMEQnLCdqbWF0aCc6J1xcdTAyMzcnLCdqb3BmJzonXFx1RDgzNVxcdURENUInLCdKb3BmJzonXFx1RDgzNVxcdURENDEnLCdqc2NyJzonXFx1RDgzNVxcdURDQkYnLCdKc2NyJzonXFx1RDgzNVxcdURDQTUnLCdqc2VyY3knOidcXHUwNDU4JywnSnNlcmN5JzonXFx1MDQwOCcsJ2p1a2N5JzonXFx1MDQ1NCcsJ0p1a2N5JzonXFx1MDQwNCcsJ2thcHBhJzonXFx1MDNCQScsJ0thcHBhJzonXFx1MDM5QScsJ2thcHBhdic6J1xcdTAzRjAnLCdrY2VkaWwnOidcXHUwMTM3JywnS2NlZGlsJzonXFx1MDEzNicsJ2tjeSc6J1xcdTA0M0EnLCdLY3knOidcXHUwNDFBJywna2ZyJzonXFx1RDgzNVxcdUREMjgnLCdLZnInOidcXHVEODM1XFx1REQwRScsJ2tncmVlbic6J1xcdTAxMzgnLCdraGN5JzonXFx1MDQ0NScsJ0tIY3knOidcXHUwNDI1Jywna2pjeSc6J1xcdTA0NUMnLCdLSmN5JzonXFx1MDQwQycsJ2tvcGYnOidcXHVEODM1XFx1REQ1QycsJ0tvcGYnOidcXHVEODM1XFx1REQ0MicsJ2tzY3InOidcXHVEODM1XFx1RENDMCcsJ0tzY3InOidcXHVEODM1XFx1RENBNicsJ2xBYXJyJzonXFx1MjFEQScsJ2xhY3V0ZSc6J1xcdTAxM0EnLCdMYWN1dGUnOidcXHUwMTM5JywnbGFlbXB0eXYnOidcXHUyOUI0JywnbGFncmFuJzonXFx1MjExMicsJ2xhbWJkYSc6J1xcdTAzQkInLCdMYW1iZGEnOidcXHUwMzlCJywnbGFuZyc6J1xcdTI3RTgnLCdMYW5nJzonXFx1MjdFQScsJ2xhbmdkJzonXFx1Mjk5MScsJ2xhbmdsZSc6J1xcdTI3RTgnLCdsYXAnOidcXHUyQTg1JywnTGFwbGFjZXRyZic6J1xcdTIxMTInLCdsYXF1byc6J1xceEFCJywnbGFycic6J1xcdTIxOTAnLCdsQXJyJzonXFx1MjFEMCcsJ0xhcnInOidcXHUyMTlFJywnbGFycmInOidcXHUyMUU0JywnbGFycmJmcyc6J1xcdTI5MUYnLCdsYXJyZnMnOidcXHUyOTFEJywnbGFycmhrJzonXFx1MjFBOScsJ2xhcnJscCc6J1xcdTIxQUInLCdsYXJycGwnOidcXHUyOTM5JywnbGFycnNpbSc6J1xcdTI5NzMnLCdsYXJydGwnOidcXHUyMUEyJywnbGF0JzonXFx1MkFBQicsJ2xhdGFpbCc6J1xcdTI5MTknLCdsQXRhaWwnOidcXHUyOTFCJywnbGF0ZSc6J1xcdTJBQUQnLCdsYXRlcyc6J1xcdTJBQURcXHVGRTAwJywnbGJhcnInOidcXHUyOTBDJywnbEJhcnInOidcXHUyOTBFJywnbGJicmsnOidcXHUyNzcyJywnbGJyYWNlJzoneycsJ2xicmFjayc6J1snLCdsYnJrZSc6J1xcdTI5OEInLCdsYnJrc2xkJzonXFx1Mjk4RicsJ2xicmtzbHUnOidcXHUyOThEJywnbGNhcm9uJzonXFx1MDEzRScsJ0xjYXJvbic6J1xcdTAxM0QnLCdsY2VkaWwnOidcXHUwMTNDJywnTGNlZGlsJzonXFx1MDEzQicsJ2xjZWlsJzonXFx1MjMwOCcsJ2xjdWInOid7JywnbGN5JzonXFx1MDQzQicsJ0xjeSc6J1xcdTA0MUInLCdsZGNhJzonXFx1MjkzNicsJ2xkcXVvJzonXFx1MjAxQycsJ2xkcXVvcic6J1xcdTIwMUUnLCdsZHJkaGFyJzonXFx1Mjk2NycsJ2xkcnVzaGFyJzonXFx1Mjk0QicsJ2xkc2gnOidcXHUyMUIyJywnbGUnOidcXHUyMjY0JywnbEUnOidcXHUyMjY2JywnTGVmdEFuZ2xlQnJhY2tldCc6J1xcdTI3RTgnLCdsZWZ0YXJyb3cnOidcXHUyMTkwJywnTGVmdGFycm93JzonXFx1MjFEMCcsJ0xlZnRBcnJvdyc6J1xcdTIxOTAnLCdMZWZ0QXJyb3dCYXInOidcXHUyMUU0JywnTGVmdEFycm93UmlnaHRBcnJvdyc6J1xcdTIxQzYnLCdsZWZ0YXJyb3d0YWlsJzonXFx1MjFBMicsJ0xlZnRDZWlsaW5nJzonXFx1MjMwOCcsJ0xlZnREb3VibGVCcmFja2V0JzonXFx1MjdFNicsJ0xlZnREb3duVGVlVmVjdG9yJzonXFx1Mjk2MScsJ0xlZnREb3duVmVjdG9yJzonXFx1MjFDMycsJ0xlZnREb3duVmVjdG9yQmFyJzonXFx1Mjk1OScsJ0xlZnRGbG9vcic6J1xcdTIzMEEnLCdsZWZ0aGFycG9vbmRvd24nOidcXHUyMUJEJywnbGVmdGhhcnBvb251cCc6J1xcdTIxQkMnLCdsZWZ0bGVmdGFycm93cyc6J1xcdTIxQzcnLCdsZWZ0cmlnaHRhcnJvdyc6J1xcdTIxOTQnLCdMZWZ0cmlnaHRhcnJvdyc6J1xcdTIxRDQnLCdMZWZ0UmlnaHRBcnJvdyc6J1xcdTIxOTQnLCdsZWZ0cmlnaHRhcnJvd3MnOidcXHUyMUM2JywnbGVmdHJpZ2h0aGFycG9vbnMnOidcXHUyMUNCJywnbGVmdHJpZ2h0c3F1aWdhcnJvdyc6J1xcdTIxQUQnLCdMZWZ0UmlnaHRWZWN0b3InOidcXHUyOTRFJywnTGVmdFRlZSc6J1xcdTIyQTMnLCdMZWZ0VGVlQXJyb3cnOidcXHUyMUE0JywnTGVmdFRlZVZlY3Rvcic6J1xcdTI5NUEnLCdsZWZ0dGhyZWV0aW1lcyc6J1xcdTIyQ0InLCdMZWZ0VHJpYW5nbGUnOidcXHUyMkIyJywnTGVmdFRyaWFuZ2xlQmFyJzonXFx1MjlDRicsJ0xlZnRUcmlhbmdsZUVxdWFsJzonXFx1MjJCNCcsJ0xlZnRVcERvd25WZWN0b3InOidcXHUyOTUxJywnTGVmdFVwVGVlVmVjdG9yJzonXFx1Mjk2MCcsJ0xlZnRVcFZlY3Rvcic6J1xcdTIxQkYnLCdMZWZ0VXBWZWN0b3JCYXInOidcXHUyOTU4JywnTGVmdFZlY3Rvcic6J1xcdTIxQkMnLCdMZWZ0VmVjdG9yQmFyJzonXFx1Mjk1MicsJ2xlZyc6J1xcdTIyREEnLCdsRWcnOidcXHUyQThCJywnbGVxJzonXFx1MjI2NCcsJ2xlcXEnOidcXHUyMjY2JywnbGVxc2xhbnQnOidcXHUyQTdEJywnbGVzJzonXFx1MkE3RCcsJ2xlc2NjJzonXFx1MkFBOCcsJ2xlc2RvdCc6J1xcdTJBN0YnLCdsZXNkb3RvJzonXFx1MkE4MScsJ2xlc2RvdG9yJzonXFx1MkE4MycsJ2xlc2cnOidcXHUyMkRBXFx1RkUwMCcsJ2xlc2dlcyc6J1xcdTJBOTMnLCdsZXNzYXBwcm94JzonXFx1MkE4NScsJ2xlc3Nkb3QnOidcXHUyMkQ2JywnbGVzc2VxZ3RyJzonXFx1MjJEQScsJ2xlc3NlcXFndHInOidcXHUyQThCJywnTGVzc0VxdWFsR3JlYXRlcic6J1xcdTIyREEnLCdMZXNzRnVsbEVxdWFsJzonXFx1MjI2NicsJ0xlc3NHcmVhdGVyJzonXFx1MjI3NicsJ2xlc3NndHInOidcXHUyMjc2JywnTGVzc0xlc3MnOidcXHUyQUExJywnbGVzc3NpbSc6J1xcdTIyNzInLCdMZXNzU2xhbnRFcXVhbCc6J1xcdTJBN0QnLCdMZXNzVGlsZGUnOidcXHUyMjcyJywnbGZpc2h0JzonXFx1Mjk3QycsJ2xmbG9vcic6J1xcdTIzMEEnLCdsZnInOidcXHVEODM1XFx1REQyOScsJ0xmcic6J1xcdUQ4MzVcXHVERDBGJywnbGcnOidcXHUyMjc2JywnbGdFJzonXFx1MkE5MScsJ2xIYXInOidcXHUyOTYyJywnbGhhcmQnOidcXHUyMUJEJywnbGhhcnUnOidcXHUyMUJDJywnbGhhcnVsJzonXFx1Mjk2QScsJ2xoYmxrJzonXFx1MjU4NCcsJ2xqY3knOidcXHUwNDU5JywnTEpjeSc6J1xcdTA0MDknLCdsbCc6J1xcdTIyNkEnLCdMbCc6J1xcdTIyRDgnLCdsbGFycic6J1xcdTIxQzcnLCdsbGNvcm5lcic6J1xcdTIzMUUnLCdMbGVmdGFycm93JzonXFx1MjFEQScsJ2xsaGFyZCc6J1xcdTI5NkInLCdsbHRyaSc6J1xcdTI1RkEnLCdsbWlkb3QnOidcXHUwMTQwJywnTG1pZG90JzonXFx1MDEzRicsJ2xtb3VzdCc6J1xcdTIzQjAnLCdsbW91c3RhY2hlJzonXFx1MjNCMCcsJ2xuYXAnOidcXHUyQTg5JywnbG5hcHByb3gnOidcXHUyQTg5JywnbG5lJzonXFx1MkE4NycsJ2xuRSc6J1xcdTIyNjgnLCdsbmVxJzonXFx1MkE4NycsJ2xuZXFxJzonXFx1MjI2OCcsJ2xuc2ltJzonXFx1MjJFNicsJ2xvYW5nJzonXFx1MjdFQycsJ2xvYXJyJzonXFx1MjFGRCcsJ2xvYnJrJzonXFx1MjdFNicsJ2xvbmdsZWZ0YXJyb3cnOidcXHUyN0Y1JywnTG9uZ2xlZnRhcnJvdyc6J1xcdTI3RjgnLCdMb25nTGVmdEFycm93JzonXFx1MjdGNScsJ2xvbmdsZWZ0cmlnaHRhcnJvdyc6J1xcdTI3RjcnLCdMb25nbGVmdHJpZ2h0YXJyb3cnOidcXHUyN0ZBJywnTG9uZ0xlZnRSaWdodEFycm93JzonXFx1MjdGNycsJ2xvbmdtYXBzdG8nOidcXHUyN0ZDJywnbG9uZ3JpZ2h0YXJyb3cnOidcXHUyN0Y2JywnTG9uZ3JpZ2h0YXJyb3cnOidcXHUyN0Y5JywnTG9uZ1JpZ2h0QXJyb3cnOidcXHUyN0Y2JywnbG9vcGFycm93bGVmdCc6J1xcdTIxQUInLCdsb29wYXJyb3dyaWdodCc6J1xcdTIxQUMnLCdsb3Bhcic6J1xcdTI5ODUnLCdsb3BmJzonXFx1RDgzNVxcdURENUQnLCdMb3BmJzonXFx1RDgzNVxcdURENDMnLCdsb3BsdXMnOidcXHUyQTJEJywnbG90aW1lcyc6J1xcdTJBMzQnLCdsb3dhc3QnOidcXHUyMjE3JywnbG93YmFyJzonXycsJ0xvd2VyTGVmdEFycm93JzonXFx1MjE5OScsJ0xvd2VyUmlnaHRBcnJvdyc6J1xcdTIxOTgnLCdsb3onOidcXHUyNUNBJywnbG96ZW5nZSc6J1xcdTI1Q0EnLCdsb3pmJzonXFx1MjlFQicsJ2xwYXInOicoJywnbHBhcmx0JzonXFx1Mjk5MycsJ2xyYXJyJzonXFx1MjFDNicsJ2xyY29ybmVyJzonXFx1MjMxRicsJ2xyaGFyJzonXFx1MjFDQicsJ2xyaGFyZCc6J1xcdTI5NkQnLCdscm0nOidcXHUyMDBFJywnbHJ0cmknOidcXHUyMkJGJywnbHNhcXVvJzonXFx1MjAzOScsJ2xzY3InOidcXHVEODM1XFx1RENDMScsJ0xzY3InOidcXHUyMTEyJywnbHNoJzonXFx1MjFCMCcsJ0xzaCc6J1xcdTIxQjAnLCdsc2ltJzonXFx1MjI3MicsJ2xzaW1lJzonXFx1MkE4RCcsJ2xzaW1nJzonXFx1MkE4RicsJ2xzcWInOidbJywnbHNxdW8nOidcXHUyMDE4JywnbHNxdW9yJzonXFx1MjAxQScsJ2xzdHJvayc6J1xcdTAxNDInLCdMc3Ryb2snOidcXHUwMTQxJywnbHQnOic8JywnTHQnOidcXHUyMjZBJywnTFQnOic8JywnbHRjYyc6J1xcdTJBQTYnLCdsdGNpcic6J1xcdTJBNzknLCdsdGRvdCc6J1xcdTIyRDYnLCdsdGhyZWUnOidcXHUyMkNCJywnbHRpbWVzJzonXFx1MjJDOScsJ2x0bGFycic6J1xcdTI5NzYnLCdsdHF1ZXN0JzonXFx1MkE3QicsJ2x0cmknOidcXHUyNUMzJywnbHRyaWUnOidcXHUyMkI0JywnbHRyaWYnOidcXHUyNUMyJywnbHRyUGFyJzonXFx1Mjk5NicsJ2x1cmRzaGFyJzonXFx1Mjk0QScsJ2x1cnVoYXInOidcXHUyOTY2JywnbHZlcnRuZXFxJzonXFx1MjI2OFxcdUZFMDAnLCdsdm5FJzonXFx1MjI2OFxcdUZFMDAnLCdtYWNyJzonXFx4QUYnLCdtYWxlJzonXFx1MjY0MicsJ21hbHQnOidcXHUyNzIwJywnbWFsdGVzZSc6J1xcdTI3MjAnLCdtYXAnOidcXHUyMUE2JywnTWFwJzonXFx1MjkwNScsJ21hcHN0byc6J1xcdTIxQTYnLCdtYXBzdG9kb3duJzonXFx1MjFBNycsJ21hcHN0b2xlZnQnOidcXHUyMUE0JywnbWFwc3RvdXAnOidcXHUyMUE1JywnbWFya2VyJzonXFx1MjVBRScsJ21jb21tYSc6J1xcdTJBMjknLCdtY3knOidcXHUwNDNDJywnTWN5JzonXFx1MDQxQycsJ21kYXNoJzonXFx1MjAxNCcsJ21ERG90JzonXFx1MjIzQScsJ21lYXN1cmVkYW5nbGUnOidcXHUyMjIxJywnTWVkaXVtU3BhY2UnOidcXHUyMDVGJywnTWVsbGludHJmJzonXFx1MjEzMycsJ21mcic6J1xcdUQ4MzVcXHVERDJBJywnTWZyJzonXFx1RDgzNVxcdUREMTAnLCdtaG8nOidcXHUyMTI3JywnbWljcm8nOidcXHhCNScsJ21pZCc6J1xcdTIyMjMnLCdtaWRhc3QnOicqJywnbWlkY2lyJzonXFx1MkFGMCcsJ21pZGRvdCc6J1xceEI3JywnbWludXMnOidcXHUyMjEyJywnbWludXNiJzonXFx1MjI5RicsJ21pbnVzZCc6J1xcdTIyMzgnLCdtaW51c2R1JzonXFx1MkEyQScsJ01pbnVzUGx1cyc6J1xcdTIyMTMnLCdtbGNwJzonXFx1MkFEQicsJ21sZHInOidcXHUyMDI2JywnbW5wbHVzJzonXFx1MjIxMycsJ21vZGVscyc6J1xcdTIyQTcnLCdtb3BmJzonXFx1RDgzNVxcdURENUUnLCdNb3BmJzonXFx1RDgzNVxcdURENDQnLCdtcCc6J1xcdTIyMTMnLCdtc2NyJzonXFx1RDgzNVxcdURDQzInLCdNc2NyJzonXFx1MjEzMycsJ21zdHBvcyc6J1xcdTIyM0UnLCdtdSc6J1xcdTAzQkMnLCdNdSc6J1xcdTAzOUMnLCdtdWx0aW1hcCc6J1xcdTIyQjgnLCdtdW1hcCc6J1xcdTIyQjgnLCduYWJsYSc6J1xcdTIyMDcnLCduYWN1dGUnOidcXHUwMTQ0JywnTmFjdXRlJzonXFx1MDE0MycsJ25hbmcnOidcXHUyMjIwXFx1MjBEMicsJ25hcCc6J1xcdTIyNDknLCduYXBFJzonXFx1MkE3MFxcdTAzMzgnLCduYXBpZCc6J1xcdTIyNEJcXHUwMzM4JywnbmFwb3MnOidcXHUwMTQ5JywnbmFwcHJveCc6J1xcdTIyNDknLCduYXR1cic6J1xcdTI2NkUnLCduYXR1cmFsJzonXFx1MjY2RScsJ25hdHVyYWxzJzonXFx1MjExNScsJ25ic3AnOidcXHhBMCcsJ25idW1wJzonXFx1MjI0RVxcdTAzMzgnLCduYnVtcGUnOidcXHUyMjRGXFx1MDMzOCcsJ25jYXAnOidcXHUyQTQzJywnbmNhcm9uJzonXFx1MDE0OCcsJ05jYXJvbic6J1xcdTAxNDcnLCduY2VkaWwnOidcXHUwMTQ2JywnTmNlZGlsJzonXFx1MDE0NScsJ25jb25nJzonXFx1MjI0NycsJ25jb25nZG90JzonXFx1MkE2RFxcdTAzMzgnLCduY3VwJzonXFx1MkE0MicsJ25jeSc6J1xcdTA0M0QnLCdOY3knOidcXHUwNDFEJywnbmRhc2gnOidcXHUyMDEzJywnbmUnOidcXHUyMjYwJywnbmVhcmhrJzonXFx1MjkyNCcsJ25lYXJyJzonXFx1MjE5NycsJ25lQXJyJzonXFx1MjFENycsJ25lYXJyb3cnOidcXHUyMTk3JywnbmVkb3QnOidcXHUyMjUwXFx1MDMzOCcsJ05lZ2F0aXZlTWVkaXVtU3BhY2UnOidcXHUyMDBCJywnTmVnYXRpdmVUaGlja1NwYWNlJzonXFx1MjAwQicsJ05lZ2F0aXZlVGhpblNwYWNlJzonXFx1MjAwQicsJ05lZ2F0aXZlVmVyeVRoaW5TcGFjZSc6J1xcdTIwMEInLCduZXF1aXYnOidcXHUyMjYyJywnbmVzZWFyJzonXFx1MjkyOCcsJ25lc2ltJzonXFx1MjI0MlxcdTAzMzgnLCdOZXN0ZWRHcmVhdGVyR3JlYXRlcic6J1xcdTIyNkInLCdOZXN0ZWRMZXNzTGVzcyc6J1xcdTIyNkEnLCdOZXdMaW5lJzonXFxuJywnbmV4aXN0JzonXFx1MjIwNCcsJ25leGlzdHMnOidcXHUyMjA0JywnbmZyJzonXFx1RDgzNVxcdUREMkInLCdOZnInOidcXHVEODM1XFx1REQxMScsJ25nZSc6J1xcdTIyNzEnLCduZ0UnOidcXHUyMjY3XFx1MDMzOCcsJ25nZXEnOidcXHUyMjcxJywnbmdlcXEnOidcXHUyMjY3XFx1MDMzOCcsJ25nZXFzbGFudCc6J1xcdTJBN0VcXHUwMzM4Jywnbmdlcyc6J1xcdTJBN0VcXHUwMzM4JywnbkdnJzonXFx1MjJEOVxcdTAzMzgnLCduZ3NpbSc6J1xcdTIyNzUnLCduZ3QnOidcXHUyMjZGJywnbkd0JzonXFx1MjI2QlxcdTIwRDInLCduZ3RyJzonXFx1MjI2RicsJ25HdHYnOidcXHUyMjZCXFx1MDMzOCcsJ25oYXJyJzonXFx1MjFBRScsJ25oQXJyJzonXFx1MjFDRScsJ25ocGFyJzonXFx1MkFGMicsJ25pJzonXFx1MjIwQicsJ25pcyc6J1xcdTIyRkMnLCduaXNkJzonXFx1MjJGQScsJ25pdic6J1xcdTIyMEInLCduamN5JzonXFx1MDQ1QScsJ05KY3knOidcXHUwNDBBJywnbmxhcnInOidcXHUyMTlBJywnbmxBcnInOidcXHUyMUNEJywnbmxkcic6J1xcdTIwMjUnLCdubGUnOidcXHUyMjcwJywnbmxFJzonXFx1MjI2NlxcdTAzMzgnLCdubGVmdGFycm93JzonXFx1MjE5QScsJ25MZWZ0YXJyb3cnOidcXHUyMUNEJywnbmxlZnRyaWdodGFycm93JzonXFx1MjFBRScsJ25MZWZ0cmlnaHRhcnJvdyc6J1xcdTIxQ0UnLCdubGVxJzonXFx1MjI3MCcsJ25sZXFxJzonXFx1MjI2NlxcdTAzMzgnLCdubGVxc2xhbnQnOidcXHUyQTdEXFx1MDMzOCcsJ25sZXMnOidcXHUyQTdEXFx1MDMzOCcsJ25sZXNzJzonXFx1MjI2RScsJ25MbCc6J1xcdTIyRDhcXHUwMzM4JywnbmxzaW0nOidcXHUyMjc0Jywnbmx0JzonXFx1MjI2RScsJ25MdCc6J1xcdTIyNkFcXHUyMEQyJywnbmx0cmknOidcXHUyMkVBJywnbmx0cmllJzonXFx1MjJFQycsJ25MdHYnOidcXHUyMjZBXFx1MDMzOCcsJ25taWQnOidcXHUyMjI0JywnTm9CcmVhayc6J1xcdTIwNjAnLCdOb25CcmVha2luZ1NwYWNlJzonXFx4QTAnLCdub3BmJzonXFx1RDgzNVxcdURENUYnLCdOb3BmJzonXFx1MjExNScsJ25vdCc6J1xceEFDJywnTm90JzonXFx1MkFFQycsJ05vdENvbmdydWVudCc6J1xcdTIyNjInLCdOb3RDdXBDYXAnOidcXHUyMjZEJywnTm90RG91YmxlVmVydGljYWxCYXInOidcXHUyMjI2JywnTm90RWxlbWVudCc6J1xcdTIyMDknLCdOb3RFcXVhbCc6J1xcdTIyNjAnLCdOb3RFcXVhbFRpbGRlJzonXFx1MjI0MlxcdTAzMzgnLCdOb3RFeGlzdHMnOidcXHUyMjA0JywnTm90R3JlYXRlcic6J1xcdTIyNkYnLCdOb3RHcmVhdGVyRXF1YWwnOidcXHUyMjcxJywnTm90R3JlYXRlckZ1bGxFcXVhbCc6J1xcdTIyNjdcXHUwMzM4JywnTm90R3JlYXRlckdyZWF0ZXInOidcXHUyMjZCXFx1MDMzOCcsJ05vdEdyZWF0ZXJMZXNzJzonXFx1MjI3OScsJ05vdEdyZWF0ZXJTbGFudEVxdWFsJzonXFx1MkE3RVxcdTAzMzgnLCdOb3RHcmVhdGVyVGlsZGUnOidcXHUyMjc1JywnTm90SHVtcERvd25IdW1wJzonXFx1MjI0RVxcdTAzMzgnLCdOb3RIdW1wRXF1YWwnOidcXHUyMjRGXFx1MDMzOCcsJ25vdGluJzonXFx1MjIwOScsJ25vdGluZG90JzonXFx1MjJGNVxcdTAzMzgnLCdub3RpbkUnOidcXHUyMkY5XFx1MDMzOCcsJ25vdGludmEnOidcXHUyMjA5Jywnbm90aW52Yic6J1xcdTIyRjcnLCdub3RpbnZjJzonXFx1MjJGNicsJ05vdExlZnRUcmlhbmdsZSc6J1xcdTIyRUEnLCdOb3RMZWZ0VHJpYW5nbGVCYXInOidcXHUyOUNGXFx1MDMzOCcsJ05vdExlZnRUcmlhbmdsZUVxdWFsJzonXFx1MjJFQycsJ05vdExlc3MnOidcXHUyMjZFJywnTm90TGVzc0VxdWFsJzonXFx1MjI3MCcsJ05vdExlc3NHcmVhdGVyJzonXFx1MjI3OCcsJ05vdExlc3NMZXNzJzonXFx1MjI2QVxcdTAzMzgnLCdOb3RMZXNzU2xhbnRFcXVhbCc6J1xcdTJBN0RcXHUwMzM4JywnTm90TGVzc1RpbGRlJzonXFx1MjI3NCcsJ05vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyJzonXFx1MkFBMlxcdTAzMzgnLCdOb3ROZXN0ZWRMZXNzTGVzcyc6J1xcdTJBQTFcXHUwMzM4Jywnbm90bmknOidcXHUyMjBDJywnbm90bml2YSc6J1xcdTIyMEMnLCdub3RuaXZiJzonXFx1MjJGRScsJ25vdG5pdmMnOidcXHUyMkZEJywnTm90UHJlY2VkZXMnOidcXHUyMjgwJywnTm90UHJlY2VkZXNFcXVhbCc6J1xcdTJBQUZcXHUwMzM4JywnTm90UHJlY2VkZXNTbGFudEVxdWFsJzonXFx1MjJFMCcsJ05vdFJldmVyc2VFbGVtZW50JzonXFx1MjIwQycsJ05vdFJpZ2h0VHJpYW5nbGUnOidcXHUyMkVCJywnTm90UmlnaHRUcmlhbmdsZUJhcic6J1xcdTI5RDBcXHUwMzM4JywnTm90UmlnaHRUcmlhbmdsZUVxdWFsJzonXFx1MjJFRCcsJ05vdFNxdWFyZVN1YnNldCc6J1xcdTIyOEZcXHUwMzM4JywnTm90U3F1YXJlU3Vic2V0RXF1YWwnOidcXHUyMkUyJywnTm90U3F1YXJlU3VwZXJzZXQnOidcXHUyMjkwXFx1MDMzOCcsJ05vdFNxdWFyZVN1cGVyc2V0RXF1YWwnOidcXHUyMkUzJywnTm90U3Vic2V0JzonXFx1MjI4MlxcdTIwRDInLCdOb3RTdWJzZXRFcXVhbCc6J1xcdTIyODgnLCdOb3RTdWNjZWVkcyc6J1xcdTIyODEnLCdOb3RTdWNjZWVkc0VxdWFsJzonXFx1MkFCMFxcdTAzMzgnLCdOb3RTdWNjZWVkc1NsYW50RXF1YWwnOidcXHUyMkUxJywnTm90U3VjY2VlZHNUaWxkZSc6J1xcdTIyN0ZcXHUwMzM4JywnTm90U3VwZXJzZXQnOidcXHUyMjgzXFx1MjBEMicsJ05vdFN1cGVyc2V0RXF1YWwnOidcXHUyMjg5JywnTm90VGlsZGUnOidcXHUyMjQxJywnTm90VGlsZGVFcXVhbCc6J1xcdTIyNDQnLCdOb3RUaWxkZUZ1bGxFcXVhbCc6J1xcdTIyNDcnLCdOb3RUaWxkZVRpbGRlJzonXFx1MjI0OScsJ05vdFZlcnRpY2FsQmFyJzonXFx1MjIyNCcsJ25wYXInOidcXHUyMjI2JywnbnBhcmFsbGVsJzonXFx1MjIyNicsJ25wYXJzbCc6J1xcdTJBRkRcXHUyMEU1JywnbnBhcnQnOidcXHUyMjAyXFx1MDMzOCcsJ25wb2xpbnQnOidcXHUyQTE0JywnbnByJzonXFx1MjI4MCcsJ25wcmN1ZSc6J1xcdTIyRTAnLCducHJlJzonXFx1MkFBRlxcdTAzMzgnLCducHJlYyc6J1xcdTIyODAnLCducHJlY2VxJzonXFx1MkFBRlxcdTAzMzgnLCducmFycic6J1xcdTIxOUInLCduckFycic6J1xcdTIxQ0YnLCducmFycmMnOidcXHUyOTMzXFx1MDMzOCcsJ25yYXJydyc6J1xcdTIxOURcXHUwMzM4JywnbnJpZ2h0YXJyb3cnOidcXHUyMTlCJywnblJpZ2h0YXJyb3cnOidcXHUyMUNGJywnbnJ0cmknOidcXHUyMkVCJywnbnJ0cmllJzonXFx1MjJFRCcsJ25zYyc6J1xcdTIyODEnLCduc2NjdWUnOidcXHUyMkUxJywnbnNjZSc6J1xcdTJBQjBcXHUwMzM4JywnbnNjcic6J1xcdUQ4MzVcXHVEQ0MzJywnTnNjcic6J1xcdUQ4MzVcXHVEQ0E5JywnbnNob3J0bWlkJzonXFx1MjIyNCcsJ25zaG9ydHBhcmFsbGVsJzonXFx1MjIyNicsJ25zaW0nOidcXHUyMjQxJywnbnNpbWUnOidcXHUyMjQ0JywnbnNpbWVxJzonXFx1MjI0NCcsJ25zbWlkJzonXFx1MjIyNCcsJ25zcGFyJzonXFx1MjIyNicsJ25zcXN1YmUnOidcXHUyMkUyJywnbnNxc3VwZSc6J1xcdTIyRTMnLCduc3ViJzonXFx1MjI4NCcsJ25zdWJlJzonXFx1MjI4OCcsJ25zdWJFJzonXFx1MkFDNVxcdTAzMzgnLCduc3Vic2V0JzonXFx1MjI4MlxcdTIwRDInLCduc3Vic2V0ZXEnOidcXHUyMjg4JywnbnN1YnNldGVxcSc6J1xcdTJBQzVcXHUwMzM4JywnbnN1Y2MnOidcXHUyMjgxJywnbnN1Y2NlcSc6J1xcdTJBQjBcXHUwMzM4JywnbnN1cCc6J1xcdTIyODUnLCduc3VwZSc6J1xcdTIyODknLCduc3VwRSc6J1xcdTJBQzZcXHUwMzM4JywnbnN1cHNldCc6J1xcdTIyODNcXHUyMEQyJywnbnN1cHNldGVxJzonXFx1MjI4OScsJ25zdXBzZXRlcXEnOidcXHUyQUM2XFx1MDMzOCcsJ250Z2wnOidcXHUyMjc5JywnbnRpbGRlJzonXFx4RjEnLCdOdGlsZGUnOidcXHhEMScsJ250bGcnOidcXHUyMjc4JywnbnRyaWFuZ2xlbGVmdCc6J1xcdTIyRUEnLCdudHJpYW5nbGVsZWZ0ZXEnOidcXHUyMkVDJywnbnRyaWFuZ2xlcmlnaHQnOidcXHUyMkVCJywnbnRyaWFuZ2xlcmlnaHRlcSc6J1xcdTIyRUQnLCdudSc6J1xcdTAzQkQnLCdOdSc6J1xcdTAzOUQnLCdudW0nOicjJywnbnVtZXJvJzonXFx1MjExNicsJ251bXNwJzonXFx1MjAwNycsJ252YXAnOidcXHUyMjREXFx1MjBEMicsJ252ZGFzaCc6J1xcdTIyQUMnLCdudkRhc2gnOidcXHUyMkFEJywnblZkYXNoJzonXFx1MjJBRScsJ25WRGFzaCc6J1xcdTIyQUYnLCdudmdlJzonXFx1MjI2NVxcdTIwRDInLCdudmd0JzonPlxcdTIwRDInLCdudkhhcnInOidcXHUyOTA0JywnbnZpbmZpbic6J1xcdTI5REUnLCdudmxBcnInOidcXHUyOTAyJywnbnZsZSc6J1xcdTIyNjRcXHUyMEQyJywnbnZsdCc6JzxcXHUyMEQyJywnbnZsdHJpZSc6J1xcdTIyQjRcXHUyMEQyJywnbnZyQXJyJzonXFx1MjkwMycsJ252cnRyaWUnOidcXHUyMkI1XFx1MjBEMicsJ252c2ltJzonXFx1MjIzQ1xcdTIwRDInLCdud2FyaGsnOidcXHUyOTIzJywnbndhcnInOidcXHUyMTk2JywnbndBcnInOidcXHUyMUQ2JywnbndhcnJvdyc6J1xcdTIxOTYnLCdud25lYXInOidcXHUyOTI3Jywnb2FjdXRlJzonXFx4RjMnLCdPYWN1dGUnOidcXHhEMycsJ29hc3QnOidcXHUyMjlCJywnb2Npcic6J1xcdTIyOUEnLCdvY2lyYyc6J1xceEY0JywnT2NpcmMnOidcXHhENCcsJ29jeSc6J1xcdTA0M0UnLCdPY3knOidcXHUwNDFFJywnb2Rhc2gnOidcXHUyMjlEJywnb2RibGFjJzonXFx1MDE1MScsJ09kYmxhYyc6J1xcdTAxNTAnLCdvZGl2JzonXFx1MkEzOCcsJ29kb3QnOidcXHUyMjk5Jywnb2Rzb2xkJzonXFx1MjlCQycsJ29lbGlnJzonXFx1MDE1MycsJ09FbGlnJzonXFx1MDE1MicsJ29mY2lyJzonXFx1MjlCRicsJ29mcic6J1xcdUQ4MzVcXHVERDJDJywnT2ZyJzonXFx1RDgzNVxcdUREMTInLCdvZ29uJzonXFx1MDJEQicsJ29ncmF2ZSc6J1xceEYyJywnT2dyYXZlJzonXFx4RDInLCdvZ3QnOidcXHUyOUMxJywnb2hiYXInOidcXHUyOUI1Jywnb2htJzonXFx1MDNBOScsJ29pbnQnOidcXHUyMjJFJywnb2xhcnInOidcXHUyMUJBJywnb2xjaXInOidcXHUyOUJFJywnb2xjcm9zcyc6J1xcdTI5QkInLCdvbGluZSc6J1xcdTIwM0UnLCdvbHQnOidcXHUyOUMwJywnb21hY3InOidcXHUwMTREJywnT21hY3InOidcXHUwMTRDJywnb21lZ2EnOidcXHUwM0M5JywnT21lZ2EnOidcXHUwM0E5Jywnb21pY3Jvbic6J1xcdTAzQkYnLCdPbWljcm9uJzonXFx1MDM5RicsJ29taWQnOidcXHUyOUI2Jywnb21pbnVzJzonXFx1MjI5NicsJ29vcGYnOidcXHVEODM1XFx1REQ2MCcsJ09vcGYnOidcXHVEODM1XFx1REQ0NicsJ29wYXInOidcXHUyOUI3JywnT3BlbkN1cmx5RG91YmxlUXVvdGUnOidcXHUyMDFDJywnT3BlbkN1cmx5UXVvdGUnOidcXHUyMDE4Jywnb3BlcnAnOidcXHUyOUI5Jywnb3BsdXMnOidcXHUyMjk1Jywnb3InOidcXHUyMjI4JywnT3InOidcXHUyQTU0Jywnb3JhcnInOidcXHUyMUJCJywnb3JkJzonXFx1MkE1RCcsJ29yZGVyJzonXFx1MjEzNCcsJ29yZGVyb2YnOidcXHUyMTM0Jywnb3JkZic6J1xceEFBJywnb3JkbSc6J1xceEJBJywnb3JpZ29mJzonXFx1MjJCNicsJ29yb3InOidcXHUyQTU2Jywnb3JzbG9wZSc6J1xcdTJBNTcnLCdvcnYnOidcXHUyQTVCJywnb1MnOidcXHUyNEM4Jywnb3Njcic6J1xcdTIxMzQnLCdPc2NyJzonXFx1RDgzNVxcdURDQUEnLCdvc2xhc2gnOidcXHhGOCcsJ09zbGFzaCc6J1xceEQ4Jywnb3NvbCc6J1xcdTIyOTgnLCdvdGlsZGUnOidcXHhGNScsJ090aWxkZSc6J1xceEQ1Jywnb3RpbWVzJzonXFx1MjI5NycsJ090aW1lcyc6J1xcdTJBMzcnLCdvdGltZXNhcyc6J1xcdTJBMzYnLCdvdW1sJzonXFx4RjYnLCdPdW1sJzonXFx4RDYnLCdvdmJhcic6J1xcdTIzM0QnLCdPdmVyQmFyJzonXFx1MjAzRScsJ092ZXJCcmFjZSc6J1xcdTIzREUnLCdPdmVyQnJhY2tldCc6J1xcdTIzQjQnLCdPdmVyUGFyZW50aGVzaXMnOidcXHUyM0RDJywncGFyJzonXFx1MjIyNScsJ3BhcmEnOidcXHhCNicsJ3BhcmFsbGVsJzonXFx1MjIyNScsJ3BhcnNpbSc6J1xcdTJBRjMnLCdwYXJzbCc6J1xcdTJBRkQnLCdwYXJ0JzonXFx1MjIwMicsJ1BhcnRpYWxEJzonXFx1MjIwMicsJ3BjeSc6J1xcdTA0M0YnLCdQY3knOidcXHUwNDFGJywncGVyY250JzonJScsJ3BlcmlvZCc6Jy4nLCdwZXJtaWwnOidcXHUyMDMwJywncGVycCc6J1xcdTIyQTUnLCdwZXJ0ZW5rJzonXFx1MjAzMScsJ3Bmcic6J1xcdUQ4MzVcXHVERDJEJywnUGZyJzonXFx1RDgzNVxcdUREMTMnLCdwaGknOidcXHUwM0M2JywnUGhpJzonXFx1MDNBNicsJ3BoaXYnOidcXHUwM0Q1JywncGhtbWF0JzonXFx1MjEzMycsJ3Bob25lJzonXFx1MjYwRScsJ3BpJzonXFx1MDNDMCcsJ1BpJzonXFx1MDNBMCcsJ3BpdGNoZm9yayc6J1xcdTIyRDQnLCdwaXYnOidcXHUwM0Q2JywncGxhbmNrJzonXFx1MjEwRicsJ3BsYW5ja2gnOidcXHUyMTBFJywncGxhbmt2JzonXFx1MjEwRicsJ3BsdXMnOicrJywncGx1c2FjaXInOidcXHUyQTIzJywncGx1c2InOidcXHUyMjlFJywncGx1c2Npcic6J1xcdTJBMjInLCdwbHVzZG8nOidcXHUyMjE0JywncGx1c2R1JzonXFx1MkEyNScsJ3BsdXNlJzonXFx1MkE3MicsJ1BsdXNNaW51cyc6J1xceEIxJywncGx1c21uJzonXFx4QjEnLCdwbHVzc2ltJzonXFx1MkEyNicsJ3BsdXN0d28nOidcXHUyQTI3JywncG0nOidcXHhCMScsJ1BvaW5jYXJlcGxhbmUnOidcXHUyMTBDJywncG9pbnRpbnQnOidcXHUyQTE1JywncG9wZic6J1xcdUQ4MzVcXHVERDYxJywnUG9wZic6J1xcdTIxMTknLCdwb3VuZCc6J1xceEEzJywncHInOidcXHUyMjdBJywnUHInOidcXHUyQUJCJywncHJhcCc6J1xcdTJBQjcnLCdwcmN1ZSc6J1xcdTIyN0MnLCdwcmUnOidcXHUyQUFGJywncHJFJzonXFx1MkFCMycsJ3ByZWMnOidcXHUyMjdBJywncHJlY2FwcHJveCc6J1xcdTJBQjcnLCdwcmVjY3VybHllcSc6J1xcdTIyN0MnLCdQcmVjZWRlcyc6J1xcdTIyN0EnLCdQcmVjZWRlc0VxdWFsJzonXFx1MkFBRicsJ1ByZWNlZGVzU2xhbnRFcXVhbCc6J1xcdTIyN0MnLCdQcmVjZWRlc1RpbGRlJzonXFx1MjI3RScsJ3ByZWNlcSc6J1xcdTJBQUYnLCdwcmVjbmFwcHJveCc6J1xcdTJBQjknLCdwcmVjbmVxcSc6J1xcdTJBQjUnLCdwcmVjbnNpbSc6J1xcdTIyRTgnLCdwcmVjc2ltJzonXFx1MjI3RScsJ3ByaW1lJzonXFx1MjAzMicsJ1ByaW1lJzonXFx1MjAzMycsJ3ByaW1lcyc6J1xcdTIxMTknLCdwcm5hcCc6J1xcdTJBQjknLCdwcm5FJzonXFx1MkFCNScsJ3BybnNpbSc6J1xcdTIyRTgnLCdwcm9kJzonXFx1MjIwRicsJ1Byb2R1Y3QnOidcXHUyMjBGJywncHJvZmFsYXInOidcXHUyMzJFJywncHJvZmxpbmUnOidcXHUyMzEyJywncHJvZnN1cmYnOidcXHUyMzEzJywncHJvcCc6J1xcdTIyMUQnLCdQcm9wb3J0aW9uJzonXFx1MjIzNycsJ1Byb3BvcnRpb25hbCc6J1xcdTIyMUQnLCdwcm9wdG8nOidcXHUyMjFEJywncHJzaW0nOidcXHUyMjdFJywncHJ1cmVsJzonXFx1MjJCMCcsJ3BzY3InOidcXHVEODM1XFx1RENDNScsJ1BzY3InOidcXHVEODM1XFx1RENBQicsJ3BzaSc6J1xcdTAzQzgnLCdQc2knOidcXHUwM0E4JywncHVuY3NwJzonXFx1MjAwOCcsJ3Fmcic6J1xcdUQ4MzVcXHVERDJFJywnUWZyJzonXFx1RDgzNVxcdUREMTQnLCdxaW50JzonXFx1MkEwQycsJ3FvcGYnOidcXHVEODM1XFx1REQ2MicsJ1FvcGYnOidcXHUyMTFBJywncXByaW1lJzonXFx1MjA1NycsJ3FzY3InOidcXHVEODM1XFx1RENDNicsJ1FzY3InOidcXHVEODM1XFx1RENBQycsJ3F1YXRlcm5pb25zJzonXFx1MjEwRCcsJ3F1YXRpbnQnOidcXHUyQTE2JywncXVlc3QnOic/JywncXVlc3RlcSc6J1xcdTIyNUYnLCdxdW90JzonXCInLCdRVU9UJzonXCInLCdyQWFycic6J1xcdTIxREInLCdyYWNlJzonXFx1MjIzRFxcdTAzMzEnLCdyYWN1dGUnOidcXHUwMTU1JywnUmFjdXRlJzonXFx1MDE1NCcsJ3JhZGljJzonXFx1MjIxQScsJ3JhZW1wdHl2JzonXFx1MjlCMycsJ3JhbmcnOidcXHUyN0U5JywnUmFuZyc6J1xcdTI3RUInLCdyYW5nZCc6J1xcdTI5OTInLCdyYW5nZSc6J1xcdTI5QTUnLCdyYW5nbGUnOidcXHUyN0U5JywncmFxdW8nOidcXHhCQicsJ3JhcnInOidcXHUyMTkyJywnckFycic6J1xcdTIxRDInLCdSYXJyJzonXFx1MjFBMCcsJ3JhcnJhcCc6J1xcdTI5NzUnLCdyYXJyYic6J1xcdTIxRTUnLCdyYXJyYmZzJzonXFx1MjkyMCcsJ3JhcnJjJzonXFx1MjkzMycsJ3JhcnJmcyc6J1xcdTI5MUUnLCdyYXJyaGsnOidcXHUyMUFBJywncmFycmxwJzonXFx1MjFBQycsJ3JhcnJwbCc6J1xcdTI5NDUnLCdyYXJyc2ltJzonXFx1Mjk3NCcsJ3JhcnJ0bCc6J1xcdTIxQTMnLCdSYXJydGwnOidcXHUyOTE2JywncmFycncnOidcXHUyMTlEJywncmF0YWlsJzonXFx1MjkxQScsJ3JBdGFpbCc6J1xcdTI5MUMnLCdyYXRpbyc6J1xcdTIyMzYnLCdyYXRpb25hbHMnOidcXHUyMTFBJywncmJhcnInOidcXHUyOTBEJywnckJhcnInOidcXHUyOTBGJywnUkJhcnInOidcXHUyOTEwJywncmJicmsnOidcXHUyNzczJywncmJyYWNlJzonfScsJ3JicmFjayc6J10nLCdyYnJrZSc6J1xcdTI5OEMnLCdyYnJrc2xkJzonXFx1Mjk4RScsJ3JicmtzbHUnOidcXHUyOTkwJywncmNhcm9uJzonXFx1MDE1OScsJ1JjYXJvbic6J1xcdTAxNTgnLCdyY2VkaWwnOidcXHUwMTU3JywnUmNlZGlsJzonXFx1MDE1NicsJ3JjZWlsJzonXFx1MjMwOScsJ3JjdWInOid9JywncmN5JzonXFx1MDQ0MCcsJ1JjeSc6J1xcdTA0MjAnLCdyZGNhJzonXFx1MjkzNycsJ3JkbGRoYXInOidcXHUyOTY5JywncmRxdW8nOidcXHUyMDFEJywncmRxdW9yJzonXFx1MjAxRCcsJ3Jkc2gnOidcXHUyMUIzJywnUmUnOidcXHUyMTFDJywncmVhbCc6J1xcdTIxMUMnLCdyZWFsaW5lJzonXFx1MjExQicsJ3JlYWxwYXJ0JzonXFx1MjExQycsJ3JlYWxzJzonXFx1MjExRCcsJ3JlY3QnOidcXHUyNUFEJywncmVnJzonXFx4QUUnLCdSRUcnOidcXHhBRScsJ1JldmVyc2VFbGVtZW50JzonXFx1MjIwQicsJ1JldmVyc2VFcXVpbGlicml1bSc6J1xcdTIxQ0InLCdSZXZlcnNlVXBFcXVpbGlicml1bSc6J1xcdTI5NkYnLCdyZmlzaHQnOidcXHUyOTdEJywncmZsb29yJzonXFx1MjMwQicsJ3Jmcic6J1xcdUQ4MzVcXHVERDJGJywnUmZyJzonXFx1MjExQycsJ3JIYXInOidcXHUyOTY0JywncmhhcmQnOidcXHUyMUMxJywncmhhcnUnOidcXHUyMUMwJywncmhhcnVsJzonXFx1Mjk2QycsJ3Jobyc6J1xcdTAzQzEnLCdSaG8nOidcXHUwM0ExJywncmhvdic6J1xcdTAzRjEnLCdSaWdodEFuZ2xlQnJhY2tldCc6J1xcdTI3RTknLCdyaWdodGFycm93JzonXFx1MjE5MicsJ1JpZ2h0YXJyb3cnOidcXHUyMUQyJywnUmlnaHRBcnJvdyc6J1xcdTIxOTInLCdSaWdodEFycm93QmFyJzonXFx1MjFFNScsJ1JpZ2h0QXJyb3dMZWZ0QXJyb3cnOidcXHUyMUM0JywncmlnaHRhcnJvd3RhaWwnOidcXHUyMUEzJywnUmlnaHRDZWlsaW5nJzonXFx1MjMwOScsJ1JpZ2h0RG91YmxlQnJhY2tldCc6J1xcdTI3RTcnLCdSaWdodERvd25UZWVWZWN0b3InOidcXHUyOTVEJywnUmlnaHREb3duVmVjdG9yJzonXFx1MjFDMicsJ1JpZ2h0RG93blZlY3RvckJhcic6J1xcdTI5NTUnLCdSaWdodEZsb29yJzonXFx1MjMwQicsJ3JpZ2h0aGFycG9vbmRvd24nOidcXHUyMUMxJywncmlnaHRoYXJwb29udXAnOidcXHUyMUMwJywncmlnaHRsZWZ0YXJyb3dzJzonXFx1MjFDNCcsJ3JpZ2h0bGVmdGhhcnBvb25zJzonXFx1MjFDQycsJ3JpZ2h0cmlnaHRhcnJvd3MnOidcXHUyMUM5JywncmlnaHRzcXVpZ2Fycm93JzonXFx1MjE5RCcsJ1JpZ2h0VGVlJzonXFx1MjJBMicsJ1JpZ2h0VGVlQXJyb3cnOidcXHUyMUE2JywnUmlnaHRUZWVWZWN0b3InOidcXHUyOTVCJywncmlnaHR0aHJlZXRpbWVzJzonXFx1MjJDQycsJ1JpZ2h0VHJpYW5nbGUnOidcXHUyMkIzJywnUmlnaHRUcmlhbmdsZUJhcic6J1xcdTI5RDAnLCdSaWdodFRyaWFuZ2xlRXF1YWwnOidcXHUyMkI1JywnUmlnaHRVcERvd25WZWN0b3InOidcXHUyOTRGJywnUmlnaHRVcFRlZVZlY3Rvcic6J1xcdTI5NUMnLCdSaWdodFVwVmVjdG9yJzonXFx1MjFCRScsJ1JpZ2h0VXBWZWN0b3JCYXInOidcXHUyOTU0JywnUmlnaHRWZWN0b3InOidcXHUyMUMwJywnUmlnaHRWZWN0b3JCYXInOidcXHUyOTUzJywncmluZyc6J1xcdTAyREEnLCdyaXNpbmdkb3RzZXEnOidcXHUyMjUzJywncmxhcnInOidcXHUyMUM0JywncmxoYXInOidcXHUyMUNDJywncmxtJzonXFx1MjAwRicsJ3Jtb3VzdCc6J1xcdTIzQjEnLCdybW91c3RhY2hlJzonXFx1MjNCMScsJ3JubWlkJzonXFx1MkFFRScsJ3JvYW5nJzonXFx1MjdFRCcsJ3JvYXJyJzonXFx1MjFGRScsJ3JvYnJrJzonXFx1MjdFNycsJ3JvcGFyJzonXFx1Mjk4NicsJ3JvcGYnOidcXHVEODM1XFx1REQ2MycsJ1JvcGYnOidcXHUyMTFEJywncm9wbHVzJzonXFx1MkEyRScsJ3JvdGltZXMnOidcXHUyQTM1JywnUm91bmRJbXBsaWVzJzonXFx1Mjk3MCcsJ3JwYXInOicpJywncnBhcmd0JzonXFx1Mjk5NCcsJ3JwcG9saW50JzonXFx1MkExMicsJ3JyYXJyJzonXFx1MjFDOScsJ1JyaWdodGFycm93JzonXFx1MjFEQicsJ3JzYXF1byc6J1xcdTIwM0EnLCdyc2NyJzonXFx1RDgzNVxcdURDQzcnLCdSc2NyJzonXFx1MjExQicsJ3JzaCc6J1xcdTIxQjEnLCdSc2gnOidcXHUyMUIxJywncnNxYic6J10nLCdyc3F1byc6J1xcdTIwMTknLCdyc3F1b3InOidcXHUyMDE5JywncnRocmVlJzonXFx1MjJDQycsJ3J0aW1lcyc6J1xcdTIyQ0EnLCdydHJpJzonXFx1MjVCOScsJ3J0cmllJzonXFx1MjJCNScsJ3J0cmlmJzonXFx1MjVCOCcsJ3J0cmlsdHJpJzonXFx1MjlDRScsJ1J1bGVEZWxheWVkJzonXFx1MjlGNCcsJ3J1bHVoYXInOidcXHUyOTY4JywncngnOidcXHUyMTFFJywnc2FjdXRlJzonXFx1MDE1QicsJ1NhY3V0ZSc6J1xcdTAxNUEnLCdzYnF1byc6J1xcdTIwMUEnLCdzYyc6J1xcdTIyN0InLCdTYyc6J1xcdTJBQkMnLCdzY2FwJzonXFx1MkFCOCcsJ3NjYXJvbic6J1xcdTAxNjEnLCdTY2Fyb24nOidcXHUwMTYwJywnc2NjdWUnOidcXHUyMjdEJywnc2NlJzonXFx1MkFCMCcsJ3NjRSc6J1xcdTJBQjQnLCdzY2VkaWwnOidcXHUwMTVGJywnU2NlZGlsJzonXFx1MDE1RScsJ3NjaXJjJzonXFx1MDE1RCcsJ1NjaXJjJzonXFx1MDE1QycsJ3NjbmFwJzonXFx1MkFCQScsJ3NjbkUnOidcXHUyQUI2Jywnc2Nuc2ltJzonXFx1MjJFOScsJ3NjcG9saW50JzonXFx1MkExMycsJ3Njc2ltJzonXFx1MjI3RicsJ3NjeSc6J1xcdTA0NDEnLCdTY3knOidcXHUwNDIxJywnc2RvdCc6J1xcdTIyQzUnLCdzZG90Yic6J1xcdTIyQTEnLCdzZG90ZSc6J1xcdTJBNjYnLCdzZWFyaGsnOidcXHUyOTI1Jywnc2VhcnInOidcXHUyMTk4Jywnc2VBcnInOidcXHUyMUQ4Jywnc2VhcnJvdyc6J1xcdTIxOTgnLCdzZWN0JzonXFx4QTcnLCdzZW1pJzonOycsJ3Nlc3dhcic6J1xcdTI5MjknLCdzZXRtaW51cyc6J1xcdTIyMTYnLCdzZXRtbic6J1xcdTIyMTYnLCdzZXh0JzonXFx1MjczNicsJ3Nmcic6J1xcdUQ4MzVcXHVERDMwJywnU2ZyJzonXFx1RDgzNVxcdUREMTYnLCdzZnJvd24nOidcXHUyMzIyJywnc2hhcnAnOidcXHUyNjZGJywnc2hjaGN5JzonXFx1MDQ0OScsJ1NIQ0hjeSc6J1xcdTA0MjknLCdzaGN5JzonXFx1MDQ0OCcsJ1NIY3knOidcXHUwNDI4JywnU2hvcnREb3duQXJyb3cnOidcXHUyMTkzJywnU2hvcnRMZWZ0QXJyb3cnOidcXHUyMTkwJywnc2hvcnRtaWQnOidcXHUyMjIzJywnc2hvcnRwYXJhbGxlbCc6J1xcdTIyMjUnLCdTaG9ydFJpZ2h0QXJyb3cnOidcXHUyMTkyJywnU2hvcnRVcEFycm93JzonXFx1MjE5MScsJ3NoeSc6J1xceEFEJywnc2lnbWEnOidcXHUwM0MzJywnU2lnbWEnOidcXHUwM0EzJywnc2lnbWFmJzonXFx1MDNDMicsJ3NpZ21hdic6J1xcdTAzQzInLCdzaW0nOidcXHUyMjNDJywnc2ltZG90JzonXFx1MkE2QScsJ3NpbWUnOidcXHUyMjQzJywnc2ltZXEnOidcXHUyMjQzJywnc2ltZyc6J1xcdTJBOUUnLCdzaW1nRSc6J1xcdTJBQTAnLCdzaW1sJzonXFx1MkE5RCcsJ3NpbWxFJzonXFx1MkE5RicsJ3NpbW5lJzonXFx1MjI0NicsJ3NpbXBsdXMnOidcXHUyQTI0Jywnc2ltcmFycic6J1xcdTI5NzInLCdzbGFycic6J1xcdTIxOTAnLCdTbWFsbENpcmNsZSc6J1xcdTIyMTgnLCdzbWFsbHNldG1pbnVzJzonXFx1MjIxNicsJ3NtYXNocCc6J1xcdTJBMzMnLCdzbWVwYXJzbCc6J1xcdTI5RTQnLCdzbWlkJzonXFx1MjIyMycsJ3NtaWxlJzonXFx1MjMyMycsJ3NtdCc6J1xcdTJBQUEnLCdzbXRlJzonXFx1MkFBQycsJ3NtdGVzJzonXFx1MkFBQ1xcdUZFMDAnLCdzb2Z0Y3knOidcXHUwNDRDJywnU09GVGN5JzonXFx1MDQyQycsJ3NvbCc6Jy8nLCdzb2xiJzonXFx1MjlDNCcsJ3NvbGJhcic6J1xcdTIzM0YnLCdzb3BmJzonXFx1RDgzNVxcdURENjQnLCdTb3BmJzonXFx1RDgzNVxcdURENEEnLCdzcGFkZXMnOidcXHUyNjYwJywnc3BhZGVzdWl0JzonXFx1MjY2MCcsJ3NwYXInOidcXHUyMjI1Jywnc3FjYXAnOidcXHUyMjkzJywnc3FjYXBzJzonXFx1MjI5M1xcdUZFMDAnLCdzcWN1cCc6J1xcdTIyOTQnLCdzcWN1cHMnOidcXHUyMjk0XFx1RkUwMCcsJ1NxcnQnOidcXHUyMjFBJywnc3FzdWInOidcXHUyMjhGJywnc3FzdWJlJzonXFx1MjI5MScsJ3Nxc3Vic2V0JzonXFx1MjI4RicsJ3Nxc3Vic2V0ZXEnOidcXHUyMjkxJywnc3FzdXAnOidcXHUyMjkwJywnc3FzdXBlJzonXFx1MjI5MicsJ3Nxc3Vwc2V0JzonXFx1MjI5MCcsJ3Nxc3Vwc2V0ZXEnOidcXHUyMjkyJywnc3F1JzonXFx1MjVBMScsJ3NxdWFyZSc6J1xcdTI1QTEnLCdTcXVhcmUnOidcXHUyNUExJywnU3F1YXJlSW50ZXJzZWN0aW9uJzonXFx1MjI5MycsJ1NxdWFyZVN1YnNldCc6J1xcdTIyOEYnLCdTcXVhcmVTdWJzZXRFcXVhbCc6J1xcdTIyOTEnLCdTcXVhcmVTdXBlcnNldCc6J1xcdTIyOTAnLCdTcXVhcmVTdXBlcnNldEVxdWFsJzonXFx1MjI5MicsJ1NxdWFyZVVuaW9uJzonXFx1MjI5NCcsJ3NxdWFyZic6J1xcdTI1QUEnLCdzcXVmJzonXFx1MjVBQScsJ3NyYXJyJzonXFx1MjE5MicsJ3NzY3InOidcXHVEODM1XFx1RENDOCcsJ1NzY3InOidcXHVEODM1XFx1RENBRScsJ3NzZXRtbic6J1xcdTIyMTYnLCdzc21pbGUnOidcXHUyMzIzJywnc3N0YXJmJzonXFx1MjJDNicsJ3N0YXInOidcXHUyNjA2JywnU3Rhcic6J1xcdTIyQzYnLCdzdGFyZic6J1xcdTI2MDUnLCdzdHJhaWdodGVwc2lsb24nOidcXHUwM0Y1Jywnc3RyYWlnaHRwaGknOidcXHUwM0Q1Jywnc3RybnMnOidcXHhBRicsJ3N1Yic6J1xcdTIyODInLCdTdWInOidcXHUyMkQwJywnc3ViZG90JzonXFx1MkFCRCcsJ3N1YmUnOidcXHUyMjg2Jywnc3ViRSc6J1xcdTJBQzUnLCdzdWJlZG90JzonXFx1MkFDMycsJ3N1Ym11bHQnOidcXHUyQUMxJywnc3VibmUnOidcXHUyMjhBJywnc3VibkUnOidcXHUyQUNCJywnc3VicGx1cyc6J1xcdTJBQkYnLCdzdWJyYXJyJzonXFx1Mjk3OScsJ3N1YnNldCc6J1xcdTIyODInLCdTdWJzZXQnOidcXHUyMkQwJywnc3Vic2V0ZXEnOidcXHUyMjg2Jywnc3Vic2V0ZXFxJzonXFx1MkFDNScsJ1N1YnNldEVxdWFsJzonXFx1MjI4NicsJ3N1YnNldG5lcSc6J1xcdTIyOEEnLCdzdWJzZXRuZXFxJzonXFx1MkFDQicsJ3N1YnNpbSc6J1xcdTJBQzcnLCdzdWJzdWInOidcXHUyQUQ1Jywnc3Vic3VwJzonXFx1MkFEMycsJ3N1Y2MnOidcXHUyMjdCJywnc3VjY2FwcHJveCc6J1xcdTJBQjgnLCdzdWNjY3VybHllcSc6J1xcdTIyN0QnLCdTdWNjZWVkcyc6J1xcdTIyN0InLCdTdWNjZWVkc0VxdWFsJzonXFx1MkFCMCcsJ1N1Y2NlZWRzU2xhbnRFcXVhbCc6J1xcdTIyN0QnLCdTdWNjZWVkc1RpbGRlJzonXFx1MjI3RicsJ3N1Y2NlcSc6J1xcdTJBQjAnLCdzdWNjbmFwcHJveCc6J1xcdTJBQkEnLCdzdWNjbmVxcSc6J1xcdTJBQjYnLCdzdWNjbnNpbSc6J1xcdTIyRTknLCdzdWNjc2ltJzonXFx1MjI3RicsJ1N1Y2hUaGF0JzonXFx1MjIwQicsJ3N1bSc6J1xcdTIyMTEnLCdTdW0nOidcXHUyMjExJywnc3VuZyc6J1xcdTI2NkEnLCdzdXAnOidcXHUyMjgzJywnU3VwJzonXFx1MjJEMScsJ3N1cDEnOidcXHhCOScsJ3N1cDInOidcXHhCMicsJ3N1cDMnOidcXHhCMycsJ3N1cGRvdCc6J1xcdTJBQkUnLCdzdXBkc3ViJzonXFx1MkFEOCcsJ3N1cGUnOidcXHUyMjg3Jywnc3VwRSc6J1xcdTJBQzYnLCdzdXBlZG90JzonXFx1MkFDNCcsJ1N1cGVyc2V0JzonXFx1MjI4MycsJ1N1cGVyc2V0RXF1YWwnOidcXHUyMjg3Jywnc3VwaHNvbCc6J1xcdTI3QzknLCdzdXBoc3ViJzonXFx1MkFENycsJ3N1cGxhcnInOidcXHUyOTdCJywnc3VwbXVsdCc6J1xcdTJBQzInLCdzdXBuZSc6J1xcdTIyOEInLCdzdXBuRSc6J1xcdTJBQ0MnLCdzdXBwbHVzJzonXFx1MkFDMCcsJ3N1cHNldCc6J1xcdTIyODMnLCdTdXBzZXQnOidcXHUyMkQxJywnc3Vwc2V0ZXEnOidcXHUyMjg3Jywnc3Vwc2V0ZXFxJzonXFx1MkFDNicsJ3N1cHNldG5lcSc6J1xcdTIyOEInLCdzdXBzZXRuZXFxJzonXFx1MkFDQycsJ3N1cHNpbSc6J1xcdTJBQzgnLCdzdXBzdWInOidcXHUyQUQ0Jywnc3Vwc3VwJzonXFx1MkFENicsJ3N3YXJoayc6J1xcdTI5MjYnLCdzd2Fycic6J1xcdTIxOTknLCdzd0Fycic6J1xcdTIxRDknLCdzd2Fycm93JzonXFx1MjE5OScsJ3N3bndhcic6J1xcdTI5MkEnLCdzemxpZyc6J1xceERGJywnVGFiJzonXFx0JywndGFyZ2V0JzonXFx1MjMxNicsJ3RhdSc6J1xcdTAzQzQnLCdUYXUnOidcXHUwM0E0JywndGJyayc6J1xcdTIzQjQnLCd0Y2Fyb24nOidcXHUwMTY1JywnVGNhcm9uJzonXFx1MDE2NCcsJ3RjZWRpbCc6J1xcdTAxNjMnLCdUY2VkaWwnOidcXHUwMTYyJywndGN5JzonXFx1MDQ0MicsJ1RjeSc6J1xcdTA0MjInLCd0ZG90JzonXFx1MjBEQicsJ3RlbHJlYyc6J1xcdTIzMTUnLCd0ZnInOidcXHVEODM1XFx1REQzMScsJ1Rmcic6J1xcdUQ4MzVcXHVERDE3JywndGhlcmU0JzonXFx1MjIzNCcsJ3RoZXJlZm9yZSc6J1xcdTIyMzQnLCdUaGVyZWZvcmUnOidcXHUyMjM0JywndGhldGEnOidcXHUwM0I4JywnVGhldGEnOidcXHUwMzk4JywndGhldGFzeW0nOidcXHUwM0QxJywndGhldGF2JzonXFx1MDNEMScsJ3RoaWNrYXBwcm94JzonXFx1MjI0OCcsJ3RoaWNrc2ltJzonXFx1MjIzQycsJ1RoaWNrU3BhY2UnOidcXHUyMDVGXFx1MjAwQScsJ3RoaW5zcCc6J1xcdTIwMDknLCdUaGluU3BhY2UnOidcXHUyMDA5JywndGhrYXAnOidcXHUyMjQ4JywndGhrc2ltJzonXFx1MjIzQycsJ3Rob3JuJzonXFx4RkUnLCdUSE9STic6J1xceERFJywndGlsZGUnOidcXHUwMkRDJywnVGlsZGUnOidcXHUyMjNDJywnVGlsZGVFcXVhbCc6J1xcdTIyNDMnLCdUaWxkZUZ1bGxFcXVhbCc6J1xcdTIyNDUnLCdUaWxkZVRpbGRlJzonXFx1MjI0OCcsJ3RpbWVzJzonXFx4RDcnLCd0aW1lc2InOidcXHUyMkEwJywndGltZXNiYXInOidcXHUyQTMxJywndGltZXNkJzonXFx1MkEzMCcsJ3RpbnQnOidcXHUyMjJEJywndG9lYSc6J1xcdTI5MjgnLCd0b3AnOidcXHUyMkE0JywndG9wYm90JzonXFx1MjMzNicsJ3RvcGNpcic6J1xcdTJBRjEnLCd0b3BmJzonXFx1RDgzNVxcdURENjUnLCdUb3BmJzonXFx1RDgzNVxcdURENEInLCd0b3Bmb3JrJzonXFx1MkFEQScsJ3Rvc2EnOidcXHUyOTI5JywndHByaW1lJzonXFx1MjAzNCcsJ3RyYWRlJzonXFx1MjEyMicsJ1RSQURFJzonXFx1MjEyMicsJ3RyaWFuZ2xlJzonXFx1MjVCNScsJ3RyaWFuZ2xlZG93bic6J1xcdTI1QkYnLCd0cmlhbmdsZWxlZnQnOidcXHUyNUMzJywndHJpYW5nbGVsZWZ0ZXEnOidcXHUyMkI0JywndHJpYW5nbGVxJzonXFx1MjI1QycsJ3RyaWFuZ2xlcmlnaHQnOidcXHUyNUI5JywndHJpYW5nbGVyaWdodGVxJzonXFx1MjJCNScsJ3RyaWRvdCc6J1xcdTI1RUMnLCd0cmllJzonXFx1MjI1QycsJ3RyaW1pbnVzJzonXFx1MkEzQScsJ1RyaXBsZURvdCc6J1xcdTIwREInLCd0cmlwbHVzJzonXFx1MkEzOScsJ3RyaXNiJzonXFx1MjlDRCcsJ3RyaXRpbWUnOidcXHUyQTNCJywndHJwZXppdW0nOidcXHUyM0UyJywndHNjcic6J1xcdUQ4MzVcXHVEQ0M5JywnVHNjcic6J1xcdUQ4MzVcXHVEQ0FGJywndHNjeSc6J1xcdTA0NDYnLCdUU2N5JzonXFx1MDQyNicsJ3RzaGN5JzonXFx1MDQ1QicsJ1RTSGN5JzonXFx1MDQwQicsJ3RzdHJvayc6J1xcdTAxNjcnLCdUc3Ryb2snOidcXHUwMTY2JywndHdpeHQnOidcXHUyMjZDJywndHdvaGVhZGxlZnRhcnJvdyc6J1xcdTIxOUUnLCd0d29oZWFkcmlnaHRhcnJvdyc6J1xcdTIxQTAnLCd1YWN1dGUnOidcXHhGQScsJ1VhY3V0ZSc6J1xceERBJywndWFycic6J1xcdTIxOTEnLCd1QXJyJzonXFx1MjFEMScsJ1VhcnInOidcXHUyMTlGJywnVWFycm9jaXInOidcXHUyOTQ5JywndWJyY3knOidcXHUwNDVFJywnVWJyY3knOidcXHUwNDBFJywndWJyZXZlJzonXFx1MDE2RCcsJ1VicmV2ZSc6J1xcdTAxNkMnLCd1Y2lyYyc6J1xceEZCJywnVWNpcmMnOidcXHhEQicsJ3VjeSc6J1xcdTA0NDMnLCdVY3knOidcXHUwNDIzJywndWRhcnInOidcXHUyMUM1JywndWRibGFjJzonXFx1MDE3MScsJ1VkYmxhYyc6J1xcdTAxNzAnLCd1ZGhhcic6J1xcdTI5NkUnLCd1ZmlzaHQnOidcXHUyOTdFJywndWZyJzonXFx1RDgzNVxcdUREMzInLCdVZnInOidcXHVEODM1XFx1REQxOCcsJ3VncmF2ZSc6J1xceEY5JywnVWdyYXZlJzonXFx4RDknLCd1SGFyJzonXFx1Mjk2MycsJ3VoYXJsJzonXFx1MjFCRicsJ3VoYXJyJzonXFx1MjFCRScsJ3VoYmxrJzonXFx1MjU4MCcsJ3VsY29ybic6J1xcdTIzMUMnLCd1bGNvcm5lcic6J1xcdTIzMUMnLCd1bGNyb3AnOidcXHUyMzBGJywndWx0cmknOidcXHUyNUY4JywndW1hY3InOidcXHUwMTZCJywnVW1hY3InOidcXHUwMTZBJywndW1sJzonXFx4QTgnLCdVbmRlckJhcic6J18nLCdVbmRlckJyYWNlJzonXFx1MjNERicsJ1VuZGVyQnJhY2tldCc6J1xcdTIzQjUnLCdVbmRlclBhcmVudGhlc2lzJzonXFx1MjNERCcsJ1VuaW9uJzonXFx1MjJDMycsJ1VuaW9uUGx1cyc6J1xcdTIyOEUnLCd1b2dvbic6J1xcdTAxNzMnLCdVb2dvbic6J1xcdTAxNzInLCd1b3BmJzonXFx1RDgzNVxcdURENjYnLCdVb3BmJzonXFx1RDgzNVxcdURENEMnLCd1cGFycm93JzonXFx1MjE5MScsJ1VwYXJyb3cnOidcXHUyMUQxJywnVXBBcnJvdyc6J1xcdTIxOTEnLCdVcEFycm93QmFyJzonXFx1MjkxMicsJ1VwQXJyb3dEb3duQXJyb3cnOidcXHUyMUM1JywndXBkb3duYXJyb3cnOidcXHUyMTk1JywnVXBkb3duYXJyb3cnOidcXHUyMUQ1JywnVXBEb3duQXJyb3cnOidcXHUyMTk1JywnVXBFcXVpbGlicml1bSc6J1xcdTI5NkUnLCd1cGhhcnBvb25sZWZ0JzonXFx1MjFCRicsJ3VwaGFycG9vbnJpZ2h0JzonXFx1MjFCRScsJ3VwbHVzJzonXFx1MjI4RScsJ1VwcGVyTGVmdEFycm93JzonXFx1MjE5NicsJ1VwcGVyUmlnaHRBcnJvdyc6J1xcdTIxOTcnLCd1cHNpJzonXFx1MDNDNScsJ1Vwc2knOidcXHUwM0QyJywndXBzaWgnOidcXHUwM0QyJywndXBzaWxvbic6J1xcdTAzQzUnLCdVcHNpbG9uJzonXFx1MDNBNScsJ1VwVGVlJzonXFx1MjJBNScsJ1VwVGVlQXJyb3cnOidcXHUyMUE1JywndXB1cGFycm93cyc6J1xcdTIxQzgnLCd1cmNvcm4nOidcXHUyMzFEJywndXJjb3JuZXInOidcXHUyMzFEJywndXJjcm9wJzonXFx1MjMwRScsJ3VyaW5nJzonXFx1MDE2RicsJ1VyaW5nJzonXFx1MDE2RScsJ3VydHJpJzonXFx1MjVGOScsJ3VzY3InOidcXHVEODM1XFx1RENDQScsJ1VzY3InOidcXHVEODM1XFx1RENCMCcsJ3V0ZG90JzonXFx1MjJGMCcsJ3V0aWxkZSc6J1xcdTAxNjknLCdVdGlsZGUnOidcXHUwMTY4JywndXRyaSc6J1xcdTI1QjUnLCd1dHJpZic6J1xcdTI1QjQnLCd1dWFycic6J1xcdTIxQzgnLCd1dW1sJzonXFx4RkMnLCdVdW1sJzonXFx4REMnLCd1d2FuZ2xlJzonXFx1MjlBNycsJ3ZhbmdydCc6J1xcdTI5OUMnLCd2YXJlcHNpbG9uJzonXFx1MDNGNScsJ3ZhcmthcHBhJzonXFx1MDNGMCcsJ3Zhcm5vdGhpbmcnOidcXHUyMjA1JywndmFycGhpJzonXFx1MDNENScsJ3ZhcnBpJzonXFx1MDNENicsJ3ZhcnByb3B0byc6J1xcdTIyMUQnLCd2YXJyJzonXFx1MjE5NScsJ3ZBcnInOidcXHUyMUQ1JywndmFycmhvJzonXFx1MDNGMScsJ3ZhcnNpZ21hJzonXFx1MDNDMicsJ3ZhcnN1YnNldG5lcSc6J1xcdTIyOEFcXHVGRTAwJywndmFyc3Vic2V0bmVxcSc6J1xcdTJBQ0JcXHVGRTAwJywndmFyc3Vwc2V0bmVxJzonXFx1MjI4QlxcdUZFMDAnLCd2YXJzdXBzZXRuZXFxJzonXFx1MkFDQ1xcdUZFMDAnLCd2YXJ0aGV0YSc6J1xcdTAzRDEnLCd2YXJ0cmlhbmdsZWxlZnQnOidcXHUyMkIyJywndmFydHJpYW5nbGVyaWdodCc6J1xcdTIyQjMnLCd2QmFyJzonXFx1MkFFOCcsJ1ZiYXInOidcXHUyQUVCJywndkJhcnYnOidcXHUyQUU5JywndmN5JzonXFx1MDQzMicsJ1ZjeSc6J1xcdTA0MTInLCd2ZGFzaCc6J1xcdTIyQTInLCd2RGFzaCc6J1xcdTIyQTgnLCdWZGFzaCc6J1xcdTIyQTknLCdWRGFzaCc6J1xcdTIyQUInLCdWZGFzaGwnOidcXHUyQUU2JywndmVlJzonXFx1MjIyOCcsJ1ZlZSc6J1xcdTIyQzEnLCd2ZWViYXInOidcXHUyMkJCJywndmVlZXEnOidcXHUyMjVBJywndmVsbGlwJzonXFx1MjJFRScsJ3ZlcmJhcic6J3wnLCdWZXJiYXInOidcXHUyMDE2JywndmVydCc6J3wnLCdWZXJ0JzonXFx1MjAxNicsJ1ZlcnRpY2FsQmFyJzonXFx1MjIyMycsJ1ZlcnRpY2FsTGluZSc6J3wnLCdWZXJ0aWNhbFNlcGFyYXRvcic6J1xcdTI3NTgnLCdWZXJ0aWNhbFRpbGRlJzonXFx1MjI0MCcsJ1ZlcnlUaGluU3BhY2UnOidcXHUyMDBBJywndmZyJzonXFx1RDgzNVxcdUREMzMnLCdWZnInOidcXHVEODM1XFx1REQxOScsJ3ZsdHJpJzonXFx1MjJCMicsJ3Zuc3ViJzonXFx1MjI4MlxcdTIwRDInLCd2bnN1cCc6J1xcdTIyODNcXHUyMEQyJywndm9wZic6J1xcdUQ4MzVcXHVERDY3JywnVm9wZic6J1xcdUQ4MzVcXHVERDREJywndnByb3AnOidcXHUyMjFEJywndnJ0cmknOidcXHUyMkIzJywndnNjcic6J1xcdUQ4MzVcXHVEQ0NCJywnVnNjcic6J1xcdUQ4MzVcXHVEQ0IxJywndnN1Ym5lJzonXFx1MjI4QVxcdUZFMDAnLCd2c3VibkUnOidcXHUyQUNCXFx1RkUwMCcsJ3ZzdXBuZSc6J1xcdTIyOEJcXHVGRTAwJywndnN1cG5FJzonXFx1MkFDQ1xcdUZFMDAnLCdWdmRhc2gnOidcXHUyMkFBJywndnppZ3phZyc6J1xcdTI5OUEnLCd3Y2lyYyc6J1xcdTAxNzUnLCdXY2lyYyc6J1xcdTAxNzQnLCd3ZWRiYXInOidcXHUyQTVGJywnd2VkZ2UnOidcXHUyMjI3JywnV2VkZ2UnOidcXHUyMkMwJywnd2VkZ2VxJzonXFx1MjI1OScsJ3dlaWVycCc6J1xcdTIxMTgnLCd3ZnInOidcXHVEODM1XFx1REQzNCcsJ1dmcic6J1xcdUQ4MzVcXHVERDFBJywnd29wZic6J1xcdUQ4MzVcXHVERDY4JywnV29wZic6J1xcdUQ4MzVcXHVERDRFJywnd3AnOidcXHUyMTE4Jywnd3InOidcXHUyMjQwJywnd3JlYXRoJzonXFx1MjI0MCcsJ3dzY3InOidcXHVEODM1XFx1RENDQycsJ1dzY3InOidcXHVEODM1XFx1RENCMicsJ3hjYXAnOidcXHUyMkMyJywneGNpcmMnOidcXHUyNUVGJywneGN1cCc6J1xcdTIyQzMnLCd4ZHRyaSc6J1xcdTI1QkQnLCd4ZnInOidcXHVEODM1XFx1REQzNScsJ1hmcic6J1xcdUQ4MzVcXHVERDFCJywneGhhcnInOidcXHUyN0Y3JywneGhBcnInOidcXHUyN0ZBJywneGknOidcXHUwM0JFJywnWGknOidcXHUwMzlFJywneGxhcnInOidcXHUyN0Y1JywneGxBcnInOidcXHUyN0Y4JywneG1hcCc6J1xcdTI3RkMnLCd4bmlzJzonXFx1MjJGQicsJ3hvZG90JzonXFx1MkEwMCcsJ3hvcGYnOidcXHVEODM1XFx1REQ2OScsJ1hvcGYnOidcXHVEODM1XFx1REQ0RicsJ3hvcGx1cyc6J1xcdTJBMDEnLCd4b3RpbWUnOidcXHUyQTAyJywneHJhcnInOidcXHUyN0Y2JywneHJBcnInOidcXHUyN0Y5JywneHNjcic6J1xcdUQ4MzVcXHVEQ0NEJywnWHNjcic6J1xcdUQ4MzVcXHVEQ0IzJywneHNxY3VwJzonXFx1MkEwNicsJ3h1cGx1cyc6J1xcdTJBMDQnLCd4dXRyaSc6J1xcdTI1QjMnLCd4dmVlJzonXFx1MjJDMScsJ3h3ZWRnZSc6J1xcdTIyQzAnLCd5YWN1dGUnOidcXHhGRCcsJ1lhY3V0ZSc6J1xceEREJywneWFjeSc6J1xcdTA0NEYnLCdZQWN5JzonXFx1MDQyRicsJ3ljaXJjJzonXFx1MDE3NycsJ1ljaXJjJzonXFx1MDE3NicsJ3ljeSc6J1xcdTA0NEInLCdZY3knOidcXHUwNDJCJywneWVuJzonXFx4QTUnLCd5ZnInOidcXHVEODM1XFx1REQzNicsJ1lmcic6J1xcdUQ4MzVcXHVERDFDJywneWljeSc6J1xcdTA0NTcnLCdZSWN5JzonXFx1MDQwNycsJ3lvcGYnOidcXHVEODM1XFx1REQ2QScsJ1lvcGYnOidcXHVEODM1XFx1REQ1MCcsJ3lzY3InOidcXHVEODM1XFx1RENDRScsJ1lzY3InOidcXHVEODM1XFx1RENCNCcsJ3l1Y3knOidcXHUwNDRFJywnWVVjeSc6J1xcdTA0MkUnLCd5dW1sJzonXFx4RkYnLCdZdW1sJzonXFx1MDE3OCcsJ3phY3V0ZSc6J1xcdTAxN0EnLCdaYWN1dGUnOidcXHUwMTc5JywnemNhcm9uJzonXFx1MDE3RScsJ1pjYXJvbic6J1xcdTAxN0QnLCd6Y3knOidcXHUwNDM3JywnWmN5JzonXFx1MDQxNycsJ3pkb3QnOidcXHUwMTdDJywnWmRvdCc6J1xcdTAxN0InLCd6ZWV0cmYnOidcXHUyMTI4JywnWmVyb1dpZHRoU3BhY2UnOidcXHUyMDBCJywnemV0YSc6J1xcdTAzQjYnLCdaZXRhJzonXFx1MDM5NicsJ3pmcic6J1xcdUQ4MzVcXHVERDM3JywnWmZyJzonXFx1MjEyOCcsJ3poY3knOidcXHUwNDM2JywnWkhjeSc6J1xcdTA0MTYnLCd6aWdyYXJyJzonXFx1MjFERCcsJ3pvcGYnOidcXHVEODM1XFx1REQ2QicsJ1pvcGYnOidcXHUyMTI0JywnenNjcic6J1xcdUQ4MzVcXHVEQ0NGJywnWnNjcic6J1xcdUQ4MzVcXHVEQ0I1JywnendqJzonXFx1MjAwRCcsJ3p3bmonOidcXHUyMDBDJ307XG5cdHZhciBkZWNvZGVNYXBMZWdhY3kgPSB7J2FhY3V0ZSc6J1xceEUxJywnQWFjdXRlJzonXFx4QzEnLCdhY2lyYyc6J1xceEUyJywnQWNpcmMnOidcXHhDMicsJ2FjdXRlJzonXFx4QjQnLCdhZWxpZyc6J1xceEU2JywnQUVsaWcnOidcXHhDNicsJ2FncmF2ZSc6J1xceEUwJywnQWdyYXZlJzonXFx4QzAnLCdhbXAnOicmJywnQU1QJzonJicsJ2FyaW5nJzonXFx4RTUnLCdBcmluZyc6J1xceEM1JywnYXRpbGRlJzonXFx4RTMnLCdBdGlsZGUnOidcXHhDMycsJ2F1bWwnOidcXHhFNCcsJ0F1bWwnOidcXHhDNCcsJ2JydmJhcic6J1xceEE2JywnY2NlZGlsJzonXFx4RTcnLCdDY2VkaWwnOidcXHhDNycsJ2NlZGlsJzonXFx4QjgnLCdjZW50JzonXFx4QTInLCdjb3B5JzonXFx4QTknLCdDT1BZJzonXFx4QTknLCdjdXJyZW4nOidcXHhBNCcsJ2RlZyc6J1xceEIwJywnZGl2aWRlJzonXFx4RjcnLCdlYWN1dGUnOidcXHhFOScsJ0VhY3V0ZSc6J1xceEM5JywnZWNpcmMnOidcXHhFQScsJ0VjaXJjJzonXFx4Q0EnLCdlZ3JhdmUnOidcXHhFOCcsJ0VncmF2ZSc6J1xceEM4JywnZXRoJzonXFx4RjAnLCdFVEgnOidcXHhEMCcsJ2V1bWwnOidcXHhFQicsJ0V1bWwnOidcXHhDQicsJ2ZyYWMxMic6J1xceEJEJywnZnJhYzE0JzonXFx4QkMnLCdmcmFjMzQnOidcXHhCRScsJ2d0JzonPicsJ0dUJzonPicsJ2lhY3V0ZSc6J1xceEVEJywnSWFjdXRlJzonXFx4Q0QnLCdpY2lyYyc6J1xceEVFJywnSWNpcmMnOidcXHhDRScsJ2lleGNsJzonXFx4QTEnLCdpZ3JhdmUnOidcXHhFQycsJ0lncmF2ZSc6J1xceENDJywnaXF1ZXN0JzonXFx4QkYnLCdpdW1sJzonXFx4RUYnLCdJdW1sJzonXFx4Q0YnLCdsYXF1byc6J1xceEFCJywnbHQnOic8JywnTFQnOic8JywnbWFjcic6J1xceEFGJywnbWljcm8nOidcXHhCNScsJ21pZGRvdCc6J1xceEI3JywnbmJzcCc6J1xceEEwJywnbm90JzonXFx4QUMnLCdudGlsZGUnOidcXHhGMScsJ050aWxkZSc6J1xceEQxJywnb2FjdXRlJzonXFx4RjMnLCdPYWN1dGUnOidcXHhEMycsJ29jaXJjJzonXFx4RjQnLCdPY2lyYyc6J1xceEQ0Jywnb2dyYXZlJzonXFx4RjInLCdPZ3JhdmUnOidcXHhEMicsJ29yZGYnOidcXHhBQScsJ29yZG0nOidcXHhCQScsJ29zbGFzaCc6J1xceEY4JywnT3NsYXNoJzonXFx4RDgnLCdvdGlsZGUnOidcXHhGNScsJ090aWxkZSc6J1xceEQ1Jywnb3VtbCc6J1xceEY2JywnT3VtbCc6J1xceEQ2JywncGFyYSc6J1xceEI2JywncGx1c21uJzonXFx4QjEnLCdwb3VuZCc6J1xceEEzJywncXVvdCc6J1wiJywnUVVPVCc6J1wiJywncmFxdW8nOidcXHhCQicsJ3JlZyc6J1xceEFFJywnUkVHJzonXFx4QUUnLCdzZWN0JzonXFx4QTcnLCdzaHknOidcXHhBRCcsJ3N1cDEnOidcXHhCOScsJ3N1cDInOidcXHhCMicsJ3N1cDMnOidcXHhCMycsJ3N6bGlnJzonXFx4REYnLCd0aG9ybic6J1xceEZFJywnVEhPUk4nOidcXHhERScsJ3RpbWVzJzonXFx4RDcnLCd1YWN1dGUnOidcXHhGQScsJ1VhY3V0ZSc6J1xceERBJywndWNpcmMnOidcXHhGQicsJ1VjaXJjJzonXFx4REInLCd1Z3JhdmUnOidcXHhGOScsJ1VncmF2ZSc6J1xceEQ5JywndW1sJzonXFx4QTgnLCd1dW1sJzonXFx4RkMnLCdVdW1sJzonXFx4REMnLCd5YWN1dGUnOidcXHhGRCcsJ1lhY3V0ZSc6J1xceEREJywneWVuJzonXFx4QTUnLCd5dW1sJzonXFx4RkYnfTtcblx0dmFyIGRlY29kZU1hcE51bWVyaWMgPSB7JzAnOidcXHVGRkZEJywnMTI4JzonXFx1MjBBQycsJzEzMCc6J1xcdTIwMUEnLCcxMzEnOidcXHUwMTkyJywnMTMyJzonXFx1MjAxRScsJzEzMyc6J1xcdTIwMjYnLCcxMzQnOidcXHUyMDIwJywnMTM1JzonXFx1MjAyMScsJzEzNic6J1xcdTAyQzYnLCcxMzcnOidcXHUyMDMwJywnMTM4JzonXFx1MDE2MCcsJzEzOSc6J1xcdTIwMzknLCcxNDAnOidcXHUwMTUyJywnMTQyJzonXFx1MDE3RCcsJzE0NSc6J1xcdTIwMTgnLCcxNDYnOidcXHUyMDE5JywnMTQ3JzonXFx1MjAxQycsJzE0OCc6J1xcdTIwMUQnLCcxNDknOidcXHUyMDIyJywnMTUwJzonXFx1MjAxMycsJzE1MSc6J1xcdTIwMTQnLCcxNTInOidcXHUwMkRDJywnMTUzJzonXFx1MjEyMicsJzE1NCc6J1xcdTAxNjEnLCcxNTUnOidcXHUyMDNBJywnMTU2JzonXFx1MDE1MycsJzE1OCc6J1xcdTAxN0UnLCcxNTknOidcXHUwMTc4J307XG5cdHZhciBpbnZhbGlkUmVmZXJlbmNlQ29kZVBvaW50cyA9IFsxLDIsMyw0LDUsNiw3LDgsMTEsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMTI3LDEyOCwxMjksMTMwLDEzMSwxMzIsMTMzLDEzNCwxMzUsMTM2LDEzNywxMzgsMTM5LDE0MCwxNDEsMTQyLDE0MywxNDQsMTQ1LDE0NiwxNDcsMTQ4LDE0OSwxNTAsMTUxLDE1MiwxNTMsMTU0LDE1NSwxNTYsMTU3LDE1OCwxNTksNjQ5NzYsNjQ5NzcsNjQ5NzgsNjQ5NzksNjQ5ODAsNjQ5ODEsNjQ5ODIsNjQ5ODMsNjQ5ODQsNjQ5ODUsNjQ5ODYsNjQ5ODcsNjQ5ODgsNjQ5ODksNjQ5OTAsNjQ5OTEsNjQ5OTIsNjQ5OTMsNjQ5OTQsNjQ5OTUsNjQ5OTYsNjQ5OTcsNjQ5OTgsNjQ5OTksNjUwMDAsNjUwMDEsNjUwMDIsNjUwMDMsNjUwMDQsNjUwMDUsNjUwMDYsNjUwMDcsNjU1MzQsNjU1MzUsMTMxMDcwLDEzMTA3MSwxOTY2MDYsMTk2NjA3LDI2MjE0MiwyNjIxNDMsMzI3Njc4LDMyNzY3OSwzOTMyMTQsMzkzMjE1LDQ1ODc1MCw0NTg3NTEsNTI0Mjg2LDUyNDI4Nyw1ODk4MjIsNTg5ODIzLDY1NTM1OCw2NTUzNTksNzIwODk0LDcyMDg5NSw3ODY0MzAsNzg2NDMxLDg1MTk2Niw4NTE5NjcsOTE3NTAyLDkxNzUwMyw5ODMwMzgsOTgzMDM5LDEwNDg1NzQsMTA0ODU3NSwxMTE0MTEwLDExMTQxMTFdO1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG5cdHZhciBvYmplY3QgPSB7fTtcblx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuXHR2YXIgaGFzID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eU5hbWUpIHtcblx0XHRyZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5TmFtZSk7XG5cdH07XG5cblx0dmFyIGNvbnRhaW5zID0gZnVuY3Rpb24oYXJyYXksIHZhbHVlKSB7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0aWYgKGFycmF5W2luZGV4XSA9PSB2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdHZhciBtZXJnZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG5cdFx0aWYgKCFvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gZGVmYXVsdHM7XG5cdFx0fVxuXHRcdHZhciByZXN1bHQgPSB7fTtcblx0XHR2YXIga2V5O1xuXHRcdGZvciAoa2V5IGluIGRlZmF1bHRzKSB7XG5cdFx0XHQvLyBBIGBoYXNPd25Qcm9wZXJ0eWAgY2hlY2sgaXMgbm90IG5lZWRlZCBoZXJlLCBzaW5jZSBvbmx5IHJlY29nbml6ZWRcblx0XHRcdC8vIG9wdGlvbiBuYW1lcyBhcmUgdXNlZCBhbnl3YXkuIEFueSBvdGhlcnMgYXJlIGlnbm9yZWQuXG5cdFx0XHRyZXN1bHRba2V5XSA9IGhhcyhvcHRpb25zLCBrZXkpID8gb3B0aW9uc1trZXldIDogZGVmYXVsdHNba2V5XTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvLyBNb2RpZmllZCB2ZXJzaW9uIG9mIGB1Y3MyZW5jb2RlYDsgc2VlIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZS5cblx0dmFyIGNvZGVQb2ludFRvU3ltYm9sID0gZnVuY3Rpb24oY29kZVBvaW50LCBzdHJpY3QpIHtcblx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0aWYgKChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHx8IGNvZGVQb2ludCA+IDB4MTBGRkZGKSB7XG5cdFx0XHQvLyBTZWUgaXNzdWUgIzQ6XG5cdFx0XHQvLyDigJxPdGhlcndpc2UsIGlmIHRoZSBudW1iZXIgaXMgaW4gdGhlIHJhbmdlIDB4RDgwMCB0byAweERGRkYgb3IgaXNcblx0XHRcdC8vIGdyZWF0ZXIgdGhhbiAweDEwRkZGRiwgdGhlbiB0aGlzIGlzIGEgcGFyc2UgZXJyb3IuIFJldHVybiBhIFUrRkZGRFxuXHRcdFx0Ly8gUkVQTEFDRU1FTlQgQ0hBUkFDVEVSLuKAnVxuXHRcdFx0aWYgKHN0cmljdCkge1xuXHRcdFx0XHRwYXJzZUVycm9yKCdjaGFyYWN0ZXIgcmVmZXJlbmNlIG91dHNpZGUgdGhlIHBlcm1pc3NpYmxlIFVuaWNvZGUgcmFuZ2UnKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAnXFx1RkZGRCc7XG5cdFx0fVxuXHRcdGlmIChoYXMoZGVjb2RlTWFwTnVtZXJpYywgY29kZVBvaW50KSkge1xuXHRcdFx0aWYgKHN0cmljdCkge1xuXHRcdFx0XHRwYXJzZUVycm9yKCdkaXNhbGxvd2VkIGNoYXJhY3RlciByZWZlcmVuY2UnKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkZWNvZGVNYXBOdW1lcmljW2NvZGVQb2ludF07XG5cdFx0fVxuXHRcdGlmIChzdHJpY3QgJiYgY29udGFpbnMoaW52YWxpZFJlZmVyZW5jZUNvZGVQb2ludHMsIGNvZGVQb2ludCkpIHtcblx0XHRcdHBhcnNlRXJyb3IoJ2Rpc2FsbG93ZWQgY2hhcmFjdGVyIHJlZmVyZW5jZScpO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG5cdFx0XHRjb2RlUG9pbnQgLT0gMHgxMDAwMDtcblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGO1xuXHRcdH1cblx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fTtcblxuXHR2YXIgaGV4RXNjYXBlID0gZnVuY3Rpb24oY29kZVBvaW50KSB7XG5cdFx0cmV0dXJuICcmI3gnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgJzsnO1xuXHR9O1xuXG5cdHZhciBkZWNFc2NhcGUgPSBmdW5jdGlvbihjb2RlUG9pbnQpIHtcblx0XHRyZXR1cm4gJyYjJyArIGNvZGVQb2ludCArICc7Jztcblx0fTtcblxuXHR2YXIgcGFyc2VFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHR0aHJvdyBFcnJvcignUGFyc2UgZXJyb3I6ICcgKyBtZXNzYWdlKTtcblx0fTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgZW5jb2RlID0gZnVuY3Rpb24oc3RyaW5nLCBvcHRpb25zKSB7XG5cdFx0b3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMsIGVuY29kZS5vcHRpb25zKTtcblx0XHR2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG5cdFx0aWYgKHN0cmljdCAmJiByZWdleEludmFsaWRSYXdDb2RlUG9pbnQudGVzdChzdHJpbmcpKSB7XG5cdFx0XHRwYXJzZUVycm9yKCdmb3JiaWRkZW4gY29kZSBwb2ludCcpO1xuXHRcdH1cblx0XHR2YXIgZW5jb2RlRXZlcnl0aGluZyA9IG9wdGlvbnMuZW5jb2RlRXZlcnl0aGluZztcblx0XHR2YXIgdXNlTmFtZWRSZWZlcmVuY2VzID0gb3B0aW9ucy51c2VOYW1lZFJlZmVyZW5jZXM7XG5cdFx0dmFyIGFsbG93VW5zYWZlU3ltYm9scyA9IG9wdGlvbnMuYWxsb3dVbnNhZmVTeW1ib2xzO1xuXHRcdHZhciBlc2NhcGVDb2RlUG9pbnQgPSBvcHRpb25zLmRlY2ltYWwgPyBkZWNFc2NhcGUgOiBoZXhFc2NhcGU7XG5cblx0XHR2YXIgZXNjYXBlQm1wU3ltYm9sID0gZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0XHRyZXR1cm4gZXNjYXBlQ29kZVBvaW50KHN5bWJvbC5jaGFyQ29kZUF0KDApKTtcblx0XHR9O1xuXG5cdFx0aWYgKGVuY29kZUV2ZXJ5dGhpbmcpIHtcblx0XHRcdC8vIEVuY29kZSBBU0NJSSBzeW1ib2xzLlxuXHRcdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhBc2NpaVdoaXRlbGlzdCwgZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0XHRcdC8vIFVzZSBuYW1lZCByZWZlcmVuY2VzIGlmIHJlcXVlc3RlZCAmIHBvc3NpYmxlLlxuXHRcdFx0XHRpZiAodXNlTmFtZWRSZWZlcmVuY2VzICYmIGhhcyhlbmNvZGVNYXAsIHN5bWJvbCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyYnICsgZW5jb2RlTWFwW3N5bWJvbF0gKyAnOyc7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGVzY2FwZUJtcFN5bWJvbChzeW1ib2wpO1xuXHRcdFx0fSk7XG5cdFx0XHQvLyBTaG9ydGVuIGEgZmV3IGVzY2FwZXMgdGhhdCByZXByZXNlbnQgdHdvIHN5bWJvbHMsIG9mIHdoaWNoIGF0IGxlYXN0IG9uZVxuXHRcdFx0Ly8gaXMgd2l0aGluIHRoZSBBU0NJSSByYW5nZS5cblx0XHRcdGlmICh1c2VOYW1lZFJlZmVyZW5jZXMpIHtcblx0XHRcdFx0c3RyaW5nID0gc3RyaW5nXG5cdFx0XHRcdFx0LnJlcGxhY2UoLyZndDtcXHUyMEQyL2csICcmbnZndDsnKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC8mbHQ7XFx1MjBEMi9nLCAnJm52bHQ7Jylcblx0XHRcdFx0XHQucmVwbGFjZSgvJiN4NjY7JiN4NkE7L2csICcmZmpsaWc7Jyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBFbmNvZGUgbm9uLUFTQ0lJIHN5bWJvbHMuXG5cdFx0XHRpZiAodXNlTmFtZWRSZWZlcmVuY2VzKSB7XG5cdFx0XHRcdC8vIEVuY29kZSBub24tQVNDSUkgc3ltYm9scyB0aGF0IGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgbmFtZWQgcmVmZXJlbmNlLlxuXHRcdFx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleEVuY29kZU5vbkFzY2lpLCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdFx0XHQvLyBOb3RlOiB0aGVyZSBpcyBubyBuZWVkIHRvIGNoZWNrIGBoYXMoZW5jb2RlTWFwLCBzdHJpbmcpYCBoZXJlLlxuXHRcdFx0XHRcdHJldHVybiAnJicgKyBlbmNvZGVNYXBbc3RyaW5nXSArICc7Jztcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBOb3RlOiBhbnkgcmVtYWluaW5nIG5vbi1BU0NJSSBzeW1ib2xzIGFyZSBoYW5kbGVkIG91dHNpZGUgb2YgdGhlIGBpZmAuXG5cdFx0fSBlbHNlIGlmICh1c2VOYW1lZFJlZmVyZW5jZXMpIHtcblx0XHRcdC8vIEFwcGx5IG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzLlxuXHRcdFx0Ly8gRW5jb2RlIGA8PlwiJyZgIHVzaW5nIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzLlxuXHRcdFx0aWYgKCFhbGxvd1Vuc2FmZVN5bWJvbHMpIHtcblx0XHRcdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhFc2NhcGUsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0XHRcdHJldHVybiAnJicgKyBlbmNvZGVNYXBbc3RyaW5nXSArICc7JzsgLy8gbm8gbmVlZCB0byBjaGVjayBgaGFzKClgIGhlcmVcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBTaG9ydGVuIGVzY2FwZXMgdGhhdCByZXByZXNlbnQgdHdvIHN5bWJvbHMsIG9mIHdoaWNoIGF0IGxlYXN0IG9uZSBpc1xuXHRcdFx0Ly8gYDw+XCInJmAuXG5cdFx0XHRzdHJpbmcgPSBzdHJpbmdcblx0XHRcdFx0LnJlcGxhY2UoLyZndDtcXHUyMEQyL2csICcmbnZndDsnKVxuXHRcdFx0XHQucmVwbGFjZSgvJmx0O1xcdTIwRDIvZywgJyZudmx0OycpO1xuXHRcdFx0Ly8gRW5jb2RlIG5vbi1BU0NJSSBzeW1ib2xzIHRoYXQgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBuYW1lZCByZWZlcmVuY2UuXG5cdFx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleEVuY29kZU5vbkFzY2lpLCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdFx0Ly8gTm90ZTogdGhlcmUgaXMgbm8gbmVlZCB0byBjaGVjayBgaGFzKGVuY29kZU1hcCwgc3RyaW5nKWAgaGVyZS5cblx0XHRcdFx0cmV0dXJuICcmJyArIGVuY29kZU1hcFtzdHJpbmddICsgJzsnO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmICghYWxsb3dVbnNhZmVTeW1ib2xzKSB7XG5cdFx0XHQvLyBFbmNvZGUgYDw+XCInJmAgdXNpbmcgaGV4YWRlY2ltYWwgZXNjYXBlcywgbm93IHRoYXQgdGhleeKAmXJlIG5vdCBoYW5kbGVkXG5cdFx0XHQvLyB1c2luZyBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcy5cblx0XHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4RXNjYXBlLCBlc2NhcGVCbXBTeW1ib2wpO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RyaW5nXG5cdFx0XHQvLyBFbmNvZGUgYXN0cmFsIHN5bWJvbHMuXG5cdFx0XHQucmVwbGFjZShyZWdleEFzdHJhbFN5bWJvbHMsIGZ1bmN0aW9uKCQwKSB7XG5cdFx0XHRcdC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuXHRcdFx0XHR2YXIgaGlnaCA9ICQwLmNoYXJDb2RlQXQoMCk7XG5cdFx0XHRcdHZhciBsb3cgPSAkMC5jaGFyQ29kZUF0KDEpO1xuXHRcdFx0XHR2YXIgY29kZVBvaW50ID0gKGhpZ2ggLSAweEQ4MDApICogMHg0MDAgKyBsb3cgLSAweERDMDAgKyAweDEwMDAwO1xuXHRcdFx0XHRyZXR1cm4gZXNjYXBlQ29kZVBvaW50KGNvZGVQb2ludCk7XG5cdFx0XHR9KVxuXHRcdFx0Ly8gRW5jb2RlIGFueSByZW1haW5pbmcgQk1QIHN5bWJvbHMgdGhhdCBhcmUgbm90IHByaW50YWJsZSBBU0NJSSBzeW1ib2xzXG5cdFx0XHQvLyB1c2luZyBhIGhleGFkZWNpbWFsIGVzY2FwZS5cblx0XHRcdC5yZXBsYWNlKHJlZ2V4Qm1wV2hpdGVsaXN0LCBlc2NhcGVCbXBTeW1ib2wpO1xuXHR9O1xuXHQvLyBFeHBvc2UgZGVmYXVsdCBvcHRpb25zIChzbyB0aGV5IGNhbiBiZSBvdmVycmlkZGVuIGdsb2JhbGx5KS5cblx0ZW5jb2RlLm9wdGlvbnMgPSB7XG5cdFx0J2FsbG93VW5zYWZlU3ltYm9scyc6IGZhbHNlLFxuXHRcdCdlbmNvZGVFdmVyeXRoaW5nJzogZmFsc2UsXG5cdFx0J3N0cmljdCc6IGZhbHNlLFxuXHRcdCd1c2VOYW1lZFJlZmVyZW5jZXMnOiBmYWxzZSxcblx0XHQnZGVjaW1hbCcgOiBmYWxzZVxuXHR9O1xuXG5cdHZhciBkZWNvZGUgPSBmdW5jdGlvbihodG1sLCBvcHRpb25zKSB7XG5cdFx0b3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMsIGRlY29kZS5vcHRpb25zKTtcblx0XHR2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG5cdFx0aWYgKHN0cmljdCAmJiByZWdleEludmFsaWRFbnRpdHkudGVzdChodG1sKSkge1xuXHRcdFx0cGFyc2VFcnJvcignbWFsZm9ybWVkIGNoYXJhY3RlciByZWZlcmVuY2UnKTtcblx0XHR9XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZShyZWdleERlY29kZSwgZnVuY3Rpb24oJDAsICQxLCAkMiwgJDMsICQ0LCAkNSwgJDYsICQ3LCAkOCkge1xuXHRcdFx0dmFyIGNvZGVQb2ludDtcblx0XHRcdHZhciBzZW1pY29sb247XG5cdFx0XHR2YXIgZGVjRGlnaXRzO1xuXHRcdFx0dmFyIGhleERpZ2l0cztcblx0XHRcdHZhciByZWZlcmVuY2U7XG5cdFx0XHR2YXIgbmV4dDtcblxuXHRcdFx0aWYgKCQxKSB7XG5cdFx0XHRcdHJlZmVyZW5jZSA9ICQxO1xuXHRcdFx0XHQvLyBOb3RlOiB0aGVyZSBpcyBubyBuZWVkIHRvIGNoZWNrIGBoYXMoZGVjb2RlTWFwLCByZWZlcmVuY2UpYC5cblx0XHRcdFx0cmV0dXJuIGRlY29kZU1hcFtyZWZlcmVuY2VdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoJDIpIHtcblx0XHRcdFx0Ly8gRGVjb2RlIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzIHdpdGhvdXQgdHJhaWxpbmcgYDtgLCBlLmcuIGAmYW1wYC5cblx0XHRcdFx0Ly8gVGhpcyBpcyBvbmx5IGEgcGFyc2UgZXJyb3IgaWYgaXQgZ2V0cyBjb252ZXJ0ZWQgdG8gYCZgLCBvciBpZiBpdCBpc1xuXHRcdFx0XHQvLyBmb2xsb3dlZCBieSBgPWAgaW4gYW4gYXR0cmlidXRlIGNvbnRleHQuXG5cdFx0XHRcdHJlZmVyZW5jZSA9ICQyO1xuXHRcdFx0XHRuZXh0ID0gJDM7XG5cdFx0XHRcdGlmIChuZXh0ICYmIG9wdGlvbnMuaXNBdHRyaWJ1dGVWYWx1ZSkge1xuXHRcdFx0XHRcdGlmIChzdHJpY3QgJiYgbmV4dCA9PSAnPScpIHtcblx0XHRcdFx0XHRcdHBhcnNlRXJyb3IoJ2AmYCBkaWQgbm90IHN0YXJ0IGEgY2hhcmFjdGVyIHJlZmVyZW5jZScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gJDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHN0cmljdCkge1xuXHRcdFx0XHRcdFx0cGFyc2VFcnJvcihcblx0XHRcdFx0XHRcdFx0J25hbWVkIGNoYXJhY3RlciByZWZlcmVuY2Ugd2FzIG5vdCB0ZXJtaW5hdGVkIGJ5IGEgc2VtaWNvbG9uJ1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gTm90ZTogdGhlcmUgaXMgbm8gbmVlZCB0byBjaGVjayBgaGFzKGRlY29kZU1hcExlZ2FjeSwgcmVmZXJlbmNlKWAuXG5cdFx0XHRcdFx0cmV0dXJuIGRlY29kZU1hcExlZ2FjeVtyZWZlcmVuY2VdICsgKG5leHQgfHwgJycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICgkNCkge1xuXHRcdFx0XHQvLyBEZWNvZGUgZGVjaW1hbCBlc2NhcGVzLCBlLmcuIGAmIzExOTU1ODtgLlxuXHRcdFx0XHRkZWNEaWdpdHMgPSAkNDtcblx0XHRcdFx0c2VtaWNvbG9uID0gJDU7XG5cdFx0XHRcdGlmIChzdHJpY3QgJiYgIXNlbWljb2xvbikge1xuXHRcdFx0XHRcdHBhcnNlRXJyb3IoJ2NoYXJhY3RlciByZWZlcmVuY2Ugd2FzIG5vdCB0ZXJtaW5hdGVkIGJ5IGEgc2VtaWNvbG9uJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29kZVBvaW50ID0gcGFyc2VJbnQoZGVjRGlnaXRzLCAxMCk7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnRUb1N5bWJvbChjb2RlUG9pbnQsIHN0cmljdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICgkNikge1xuXHRcdFx0XHQvLyBEZWNvZGUgaGV4YWRlY2ltYWwgZXNjYXBlcywgZS5nLiBgJiN4MUQzMDY7YC5cblx0XHRcdFx0aGV4RGlnaXRzID0gJDY7XG5cdFx0XHRcdHNlbWljb2xvbiA9ICQ3O1xuXHRcdFx0XHRpZiAoc3RyaWN0ICYmICFzZW1pY29sb24pIHtcblx0XHRcdFx0XHRwYXJzZUVycm9yKCdjaGFyYWN0ZXIgcmVmZXJlbmNlIHdhcyBub3QgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvZGVQb2ludCA9IHBhcnNlSW50KGhleERpZ2l0cywgMTYpO1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50VG9TeW1ib2woY29kZVBvaW50LCBzdHJpY3QpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB3ZeKAmXJlIHN0aWxsIGhlcmUsIGBpZiAoJDcpYCBpcyBpbXBsaWVkOyBpdOKAmXMgYW4gYW1iaWd1b3VzXG5cdFx0XHQvLyBhbXBlcnNhbmQgZm9yIHN1cmUuIGh0dHBzOi8vbXRocy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kc1xuXHRcdFx0aWYgKHN0cmljdCkge1xuXHRcdFx0XHRwYXJzZUVycm9yKFxuXHRcdFx0XHRcdCduYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlIHdhcyBub3QgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbidcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAkMDtcblx0XHR9KTtcblx0fTtcblx0Ly8gRXhwb3NlIGRlZmF1bHQgb3B0aW9ucyAoc28gdGhleSBjYW4gYmUgb3ZlcnJpZGRlbiBnbG9iYWxseSkuXG5cdGRlY29kZS5vcHRpb25zID0ge1xuXHRcdCdpc0F0dHJpYnV0ZVZhbHVlJzogZmFsc2UsXG5cdFx0J3N0cmljdCc6IGZhbHNlXG5cdH07XG5cblx0dmFyIGVzY2FwZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZShyZWdleEVzY2FwZSwgZnVuY3Rpb24oJDApIHtcblx0XHRcdC8vIE5vdGU6IHRoZXJlIGlzIG5vIG5lZWQgdG8gY2hlY2sgYGhhcyhlc2NhcGVNYXAsICQwKWAgaGVyZS5cblx0XHRcdHJldHVybiBlc2NhcGVNYXBbJDBdO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciBoZSA9IHtcblx0XHQndmVyc2lvbic6ICcxLjIuMCcsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlc2NhcGUnOiBlc2NhcGUsXG5cdFx0J3VuZXNjYXBlJzogZGVjb2RlXG5cdH07XG5cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gaGU7XG5cdFx0fSk7XG5cdH1cdGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xuXHRcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IGhlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gaGUpIHtcblx0XHRcdFx0aGFzKGhlLCBrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gaGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5oZSA9IGhlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0aW5mbzogJ+KEue+4jycsXG5cdHN1Y2Nlc3M6ICfinIUnLFxuXHR3YXJuaW5nOiAn4pqg77iPJyxcblx0ZXJyb3I6ICfinYzvuI8nXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IG9mZiAqL1xuLyogZXNsaW50LWVudiBjb21tb25qcyAqL1xuXG4vKipcbiAqIFNoaW0gcHJvY2Vzcy5zdGRvdXQuXG4gKi9cblxucHJvY2Vzcy5zdGRvdXQgPSByZXF1aXJlKCdicm93c2VyLXN0ZG91dCcpKHtsYWJlbDogZmFsc2V9KTtcblxudmFyIHBhcnNlUXVlcnkgPSByZXF1aXJlKCcuL2xpYi9icm93c2VyL3BhcnNlLXF1ZXJ5Jyk7XG52YXIgaGlnaGxpZ2h0VGFncyA9IHJlcXVpcmUoJy4vbGliL2Jyb3dzZXIvaGlnaGxpZ2h0LXRhZ3MnKTtcbnZhciBNb2NoYSA9IHJlcXVpcmUoJy4vbGliL21vY2hhJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgTW9jaGEgaW5zdGFuY2UuXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICovXG5cbnZhciBtb2NoYSA9IG5ldyBNb2NoYSh7cmVwb3J0ZXI6ICdodG1sJ30pO1xuXG4vKipcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXG4gKi9cblxudmFyIERhdGUgPSBnbG9iYWwuRGF0ZTtcbnZhciBzZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XG52YXIgc2V0SW50ZXJ2YWwgPSBnbG9iYWwuc2V0SW50ZXJ2YWw7XG52YXIgY2xlYXJUaW1lb3V0ID0gZ2xvYmFsLmNsZWFyVGltZW91dDtcbnZhciBjbGVhckludGVydmFsID0gZ2xvYmFsLmNsZWFySW50ZXJ2YWw7XG5cbnZhciB1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXJzID0gW107XG5cbnZhciBvcmlnaW5hbE9uZXJyb3JIYW5kbGVyID0gZ2xvYmFsLm9uZXJyb3I7XG5cbi8qKlxuICogUmVtb3ZlIHVuY2F1Z2h0RXhjZXB0aW9uIGxpc3RlbmVyLlxuICogUmV2ZXJ0IHRvIG9yaWdpbmFsIG9uZXJyb3IgaGFuZGxlciBpZiBwcmV2aW91c2x5IGRlZmluZWQuXG4gKi9cblxucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChlLCBmbikge1xuICBpZiAoZSA9PT0gJ3VuY2F1Z2h0RXhjZXB0aW9uJykge1xuICAgIGlmIChvcmlnaW5hbE9uZXJyb3JIYW5kbGVyKSB7XG4gICAgICBnbG9iYWwub25lcnJvciA9IG9yaWdpbmFsT25lcnJvckhhbmRsZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsb2JhbC5vbmVycm9yID0gZnVuY3Rpb24gKCkge307XG4gICAgfVxuICAgIHZhciBpID0gdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycy5pbmRleE9mKGZuKTtcbiAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgIHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGxpc3RlbmVyQ291bnQgZm9yICd1bmNhdWdodEV4Y2VwdGlvbicuXG4gKi9cblxucHJvY2Vzcy5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKG5hbWUgPT09ICd1bmNhdWdodEV4Y2VwdGlvbicpIHtcbiAgICByZXR1cm4gdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycy5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG4vKipcbiAqIEltcGxlbWVudHMgdW5jYXVnaHRFeGNlcHRpb24gbGlzdGVuZXIuXG4gKi9cblxucHJvY2Vzcy5vbiA9IGZ1bmN0aW9uIChlLCBmbikge1xuICBpZiAoZSA9PT0gJ3VuY2F1Z2h0RXhjZXB0aW9uJykge1xuICAgIGdsb2JhbC5vbmVycm9yID0gZnVuY3Rpb24gKGVyciwgdXJsLCBsaW5lKSB7XG4gICAgICBmbihuZXcgRXJyb3IoZXJyICsgJyAoJyArIHVybCArICc6JyArIGxpbmUgKyAnKScpKTtcbiAgICAgIHJldHVybiAhbW9jaGEub3B0aW9ucy5hbGxvd1VuY2F1Z2h0O1xuICAgIH07XG4gICAgdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycy5wdXNoKGZuKTtcbiAgfVxufTtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAoZSkge1xuICBpZiAoZSA9PT0gJ3VuY2F1Z2h0RXhjZXB0aW9uJykge1xuICAgIHJldHVybiB1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXJzO1xuICB9XG4gIHJldHVybiBbXTtcbn07XG5cbi8vIFRoZSBCREQgVUkgaXMgcmVnaXN0ZXJlZCBieSBkZWZhdWx0LCBidXQgbm8gVUkgd2lsbCBiZSBmdW5jdGlvbmFsIGluIHRoZVxuLy8gYnJvd3NlciB3aXRob3V0IGFuIGV4cGxpY2l0IGNhbGwgdG8gdGhlIG92ZXJyaWRkZW4gYG1vY2hhLnVpYCAoc2VlIGJlbG93KS5cbi8vIEVuc3VyZSB0aGF0IHRoaXMgZGVmYXVsdCBVSSBkb2VzIG5vdCBleHBvc2UgaXRzIG1ldGhvZHMgdG8gdGhlIGdsb2JhbCBzY29wZS5cbm1vY2hhLnN1aXRlLnJlbW92ZUFsbExpc3RlbmVycygncHJlLXJlcXVpcmUnKTtcblxudmFyIGltbWVkaWF0ZVF1ZXVlID0gW107XG52YXIgaW1tZWRpYXRlVGltZW91dDtcblxuZnVuY3Rpb24gdGltZXNsaWNlKCkge1xuICB2YXIgaW1tZWRpYXRlU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgd2hpbGUgKGltbWVkaWF0ZVF1ZXVlLmxlbmd0aCAmJiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGltbWVkaWF0ZVN0YXJ0IDwgMTAwKSB7XG4gICAgaW1tZWRpYXRlUXVldWUuc2hpZnQoKSgpO1xuICB9XG4gIGlmIChpbW1lZGlhdGVRdWV1ZS5sZW5ndGgpIHtcbiAgICBpbW1lZGlhdGVUaW1lb3V0ID0gc2V0VGltZW91dCh0aW1lc2xpY2UsIDApO1xuICB9IGVsc2Uge1xuICAgIGltbWVkaWF0ZVRpbWVvdXQgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogSGlnaC1wZXJmb3JtYW5jZSBvdmVycmlkZSBvZiBSdW5uZXIuaW1tZWRpYXRlbHkuXG4gKi9cblxuTW9jaGEuUnVubmVyLmltbWVkaWF0ZWx5ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIGltbWVkaWF0ZVF1ZXVlLnB1c2goY2FsbGJhY2spO1xuICBpZiAoIWltbWVkaWF0ZVRpbWVvdXQpIHtcbiAgICBpbW1lZGlhdGVUaW1lb3V0ID0gc2V0VGltZW91dCh0aW1lc2xpY2UsIDApO1xuICB9XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIGFsbG93IGFzc2VydGlvbiBsaWJyYXJpZXMgdG8gdGhyb3cgZXJyb3JzIGRpcmVjdGx5IGludG8gbW9jaGEuXG4gKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHJ1bm5pbmcgdGVzdHMgaW4gYSBicm93c2VyIGJlY2F1c2Ugd2luZG93Lm9uZXJyb3Igd2lsbFxuICogb25seSByZWNlaXZlIHRoZSAnbWVzc2FnZScgYXR0cmlidXRlIG9mIHRoZSBFcnJvci5cbiAqL1xubW9jaGEudGhyb3dFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgIGZuKGVycik7XG4gIH0pO1xuICB0aHJvdyBlcnI7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIHVpIHRvIGVuc3VyZSB0aGF0IHRoZSB1aSBmdW5jdGlvbnMgYXJlIGluaXRpYWxpemVkLlxuICogTm9ybWFsbHkgdGhpcyB3b3VsZCBoYXBwZW4gaW4gTW9jaGEucHJvdG90eXBlLmxvYWRGaWxlcy5cbiAqL1xuXG5tb2NoYS51aSA9IGZ1bmN0aW9uICh1aSkge1xuICBNb2NoYS5wcm90b3R5cGUudWkuY2FsbCh0aGlzLCB1aSk7XG4gIHRoaXMuc3VpdGUuZW1pdCgncHJlLXJlcXVpcmUnLCBnbG9iYWwsIG51bGwsIHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0dXAgbW9jaGEgd2l0aCB0aGUgZ2l2ZW4gc2V0dGluZyBvcHRpb25zLlxuICovXG5cbm1vY2hhLnNldHVwID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgIG9wdHMgPSB7dWk6IG9wdHN9O1xuICB9XG4gIGlmIChvcHRzLmRlbGF5ID09PSB0cnVlKSB7XG4gICAgdGhpcy5kZWxheSgpO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgT2JqZWN0LmtleXMob3B0cylcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgIHJldHVybiBvcHQgIT09ICdkZWxheSc7XG4gICAgfSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbiAob3B0KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdHMsIG9wdCkpIHtcbiAgICAgICAgc2VsZltvcHRdKG9wdHNbb3B0XSk7XG4gICAgICB9XG4gICAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSdW4gbW9jaGEsIHJldHVybmluZyB0aGUgUnVubmVyLlxuICovXG5cbm1vY2hhLnJ1biA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgb3B0aW9ucyA9IG1vY2hhLm9wdGlvbnM7XG4gIG1vY2hhLmdsb2JhbHMoJ2xvY2F0aW9uJyk7XG5cbiAgdmFyIHF1ZXJ5ID0gcGFyc2VRdWVyeShnbG9iYWwubG9jYXRpb24uc2VhcmNoIHx8ICcnKTtcbiAgaWYgKHF1ZXJ5LmdyZXApIHtcbiAgICBtb2NoYS5ncmVwKHF1ZXJ5LmdyZXApO1xuICB9XG4gIGlmIChxdWVyeS5mZ3JlcCkge1xuICAgIG1vY2hhLmZncmVwKHF1ZXJ5LmZncmVwKTtcbiAgfVxuICBpZiAocXVlcnkuaW52ZXJ0KSB7XG4gICAgbW9jaGEuaW52ZXJ0KCk7XG4gIH1cblxuICByZXR1cm4gTW9jaGEucHJvdG90eXBlLnJ1bi5jYWxsKG1vY2hhLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgLy8gVGhlIERPTSBEb2N1bWVudCBpcyBub3QgYXZhaWxhYmxlIGluIFdlYiBXb3JrZXJzLlxuICAgIHZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICBpZiAoXG4gICAgICBkb2N1bWVudCAmJlxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhJykgJiZcbiAgICAgIG9wdGlvbnMubm9IaWdobGlnaHRpbmcgIT09IHRydWVcbiAgICApIHtcbiAgICAgIGhpZ2hsaWdodFRhZ3MoJ2NvZGUnKTtcbiAgICB9XG4gICAgaWYgKGZuKSB7XG4gICAgICBmbihlcnIpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEV4cG9zZSB0aGUgcHJvY2VzcyBzaGltLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21vY2hhanMvbW9jaGEvcHVsbC85MTZcbiAqL1xuXG5Nb2NoYS5wcm9jZXNzID0gcHJvY2VzcztcblxuLyoqXG4gKiBFeHBvc2UgbW9jaGEuXG4gKi9cbmdsb2JhbC5Nb2NoYSA9IE1vY2hhO1xuZ2xvYmFsLm1vY2hhID0gbW9jaGE7XG5cbi8vIGZvciBidW5kbGVyczogZW5hYmxlIGBpbXBvcnQge2Rlc2NyaWJlLCBpdH0gZnJvbSAnbW9jaGEnYFxuLy8gYGJkZGAgaW50ZXJmYWNlIG9ubHlcbi8vIHByZXR0aWVyLWlnbm9yZVxuWyBcbiAgJ2Rlc2NyaWJlJywgJ2NvbnRleHQnLCAnaXQnLCAnc3BlY2lmeScsXG4gICd4ZGVzY3JpYmUnLCAneGNvbnRleHQnLCAneGl0JywgJ3hzcGVjaWZ5JyxcbiAgJ2JlZm9yZScsICdiZWZvcmVFYWNoJywgJ2FmdGVyRWFjaCcsICdhZnRlcidcbl0uZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgbW9jaGFba2V5XSA9IGdsb2JhbFtrZXldO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbW9jaGE7XG4iLCJmdW5jdGlvbiB3ZWJwYWNrRW1wdHlDb250ZXh0KHJlcSkge1xuXHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0dGhyb3cgZTtcbn1cbndlYnBhY2tFbXB0eUNvbnRleHQua2V5cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH07XG53ZWJwYWNrRW1wdHlDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xud2VicGFja0VtcHR5Q29udGV4dC5pZCA9IFwiLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliIHN5bmMgcmVjdXJzaXZlXCI7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEhpZ2hsaWdodCB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGBqc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBqc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoaWdobGlnaHQoanMpIHtcbiAgcmV0dXJuIGpzXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXFwvXFwvKC4qKS9nbSwgJzxzcGFuIGNsYXNzPVwiY29tbWVudFwiPi8vJDE8L3NwYW4+JylcbiAgICAucmVwbGFjZSgvKCcuKj8nKS9nbSwgJzxzcGFuIGNsYXNzPVwic3RyaW5nXCI+JDE8L3NwYW4+JylcbiAgICAucmVwbGFjZSgvKFxcZCtcXC5cXGQrKS9nbSwgJzxzcGFuIGNsYXNzPVwibnVtYmVyXCI+JDE8L3NwYW4+JylcbiAgICAucmVwbGFjZSgvKFxcZCspL2dtLCAnPHNwYW4gY2xhc3M9XCJudW1iZXJcIj4kMTwvc3Bhbj4nKVxuICAgIC5yZXBsYWNlKFxuICAgICAgL1xcYm5ld1sgXFx0XSsoXFx3KykvZ20sXG4gICAgICAnPHNwYW4gY2xhc3M9XCJrZXl3b3JkXCI+bmV3PC9zcGFuPiA8c3BhbiBjbGFzcz1cImluaXRcIj4kMTwvc3Bhbj4nXG4gICAgKVxuICAgIC5yZXBsYWNlKFxuICAgICAgL1xcYihmdW5jdGlvbnxuZXd8dGhyb3d8cmV0dXJufHZhcnxpZnxlbHNlKVxcYi9nbSxcbiAgICAgICc8c3BhbiBjbGFzcz1cImtleXdvcmRcIj4kMTwvc3Bhbj4nXG4gICAgKTtcbn1cblxuLyoqXG4gKiBIaWdobGlnaHQgdGhlIGNvbnRlbnRzIG9mIHRhZyBgbmFtZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGlnaGxpZ2h0VGFncyhuYW1lKSB7XG4gIHZhciBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhJykuZ2V0RWxlbWVudHNCeVRhZ05hbWUobmFtZSk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgY29kZVtpXS5pbm5lckhUTUwgPSBoaWdobGlnaHQoY29kZVtpXS5pbm5lckhUTUwpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgcXNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcXNcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsIHN0cmluZz59XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VRdWVyeShxcykge1xuICByZXR1cm4gcXNcbiAgICAucmVwbGFjZSgnPycsICcnKVxuICAgIC5zcGxpdCgnJicpXG4gICAgLnJlZHVjZShmdW5jdGlvbiAob2JqLCBwYWlyKSB7XG4gICAgICB2YXIgaSA9IHBhaXIuaW5kZXhPZignPScpO1xuICAgICAgdmFyIGtleSA9IHBhaXIuc2xpY2UoMCwgaSk7XG4gICAgICB2YXIgdmFsID0gcGFpci5zbGljZSgrK2kpO1xuXG4gICAgICAvLyBEdWUgdG8gaG93IHRoZSBVUkxTZWFyY2hQYXJhbXMgQVBJIHRyZWF0cyBzcGFjZXNcbiAgICAgIG9ialtrZXldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbC5yZXBsYWNlKC9cXCsvZywgJyUyMCcpKTtcblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiBAbW9kdWxlIGJyb3dzZXIvUHJvZ3Jlc3NcbiovXG5cbi8qKlxuICogRXhwb3NlIGBQcm9ncmVzc2AuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQcm9ncmVzcztcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBQcm9ncmVzc2AgaW5kaWNhdG9yLlxuICovXG5mdW5jdGlvbiBQcm9ncmVzcygpIHtcbiAgdGhpcy5wZXJjZW50ID0gMDtcbiAgdGhpcy5zaXplKDApO1xuICB0aGlzLmZvbnRTaXplKDExKTtcbiAgdGhpcy5mb250KCdoZWx2ZXRpY2EsIGFyaWFsLCBzYW5zLXNlcmlmJyk7XG59XG5cbi8qKlxuICogU2V0IHByb2dyZXNzIHNpemUgdG8gYHNpemVgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXG4gKi9cblByb2dyZXNzLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgdGhpcy5fc2l6ZSA9IHNpemU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGV4dCB0byBgdGV4dGAuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cbiAqL1xuUHJvZ3Jlc3MucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICB0aGlzLl90ZXh0ID0gdGV4dDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBmb250IHNpemUgdG8gYHNpemVgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXG4gKi9cblByb2dyZXNzLnByb3RvdHlwZS5mb250U2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHRoaXMuX2ZvbnRTaXplID0gc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBmb250IHRvIGBmYW1pbHlgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmYW1pbHlcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cbiAqL1xuUHJvZ3Jlc3MucHJvdG90eXBlLmZvbnQgPSBmdW5jdGlvbiAoZmFtaWx5KSB7XG4gIHRoaXMuX2ZvbnQgPSBmYW1pbHk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgcGVyY2VudGFnZSB0byBgbmAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cbiAqL1xuUHJvZ3Jlc3MucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMucGVyY2VudCA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEcmF3IG9uIGBjdHhgLlxuICpcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJkfSBjdHhcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cbiAqL1xuUHJvZ3Jlc3MucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gIHRyeSB7XG4gICAgdmFyIHBlcmNlbnQgPSBNYXRoLm1pbih0aGlzLnBlcmNlbnQsIDEwMCk7XG4gICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xuICAgIHZhciBoYWxmID0gc2l6ZSAvIDI7XG4gICAgdmFyIHggPSBoYWxmO1xuICAgIHZhciB5ID0gaGFsZjtcbiAgICB2YXIgcmFkID0gaGFsZiAtIDE7XG4gICAgdmFyIGZvbnRTaXplID0gdGhpcy5fZm9udFNpemU7XG5cbiAgICBjdHguZm9udCA9IGZvbnRTaXplICsgJ3B4ICcgKyB0aGlzLl9mb250O1xuXG4gICAgdmFyIGFuZ2xlID0gTWF0aC5QSSAqIDIgKiAocGVyY2VudCAvIDEwMCk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBzaXplLCBzaXplKTtcblxuICAgIC8vIG91dGVyIGNpcmNsZVxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjOWY5ZjlmJztcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyh4LCB5LCByYWQsIDAsIGFuZ2xlLCBmYWxzZSk7XG4gICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgLy8gaW5uZXIgY2lyY2xlXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJyNlZWUnO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHgsIHksIHJhZCAtIDEsIDAsIGFuZ2xlLCB0cnVlKTtcbiAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAvLyB0ZXh0XG4gICAgdmFyIHRleHQgPSB0aGlzLl90ZXh0IHx8IChwZXJjZW50IHwgMCkgKyAnJSc7XG4gICAgdmFyIHcgPSBjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG5cbiAgICBjdHguZmlsbFRleHQodGV4dCwgeCAtIHcgLyAyICsgMSwgeSArIGZvbnRTaXplIC8gMiAtIDEpO1xuICB9IGNhdGNoIChpZ25vcmUpIHtcbiAgICAvLyBkb24ndCBmYWlsIGlmIHdlIGNhbid0IHJlbmRlciBwcm9ncmVzc1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBDb250ZXh0XG4gKi9cbi8qKlxuICogRXhwb3NlIGBDb250ZXh0YC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRleHQ7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgQ29udGV4dGAuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQ29udGV4dCgpIHt9XG5cbi8qKlxuICogU2V0IG9yIGdldCB0aGUgY29udGV4dCBgUnVubmFibGVgIHRvIGBydW5uYWJsZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UnVubmFibGV9IHJ1bm5hYmxlXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBjb250ZXh0XG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnJ1bm5hYmxlID0gZnVuY3Rpb24gKHJ1bm5hYmxlKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl9ydW5uYWJsZTtcbiAgfVxuICB0aGlzLnRlc3QgPSB0aGlzLl9ydW5uYWJsZSA9IHJ1bm5hYmxlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IG9yIGdldCB0ZXN0IHRpbWVvdXQgYG1zYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBzZWxmXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMucnVubmFibGUoKS50aW1lb3V0KCk7XG4gIH1cbiAgdGhpcy5ydW5uYWJsZSgpLnRpbWVvdXQobXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IG9yIGdldCB0ZXN0IHNsb3duZXNzIHRocmVzaG9sZCBgbXNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbXNcbiAqIEByZXR1cm4ge0NvbnRleHR9IHNlbGZcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuc2xvdyA9IGZ1bmN0aW9uIChtcykge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5uYWJsZSgpLnNsb3coKTtcbiAgfVxuICB0aGlzLnJ1bm5hYmxlKCkuc2xvdyhtcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNYXJrIGEgdGVzdCBhcyBza2lwcGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdGhyb3dzIFBlbmRpbmdcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5ydW5uYWJsZSgpLnNraXAoKTtcbn07XG5cbi8qKlxuICogU2V0IG9yIGdldCBhIG51bWJlciBvZiBhbGxvd2VkIHJldHJpZXMgb24gZmFpbGVkIHRlc3RzXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBzZWxmXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnJldHJpZXMgPSBmdW5jdGlvbiAobikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5uYWJsZSgpLnJldHJpZXMoKTtcbiAgfVxuICB0aGlzLnJ1bm5hYmxlKCkucmV0cmllcyhuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7Zm9ybWF0fSA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBDb250YWlucyBlcnJvciBjb2RlcywgZmFjdG9yeSBmdW5jdGlvbnMgdG8gY3JlYXRlIHRocm93YWJsZSBlcnJvciBvYmplY3RzLFxuICogYW5kIHdhcm5pbmcvZGVwcmVjYXRpb24gZnVuY3Rpb25zLlxuICogQG1vZHVsZVxuICovXG5cbi8qKlxuICogcHJvY2Vzcy5lbWl0V2FybmluZyBvciBhIHBvbHlmaWxsXG4gKiBAc2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NfcHJvY2Vzc19lbWl0d2FybmluZ193YXJuaW5nX29wdGlvbnNcbiAqIEBpZ25vcmVcbiAqL1xuY29uc3QgZW1pdFdhcm5pbmcgPSAobXNnLCB0eXBlKSA9PiB7XG4gIGlmIChwcm9jZXNzLmVtaXRXYXJuaW5nKSB7XG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhtc2csIHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zb2xlLndhcm4odHlwZSArICc6ICcgKyBtc2cpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIFNob3cgYSBkZXByZWNhdGlvbiB3YXJuaW5nLiBFYWNoIGRpc3RpbmN0IG1lc3NhZ2UgaXMgb25seSBkaXNwbGF5ZWQgb25jZS5cbiAqIElnbm9yZXMgZW1wdHkgbWVzc2FnZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFttc2ddIC0gV2FybmluZyB0byBwcmludFxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgZGVwcmVjYXRlID0gbXNnID0+IHtcbiAgbXNnID0gU3RyaW5nKG1zZyk7XG4gIGlmIChtc2cgJiYgIWRlcHJlY2F0ZS5jYWNoZVttc2ddKSB7XG4gICAgZGVwcmVjYXRlLmNhY2hlW21zZ10gPSB0cnVlO1xuICAgIGVtaXRXYXJuaW5nKG1zZywgJ0RlcHJlY2F0aW9uV2FybmluZycpO1xuICB9XG59O1xuZGVwcmVjYXRlLmNhY2hlID0ge307XG5cbi8qKlxuICogU2hvdyBhIGdlbmVyaWMgd2FybmluZy5cbiAqIElnbm9yZXMgZW1wdHkgbWVzc2FnZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFttc2ddIC0gV2FybmluZyB0byBwcmludFxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgd2FybiA9IG1zZyA9PiB7XG4gIGlmIChtc2cpIHtcbiAgICBlbWl0V2FybmluZyhtc2cpO1xuICB9XG59O1xuXG4vKipcbiAqIFdoZW4gTW9jaGEgdGhyb3dzIGV4Y2VwdGlvbnMgKG9yIHJlamVjdHMgYFByb21pc2VgcyksIGl0IGF0dGVtcHRzIHRvIGFzc2lnbiBhIGBjb2RlYCBwcm9wZXJ0eSB0byB0aGUgYEVycm9yYCBvYmplY3QsIGZvciBlYXNpZXIgaGFuZGxpbmcuIFRoZXNlIGFyZSB0aGUgcG90ZW50aWFsIHZhbHVlcyBvZiBgY29kZWAuXG4gKiBAcHVibGljXG4gKiBAbmFtZXNwYWNlXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmxpYi9lcnJvcnNcbiAqL1xudmFyIGNvbnN0YW50cyA9IHtcbiAgLyoqXG4gICAqIEFuIHVucmVjb3ZlcmFibGUgZXJyb3IuXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgRkFUQUw6ICdFUlJfTU9DSEFfRkFUQUwnLFxuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBhbiBhcmd1bWVudCB0byBhIGZ1bmN0aW9uIGNhbGwgaXMgaW52YWxpZFxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIElOVkFMSURfQVJHX1RZUEU6ICdFUlJfTU9DSEFfSU5WQUxJRF9BUkdfVFlQRScsXG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiBhbiBhcmd1bWVudCB0byBhIGZ1bmN0aW9uIGNhbGwgaXMgaW52YWxpZFxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIElOVkFMSURfQVJHX1ZBTFVFOiAnRVJSX01PQ0hBX0lOVkFMSURfQVJHX1ZBTFVFJyxcblxuICAvKipcbiAgICogU29tZXRoaW5nIHdhcyB0aHJvd24sIGJ1dCBpdCB3YXNuJ3QgYW4gYEVycm9yYFxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIElOVkFMSURfRVhDRVBUSU9OOiAnRVJSX01PQ0hBX0lOVkFMSURfRVhDRVBUSU9OJyxcblxuICAvKipcbiAgICogQW4gaW50ZXJmYWNlIChlLmcuLCBgTW9jaGEuaW50ZXJmYWNlc2ApIGlzIHVua25vd24gb3IgaW52YWxpZFxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIElOVkFMSURfSU5URVJGQUNFOiAnRVJSX01PQ0hBX0lOVkFMSURfSU5URVJGQUNFJyxcblxuICAvKipcbiAgICogQSByZXBvcnRlciAoLmUuZywgYE1vY2hhLnJlcG9ydGVyc2ApIGlzIHVua25vd24gb3IgaW52YWxpZFxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIElOVkFMSURfUkVQT1JURVI6ICdFUlJfTU9DSEFfSU5WQUxJRF9SRVBPUlRFUicsXG5cbiAgLyoqXG4gICAqIGBkb25lKClgIHdhcyBjYWxsZWQgdHdpY2UgaW4gYSBgVGVzdGAgb3IgYEhvb2tgIGNhbGxiYWNrXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgTVVMVElQTEVfRE9ORTogJ0VSUl9NT0NIQV9NVUxUSVBMRV9ET05FJyxcblxuICAvKipcbiAgICogTm8gZmlsZXMgbWF0Y2hlZCB0aGUgcGF0dGVybiBwcm92aWRlZCBieSB0aGUgdXNlclxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIE5PX0ZJTEVTX01BVENIX1BBVFRFUk46ICdFUlJfTU9DSEFfTk9fRklMRVNfTUFUQ0hfUEFUVEVSTicsXG5cbiAgLyoqXG4gICAqIEtub3duLCBidXQgdW5zdXBwb3J0ZWQgYmVoYXZpb3Igb2Ygc29tZSBraW5kXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgVU5TVVBQT1JURUQ6ICdFUlJfTU9DSEFfVU5TVVBQT1JURUQnLFxuXG4gIC8qKlxuICAgKiBJbnZhbGlkIHN0YXRlIHRyYW5zaXRpb24gb2NjdXJyaW5nIGluIGBNb2NoYWAgaW5zdGFuY2VcbiAgICogQGNvbnN0YW50XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBJTlNUQU5DRV9BTFJFQURZX1JVTk5JTkc6ICdFUlJfTU9DSEFfSU5TVEFOQ0VfQUxSRUFEWV9SVU5OSU5HJyxcblxuICAvKipcbiAgICogSW52YWxpZCBzdGF0ZSB0cmFuc2l0aW9uIG9jY3VycmluZyBpbiBgTW9jaGFgIGluc3RhbmNlXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgSU5TVEFOQ0VfQUxSRUFEWV9ESVNQT1NFRDogJ0VSUl9NT0NIQV9JTlNUQU5DRV9BTFJFQURZX0RJU1BPU0VEJyxcblxuICAvKipcbiAgICogVXNlIG9mIGBvbmx5KClgIHcvIGAtLWZvcmJpZC1vbmx5YCByZXN1bHRzIGluIHRoaXMgZXJyb3IuXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgRk9SQklEREVOX0VYQ0xVU0lWSVRZOiAnRVJSX01PQ0hBX0ZPUkJJRERFTl9FWENMVVNJVklUWScsXG5cbiAgLyoqXG4gICAqIFRvIGJlIHRocm93biB3aGVuIGEgdXNlci1kZWZpbmVkIHBsdWdpbiBpbXBsZW1lbnRhdGlvbiAoZS5nLiwgYG1vY2hhSG9va3NgKSBpcyBpbnZhbGlkXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgSU5WQUxJRF9QTFVHSU5fSU1QTEVNRU5UQVRJT046ICdFUlJfTU9DSEFfSU5WQUxJRF9QTFVHSU5fSU1QTEVNRU5UQVRJT04nLFxuXG4gIC8qKlxuICAgKiBUbyBiZSB0aHJvd24gd2hlbiBhIGJ1aWx0aW4gb3IgdGhpcmQtcGFydHkgcGx1Z2luIGRlZmluaXRpb24gKHRoZSBfZGVmaW5pdGlvbl8gb2YgYG1vY2hhSG9va3NgKSBpcyBpbnZhbGlkXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgSU5WQUxJRF9QTFVHSU5fREVGSU5JVElPTjogJ0VSUl9NT0NIQV9JTlZBTElEX1BMVUdJTl9ERUZJTklUSU9OJyxcblxuICAvKipcbiAgICogV2hlbiBhIHJ1bm5hYmxlIGV4Y2VlZHMgaXRzIGFsbG93ZWQgcnVuIHRpbWUuXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgVElNRU9VVDogJ0VSUl9NT0NIQV9USU1FT1VUJyxcblxuICAvKipcbiAgICogSW5wdXQgZmlsZSBpcyBub3QgYWJsZSB0byBiZSBwYXJzZWRcbiAgICogQGNvbnN0YW50XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBVTlBBUlNBQkxFX0ZJTEU6ICdFUlJfTU9DSEFfVU5QQVJTQUJMRV9GSUxFJ1xufTtcblxuLyoqXG4gKiBBIHNldCBjb250YWluaW5nIGFsbCBzdHJpbmcgdmFsdWVzIG9mIGFsbCBNb2NoYSBlcnJvciBjb25zdGFudHMsIGZvciB1c2UgYnkge0BsaW5rIGlzTW9jaGFFcnJvcn0uXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBNT0NIQV9FUlJPUlMgPSBuZXcgU2V0KE9iamVjdC52YWx1ZXMoY29uc3RhbnRzKSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gbm8gZmlsZXMgdG8gYmUgdGVzdGVkIGNvdWxkIGJlIGZvdW5kIHVzaW5nIHNwZWNpZmllZCBwYXR0ZXJuLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiAtIFVzZXItc3BlY2lmaWVkIGFyZ3VtZW50IHZhbHVlLlxuICogQHJldHVybnMge0Vycm9yfSBpbnN0YW5jZSBkZXRhaWxpbmcgdGhlIGVycm9yIGNvbmRpdGlvblxuICovXG5mdW5jdGlvbiBjcmVhdGVOb0ZpbGVzTWF0Y2hQYXR0ZXJuRXJyb3IobWVzc2FnZSwgcGF0dGVybikge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnIuY29kZSA9IGNvbnN0YW50cy5OT19GSUxFU19NQVRDSF9QQVRURVJOO1xuICBlcnIucGF0dGVybiA9IHBhdHRlcm47XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gdGhlIHJlcG9ydGVyIHNwZWNpZmllZCBpbiB0aGUgb3B0aW9ucyB3YXMgbm90IGZvdW5kLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwb3J0ZXIgLSBVc2VyLXNwZWNpZmllZCByZXBvcnRlciB2YWx1ZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gaW5zdGFuY2UgZGV0YWlsaW5nIHRoZSBlcnJvciBjb25kaXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW52YWxpZFJlcG9ydGVyRXJyb3IobWVzc2FnZSwgcmVwb3J0ZXIpIHtcbiAgdmFyIGVyciA9IG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XG4gIGVyci5jb2RlID0gY29uc3RhbnRzLklOVkFMSURfUkVQT1JURVI7XG4gIGVyci5yZXBvcnRlciA9IHJlcG9ydGVyO1xuICByZXR1cm4gZXJyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IHRvIGJlIHRocm93biB3aGVuIHRoZSBpbnRlcmZhY2Ugc3BlY2lmaWVkIGluIHRoZSBvcHRpb25zIHdhcyBub3QgZm91bmQuXG4gKlxuICogQHB1YmxpY1xuICogQHN0YXRpY1xuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBFcnJvciBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1aSAtIFVzZXItc3BlY2lmaWVkIGludGVyZmFjZSB2YWx1ZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gaW5zdGFuY2UgZGV0YWlsaW5nIHRoZSBlcnJvciBjb25kaXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW52YWxpZEludGVyZmFjZUVycm9yKG1lc3NhZ2UsIHVpKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVyci5jb2RlID0gY29uc3RhbnRzLklOVkFMSURfSU5URVJGQUNFO1xuICBlcnIuaW50ZXJmYWNlID0gdWk7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gYSBiZWhhdmlvciwgb3B0aW9uLCBvciBwYXJhbWV0ZXIgaXMgdW5zdXBwb3J0ZWQuXG4gKlxuICogQHB1YmxpY1xuICogQHN0YXRpY1xuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBFcnJvciBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZC5cbiAqIEByZXR1cm5zIHtFcnJvcn0gaW5zdGFuY2UgZGV0YWlsaW5nIHRoZSBlcnJvciBjb25kaXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVW5zdXBwb3J0ZWRFcnJvcihtZXNzYWdlKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVyci5jb2RlID0gY29uc3RhbnRzLlVOU1VQUE9SVEVEO1xuICByZXR1cm4gZXJyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IHRvIGJlIHRocm93biB3aGVuIGFuIGFyZ3VtZW50IGlzIG1pc3NpbmcuXG4gKlxuICogQHB1YmxpY1xuICogQHN0YXRpY1xuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBFcnJvciBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmd1bWVudCAtIEFyZ3VtZW50IG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWQgLSBFeHBlY3RlZCBhcmd1bWVudCBkYXRhdHlwZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gaW5zdGFuY2UgZGV0YWlsaW5nIHRoZSBlcnJvciBjb25kaXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWlzc2luZ0FyZ3VtZW50RXJyb3IobWVzc2FnZSwgYXJndW1lbnQsIGV4cGVjdGVkKSB7XG4gIHJldHVybiBjcmVhdGVJbnZhbGlkQXJndW1lbnRUeXBlRXJyb3IobWVzc2FnZSwgYXJndW1lbnQsIGV4cGVjdGVkKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCB0byBiZSB0aHJvd24gd2hlbiBhbiBhcmd1bWVudCBkaWQgbm90IHVzZSB0aGUgc3VwcG9ydGVkIHR5cGVcbiAqXG4gKiBAcHVibGljXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEVycm9yIG1lc3NhZ2UgdG8gYmUgZGlzcGxheWVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3VtZW50IC0gQXJndW1lbnQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZCAtIEV4cGVjdGVkIGFyZ3VtZW50IGRhdGF0eXBlLlxuICogQHJldHVybnMge0Vycm9yfSBpbnN0YW5jZSBkZXRhaWxpbmcgdGhlIGVycm9yIGNvbmRpdGlvblxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkQXJndW1lbnRUeXBlRXJyb3IobWVzc2FnZSwgYXJndW1lbnQsIGV4cGVjdGVkKSB7XG4gIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKG1lc3NhZ2UpO1xuICBlcnIuY29kZSA9IGNvbnN0YW50cy5JTlZBTElEX0FSR19UWVBFO1xuICBlcnIuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgZXJyLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gIGVyci5hY3R1YWwgPSB0eXBlb2YgYXJndW1lbnQ7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gYW4gYXJndW1lbnQgZGlkIG5vdCB1c2UgdGhlIHN1cHBvcnRlZCB2YWx1ZVxuICpcbiAqIEBwdWJsaWNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJndW1lbnQgLSBBcmd1bWVudCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gQXJndW1lbnQgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gLSBXaHkgdmFsdWUgaXMgaW52YWxpZC5cbiAqIEByZXR1cm5zIHtFcnJvcn0gaW5zdGFuY2UgZGV0YWlsaW5nIHRoZSBlcnJvciBjb25kaXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW52YWxpZEFyZ3VtZW50VmFsdWVFcnJvcihtZXNzYWdlLCBhcmd1bWVudCwgdmFsdWUsIHJlYXNvbikge1xuICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcihtZXNzYWdlKTtcbiAgZXJyLmNvZGUgPSBjb25zdGFudHMuSU5WQUxJRF9BUkdfVkFMVUU7XG4gIGVyci5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICBlcnIudmFsdWUgPSB2YWx1ZTtcbiAgZXJyLnJlYXNvbiA9IHR5cGVvZiByZWFzb24gIT09ICd1bmRlZmluZWQnID8gcmVhc29uIDogJ2lzIGludmFsaWQnO1xuICByZXR1cm4gZXJyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IHRvIGJlIHRocm93biB3aGVuIGFuIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0LCBidXQgdGhlIGBFcnJvcmAgaXMgZmFsc3kgb3IgdW5kZWZpbmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuXG4gKiBAcmV0dXJucyB7RXJyb3J9IGluc3RhbmNlIGRldGFpbGluZyB0aGUgZXJyb3IgY29uZGl0aW9uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWRFeGNlcHRpb25FcnJvcihtZXNzYWdlLCB2YWx1ZSkge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnIuY29kZSA9IGNvbnN0YW50cy5JTlZBTElEX0VYQ0VQVElPTjtcbiAgZXJyLnZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgZXJyLnZhbHVlID0gdmFsdWU7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gYW4gdW5yZWNvdmVyYWJsZSBlcnJvciBvY2N1cnMuXG4gKlxuICogQHB1YmxpY1xuICogQHN0YXRpY1xuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBFcnJvciBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZC5cbiAqIEByZXR1cm5zIHtFcnJvcn0gaW5zdGFuY2UgZGV0YWlsaW5nIHRoZSBlcnJvciBjb25kaXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmF0YWxFcnJvcihtZXNzYWdlLCB2YWx1ZSkge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnIuY29kZSA9IGNvbnN0YW50cy5GQVRBTDtcbiAgZXJyLnZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgZXJyLnZhbHVlID0gdmFsdWU7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogRHluYW1pY2FsbHkgY3JlYXRlcyBhIHBsdWdpbi10eXBlLXNwZWNpZmljIGVycm9yIGJhc2VkIG9uIHBsdWdpbiB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7XCJyZXBvcnRlclwifFwidWlcIn0gcGx1Z2luVHlwZSAtIFBsdWdpbiB0eXBlLiBGdXR1cmU6IGV4cGFuZCBhcyBuZWVkZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGx1Z2luSWRdIC0gTmFtZS9wYXRoIG9mIHBsdWdpbiwgaWYgYW55XG4gKiBAdGhyb3dzIFdoZW4gYHBsdWdpblR5cGVgIGlzIG5vdCBrbm93blxuICogQHB1YmxpY1xuICogQHN0YXRpY1xuICogQHJldHVybnMge0Vycm9yfVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkTGVnYWN5UGx1Z2luRXJyb3IobWVzc2FnZSwgcGx1Z2luVHlwZSwgcGx1Z2luSWQpIHtcbiAgc3dpdGNoIChwbHVnaW5UeXBlKSB7XG4gICAgY2FzZSAncmVwb3J0ZXInOlxuICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWRSZXBvcnRlckVycm9yKG1lc3NhZ2UsIHBsdWdpbklkKTtcbiAgICBjYXNlICd1aSc6XG4gICAgICByZXR1cm4gY3JlYXRlSW52YWxpZEludGVyZmFjZUVycm9yKG1lc3NhZ2UsIHBsdWdpbklkKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBsdWdpblR5cGUgXCInICsgcGx1Z2luVHlwZSArICdcIicpO1xuICB9XG59XG5cbi8qKlxuICogKipERVBSRUNBVEVEKiouICBVc2Uge0BsaW5rIGNyZWF0ZUludmFsaWRMZWdhY3lQbHVnaW5FcnJvcn0gaW5zdGVhZCAgRHluYW1pY2FsbHkgY3JlYXRlcyBhIHBsdWdpbi10eXBlLXNwZWNpZmljIGVycm9yIGJhc2VkIG9uIHBsdWdpbiB0eXBlXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBFcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge1wicmVwb3J0ZXJcInxcImludGVyZmFjZVwifSBwbHVnaW5UeXBlIC0gUGx1Z2luIHR5cGUuIEZ1dHVyZTogZXhwYW5kIGFzIG5lZWRlZFxuICogQHBhcmFtIHtzdHJpbmd9IFtwbHVnaW5JZF0gLSBOYW1lL3BhdGggb2YgcGx1Z2luLCBpZiBhbnlcbiAqIEB0aHJvd3MgV2hlbiBgcGx1Z2luVHlwZWAgaXMgbm90IGtub3duXG4gKiBAcHVibGljXG4gKiBAc3RhdGljXG4gKiBAcmV0dXJucyB7RXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWRQbHVnaW5FcnJvciguLi5hcmdzKSB7XG4gIGRlcHJlY2F0ZSgnVXNlIGNyZWF0ZUludmFsaWRMZWdhY3lQbHVnaW5FcnJvcigpIGluc3RlYWQnKTtcbiAgcmV0dXJuIGNyZWF0ZUludmFsaWRMZWdhY3lQbHVnaW5FcnJvciguLi5hcmdzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCB0byBiZSB0aHJvd24gd2hlbiBhIG1vY2hhIG9iamVjdCdzIGBydW5gIG1ldGhvZCBpcyBleGVjdXRlZCB3aGlsZSBpdCBpcyBhbHJlYWR5IGRpc3Bvc2VkLlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UgdG8gYmUgZGlzcGxheWVkLlxuICogQHBhcmFtIHtib29sZWFufSBjbGVhblJlZmVyZW5jZXNBZnRlclJ1biB0aGUgdmFsdWUgb2YgYGNsZWFuUmVmZXJlbmNlc0FmdGVyUnVuYFxuICogQHBhcmFtIHtNb2NoYX0gaW5zdGFuY2UgdGhlIG1vY2hhIGluc3RhbmNlIHRoYXQgdGhyb3cgdGhpcyBlcnJvclxuICogQHN0YXRpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVNb2NoYUluc3RhbmNlQWxyZWFkeURpc3Bvc2VkRXJyb3IoXG4gIG1lc3NhZ2UsXG4gIGNsZWFuUmVmZXJlbmNlc0FmdGVyUnVuLFxuICBpbnN0YW5jZVxuKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVyci5jb2RlID0gY29uc3RhbnRzLklOU1RBTkNFX0FMUkVBRFlfRElTUE9TRUQ7XG4gIGVyci5jbGVhblJlZmVyZW5jZXNBZnRlclJ1biA9IGNsZWFuUmVmZXJlbmNlc0FmdGVyUnVuO1xuICBlcnIuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgcmV0dXJuIGVycjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCB0byBiZSB0aHJvd24gd2hlbiBhIG1vY2hhIG9iamVjdCdzIGBydW5gIG1ldGhvZCBpcyBjYWxsZWQgd2hpbGUgYSB0ZXN0IHJ1biBpcyBpbiBwcm9ncmVzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZC5cbiAqIEBzdGF0aWNcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9jaGFJbnN0YW5jZUFscmVhZHlSdW5uaW5nRXJyb3IobWVzc2FnZSwgaW5zdGFuY2UpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyLmNvZGUgPSBjb25zdGFudHMuSU5TVEFOQ0VfQUxSRUFEWV9SVU5OSU5HO1xuICBlcnIuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgcmV0dXJuIGVycjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCB0byBiZSB0aHJvd24gd2hlbiBkb25lKCkgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluIGEgdGVzdFxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7UnVubmFibGV9IHJ1bm5hYmxlIC0gT3JpZ2luYWwgcnVubmFibGVcbiAqIEBwYXJhbSB7RXJyb3J9IFtvcmlnaW5hbEVycl0gLSBPcmlnaW5hbCBlcnJvciwgaWYgYW55XG4gKiBAcmV0dXJucyB7RXJyb3J9IGluc3RhbmNlIGRldGFpbGluZyB0aGUgZXJyb3IgY29uZGl0aW9uXG4gKiBAc3RhdGljXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU11bHRpcGxlRG9uZUVycm9yKHJ1bm5hYmxlLCBvcmlnaW5hbEVycikge1xuICB2YXIgdGl0bGU7XG4gIHRyeSB7XG4gICAgdGl0bGUgPSBmb3JtYXQoJzwlcz4nLCBydW5uYWJsZS5mdWxsVGl0bGUoKSk7XG4gICAgaWYgKHJ1bm5hYmxlLnBhcmVudC5yb290KSB7XG4gICAgICB0aXRsZSArPSAnIChvZiByb290IHN1aXRlKSc7XG4gICAgfVxuICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgdGl0bGUgPSBmb3JtYXQoJzwlcz4gKG9mIHVua25vd24gc3VpdGUpJywgcnVubmFibGUudGl0bGUpO1xuICB9XG4gIHZhciBtZXNzYWdlID0gZm9ybWF0KFxuICAgICdkb25lKCkgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluICVzICVzJyxcbiAgICBydW5uYWJsZS50eXBlID8gcnVubmFibGUudHlwZSA6ICd1bmtub3duIHJ1bm5hYmxlJyxcbiAgICB0aXRsZVxuICApO1xuICBpZiAocnVubmFibGUuZmlsZSkge1xuICAgIG1lc3NhZ2UgKz0gZm9ybWF0KCcgb2YgZmlsZSAlcycsIHJ1bm5hYmxlLmZpbGUpO1xuICB9XG4gIGlmIChvcmlnaW5hbEVycikge1xuICAgIG1lc3NhZ2UgKz0gZm9ybWF0KCc7IGluIGFkZGl0aW9uLCBkb25lKCkgcmVjZWl2ZWQgZXJyb3I6ICVzJywgb3JpZ2luYWxFcnIpO1xuICB9XG5cbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyLmNvZGUgPSBjb25zdGFudHMuTVVMVElQTEVfRE9ORTtcbiAgZXJyLnZhbHVlVHlwZSA9IHR5cGVvZiBvcmlnaW5hbEVycjtcbiAgZXJyLnZhbHVlID0gb3JpZ2luYWxFcnI7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gYC5vbmx5KClgIGlzIHVzZWQgd2l0aFxuICogYC0tZm9yYmlkLW9ubHlgLlxuICogQHN0YXRpY1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtNb2NoYX0gbW9jaGEgLSBNb2NoYSBpbnN0YW5jZVxuICogQHJldHVybnMge0Vycm9yfSBFcnJvciB3aXRoIGNvZGUge0BsaW5rIGNvbnN0YW50cy5GT1JCSURERU5fRVhDTFVTSVZJVFl9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZvcmJpZGRlbkV4Y2x1c2l2aXR5RXJyb3IobW9jaGEpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICBtb2NoYS5pc1dvcmtlclxuICAgICAgPyAnYC5vbmx5YCBpcyBub3Qgc3VwcG9ydGVkIGluIHBhcmFsbGVsIG1vZGUnXG4gICAgICA6ICdgLm9ubHlgIGZvcmJpZGRlbiBieSAtLWZvcmJpZC1vbmx5J1xuICApO1xuICBlcnIuY29kZSA9IGNvbnN0YW50cy5GT1JCSURERU5fRVhDTFVTSVZJVFk7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gYSBwbHVnaW4gZGVmaW5pdGlvbiBpcyBpbnZhbGlkXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnIC0gRXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHtQbHVnaW5EZWZpbml0aW9ufSBbcGx1Z2luRGVmXSAtIFByb2JsZW1hdGljIHBsdWdpbiBkZWZpbml0aW9uXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyB7RXJyb3J9IEVycm9yIHdpdGggY29kZSB7QGxpbmsgY29uc3RhbnRzLklOVkFMSURfUExVR0lOX0RFRklOSVRJT059XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWRQbHVnaW5EZWZpbml0aW9uRXJyb3IobXNnLCBwbHVnaW5EZWYpIHtcbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5jb2RlID0gY29uc3RhbnRzLklOVkFMSURfUExVR0lOX0RFRklOSVRJT047XG4gIGVyci5wbHVnaW5EZWYgPSBwbHVnaW5EZWY7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gYSBwbHVnaW4gaW1wbGVtZW50YXRpb24gKHVzZXIgY29kZSkgaXMgaW52YWxpZFxuICogQHN0YXRpY1xuICogQHBhcmFtIHtzdHJpbmd9IG1zZyAtIEVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBQbHVnaW4gZGVmaW5pdGlvbiBhbmQgdXNlci1zdXBwbGllZCBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtQbHVnaW5EZWZpbml0aW9ufSBbb3B0cy5wbHVnaW5EZWZdIC0gUGx1Z2luIERlZmluaXRpb25cbiAqIEBwYXJhbSB7Kn0gW29wdHMucGx1Z2luSW1wbF0gLSBQbHVnaW4gSW1wbGVtZW50YXRpb24gKHVzZXItc3VwcGxpZWQpXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyB7RXJyb3J9IEVycm9yIHdpdGggY29kZSB7QGxpbmsgY29uc3RhbnRzLklOVkFMSURfUExVR0lOX0RFRklOSVRJT059XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWRQbHVnaW5JbXBsZW1lbnRhdGlvbkVycm9yKFxuICBtc2csXG4gIHtwbHVnaW5EZWYsIHBsdWdpbkltcGx9ID0ge31cbikge1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLmNvZGUgPSBjb25zdGFudHMuSU5WQUxJRF9QTFVHSU5fSU1QTEVNRU5UQVRJT047XG4gIGVyci5wbHVnaW5EZWYgPSBwbHVnaW5EZWY7XG4gIGVyci5wbHVnaW5JbXBsID0gcGx1Z2luSW1wbDtcbiAgcmV0dXJuIGVycjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCB0byBiZSB0aHJvd24gd2hlbiBhIHJ1bm5hYmxlIGV4Y2VlZHMgaXRzIGFsbG93ZWQgcnVuIHRpbWUuXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnIC0gRXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0XSAtIFRpbWVvdXQgaW4gbXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZmlsZV0gLSBGaWxlLCBpZiBnaXZlblxuICogQHJldHVybnMge01vY2hhVGltZW91dEVycm9yfVxuICovXG5mdW5jdGlvbiBjcmVhdGVUaW1lb3V0RXJyb3IobXNnLCB0aW1lb3V0LCBmaWxlKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIuY29kZSA9IGNvbnN0YW50cy5USU1FT1VUO1xuICBlcnIudGltZW91dCA9IHRpbWVvdXQ7XG4gIGVyci5maWxlID0gZmlsZTtcbiAgcmV0dXJuIGVycjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCB0byBiZSB0aHJvd24gd2hlbiBmaWxlIGlzIHVucGFyc2FibGVcbiAqIEBwdWJsaWNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgLSBGaWxlIG5hbWVcbiAqIEByZXR1cm5zIHtFcnJvcn0gRXJyb3Igd2l0aCBjb2RlIHtAbGluayBjb25zdGFudHMuVU5QQVJTQUJMRV9GSUxFfVxuICovXG5mdW5jdGlvbiBjcmVhdGVVbnBhcnNhYmxlRmlsZUVycm9yKG1lc3NhZ2UsIGZpbGVuYW1lKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVyci5jb2RlID0gY29uc3RhbnRzLlVOUEFSU0FCTEVfRklMRTtcbiAgcmV0dXJuIGVycjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlcnJvciBjYW1lIG91dCBvZiBNb2NoYS5cbiAqIF9DYW4gc3VmZmVyIGZyb20gZmFsc2UgbmVnYXRpdmVzLCBidXQgbm90IGZhbHNlIHBvc2l0aXZlcy5fXG4gKiBAc3RhdGljXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IGVyciAtIEVycm9yLCBvciBhbnl0aGluZ1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzTW9jaGFFcnJvciA9IGVyciA9PlxuICBCb29sZWFuKGVyciAmJiB0eXBlb2YgZXJyID09PSAnb2JqZWN0JyAmJiBNT0NIQV9FUlJPUlMuaGFzKGVyci5jb2RlKSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb25zdGFudHMsXG4gIGNyZWF0ZUZhdGFsRXJyb3IsXG4gIGNyZWF0ZUZvcmJpZGRlbkV4Y2x1c2l2aXR5RXJyb3IsXG4gIGNyZWF0ZUludmFsaWRBcmd1bWVudFR5cGVFcnJvcixcbiAgY3JlYXRlSW52YWxpZEFyZ3VtZW50VmFsdWVFcnJvcixcbiAgY3JlYXRlSW52YWxpZEV4Y2VwdGlvbkVycm9yLFxuICBjcmVhdGVJbnZhbGlkSW50ZXJmYWNlRXJyb3IsXG4gIGNyZWF0ZUludmFsaWRMZWdhY3lQbHVnaW5FcnJvcixcbiAgY3JlYXRlSW52YWxpZFBsdWdpbkRlZmluaXRpb25FcnJvcixcbiAgY3JlYXRlSW52YWxpZFBsdWdpbkVycm9yLFxuICBjcmVhdGVJbnZhbGlkUGx1Z2luSW1wbGVtZW50YXRpb25FcnJvcixcbiAgY3JlYXRlSW52YWxpZFJlcG9ydGVyRXJyb3IsXG4gIGNyZWF0ZU1pc3NpbmdBcmd1bWVudEVycm9yLFxuICBjcmVhdGVNb2NoYUluc3RhbmNlQWxyZWFkeURpc3Bvc2VkRXJyb3IsXG4gIGNyZWF0ZU1vY2hhSW5zdGFuY2VBbHJlYWR5UnVubmluZ0Vycm9yLFxuICBjcmVhdGVNdWx0aXBsZURvbmVFcnJvcixcbiAgY3JlYXRlTm9GaWxlc01hdGNoUGF0dGVybkVycm9yLFxuICBjcmVhdGVUaW1lb3V0RXJyb3IsXG4gIGNyZWF0ZVVucGFyc2FibGVGaWxlRXJyb3IsXG4gIGNyZWF0ZVVuc3VwcG9ydGVkRXJyb3IsXG4gIGRlcHJlY2F0ZSxcbiAgaXNNb2NoYUVycm9yLFxuICB3YXJuXG59O1xuXG4vKipcbiAqIFRoZSBlcnJvciB0aHJvd24gd2hlbiBhIFJ1bm5hYmxlIHRpbWVzIG91dFxuICogQG1lbWJlcm9mIG1vZHVsZTpsaWIvZXJyb3JzXG4gKiBAdHlwZWRlZiB7RXJyb3J9IE1vY2hhVGltZW91dEVycm9yXG4gKiBAcHJvcGVydHkge2NvbnN0YW50cy5USU1FT1VUfSBjb2RlIC0gRXJyb3IgY29kZVxuICogQHByb3BlcnR5IHtudW1iZXI/fSB0aW1lb3V0IFRpbWVvdXQgaW4gbXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nP30gZmlsZSBGaWxlcGF0aCwgaWYgZ2l2ZW5cbiAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XG5jb25zdCB7aW5oZXJpdHMsIGNvbnN0YW50c30gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCB7TU9DSEFfSURfUFJPUF9OQU1FfSA9IGNvbnN0YW50cztcblxuLyoqXG4gKiBFeHBvc2UgYEhvb2tgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gSG9vaztcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBIb29rYCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBSdW5uYWJsZVxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBIb29rKHRpdGxlLCBmbikge1xuICBSdW5uYWJsZS5jYWxsKHRoaXMsIHRpdGxlLCBmbik7XG4gIHRoaXMudHlwZSA9ICdob29rJztcbn1cblxuLyoqXG4gKiBJbmhlcml0IGZyb20gYFJ1bm5hYmxlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKEhvb2ssIFJ1bm5hYmxlKTtcblxuLyoqXG4gKiBSZXNldHMgdGhlIHN0YXRlIGZvciBhIG5leHQgcnVuLlxuICovXG5Ib29rLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgUnVubmFibGUucHJvdG90eXBlLnJlc2V0LmNhbGwodGhpcyk7XG4gIGRlbGV0ZSB0aGlzLl9lcnJvcjtcbn07XG5cbi8qKlxuICogR2V0IG9yIHNldCB0aGUgdGVzdCBgZXJyYC5cbiAqXG4gKiBAbWVtYmVyb2YgSG9va1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqL1xuSG9vay5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGVyciA9IHRoaXMuX2Vycm9yO1xuICAgIHRoaXMuX2Vycm9yID0gbnVsbDtcbiAgICByZXR1cm4gZXJyO1xuICB9XG5cbiAgdGhpcy5fZXJyb3IgPSBlcnI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHN1aXRhYmxlIGZvciBJUEMuXG4gKiBGdW5jdGlvbnMgYXJlIHJlcHJlc2VudGVkIGJ5IGtleXMgYmVnaW5uaW5nIHdpdGggYCQkYC5cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5Ib29rLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gIHJldHVybiB7XG4gICAgJCRjdXJyZW50UmV0cnk6IHRoaXMuY3VycmVudFJldHJ5KCksXG4gICAgJCRmdWxsVGl0bGU6IHRoaXMuZnVsbFRpdGxlKCksXG4gICAgJCRpc1BlbmRpbmc6IEJvb2xlYW4odGhpcy5pc1BlbmRpbmcoKSksXG4gICAgJCR0aXRsZVBhdGg6IHRoaXMudGl0bGVQYXRoKCksXG4gICAgY3R4OlxuICAgICAgdGhpcy5jdHggJiYgdGhpcy5jdHguY3VycmVudFRlc3RcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBjdXJyZW50VGVzdDoge1xuICAgICAgICAgICAgICB0aXRsZTogdGhpcy5jdHguY3VycmVudFRlc3QudGl0bGUsXG4gICAgICAgICAgICAgIFtNT0NIQV9JRF9QUk9QX05BTUVdOiB0aGlzLmN0eC5jdXJyZW50VGVzdC5pZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgOiB7fSxcbiAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICBmaWxlOiB0aGlzLmZpbGUsXG4gICAgcGFyZW50OiB7XG4gICAgICAkJGZ1bGxUaXRsZTogdGhpcy5wYXJlbnQuZnVsbFRpdGxlKCksXG4gICAgICBbTU9DSEFfSURfUFJPUF9OQU1FXTogdGhpcy5wYXJlbnQuaWRcbiAgICB9LFxuICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgIHRpdGxlOiB0aGlzLnRpdGxlLFxuICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICBbTU9DSEFfSURfUFJPUF9OQU1FXTogdGhpcy5pZFxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRlc3QgPSByZXF1aXJlKCcuLi90ZXN0Jyk7XG52YXIgRVZFTlRfRklMRV9QUkVfUkVRVUlSRSA9XG4gIHJlcXVpcmUoJy4uL3N1aXRlJykuY29uc3RhbnRzLkVWRU5UX0ZJTEVfUFJFX1JFUVVJUkU7XG5cbi8qKlxuICogQkRELXN0eWxlIGludGVyZmFjZTpcbiAqXG4gKiAgICAgIGRlc2NyaWJlKCdBcnJheScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgIGRlc2NyaWJlKCcjaW5kZXhPZigpJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICBpdCgnc2hvdWxkIHJldHVybiAtMSB3aGVuIG5vdCBwcmVzZW50JywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgIC8vIC4uLlxuICogICAgICAgICAgfSk7XG4gKlxuICogICAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gdGhlIGluZGV4IHdoZW4gcHJlc2VudCcsIGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAvLyAuLi5cbiAqICAgICAgICAgIH0pO1xuICogICAgICAgIH0pO1xuICogICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBSb290IHN1aXRlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJkZEludGVyZmFjZShzdWl0ZSkge1xuICB2YXIgc3VpdGVzID0gW3N1aXRlXTtcblxuICBzdWl0ZS5vbihFVkVOVF9GSUxFX1BSRV9SRVFVSVJFLCBmdW5jdGlvbiAoY29udGV4dCwgZmlsZSwgbW9jaGEpIHtcbiAgICB2YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKShzdWl0ZXMsIGNvbnRleHQsIG1vY2hhKTtcblxuICAgIGNvbnRleHQuYmVmb3JlID0gY29tbW9uLmJlZm9yZTtcbiAgICBjb250ZXh0LmFmdGVyID0gY29tbW9uLmFmdGVyO1xuICAgIGNvbnRleHQuYmVmb3JlRWFjaCA9IGNvbW1vbi5iZWZvcmVFYWNoO1xuICAgIGNvbnRleHQuYWZ0ZXJFYWNoID0gY29tbW9uLmFmdGVyRWFjaDtcbiAgICBjb250ZXh0LnJ1biA9IG1vY2hhLm9wdGlvbnMuZGVsYXkgJiYgY29tbW9uLnJ1bldpdGhTdWl0ZShzdWl0ZSk7XG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgYSBcInN1aXRlXCIgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYFxuICAgICAqIGFuZCBjYWxsYmFjayBgZm5gIGNvbnRhaW5pbmcgbmVzdGVkIHN1aXRlc1xuICAgICAqIGFuZC9vciB0ZXN0cy5cbiAgICAgKi9cblxuICAgIGNvbnRleHQuZGVzY3JpYmUgPSBjb250ZXh0LmNvbnRleHQgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLmNyZWF0ZSh7XG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgZmlsZTogZmlsZSxcbiAgICAgICAgZm46IGZuXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVuZGluZyBkZXNjcmliZS5cbiAgICAgKi9cblxuICAgIGNvbnRleHQueGRlc2NyaWJlID1cbiAgICAgIGNvbnRleHQueGNvbnRleHQgPVxuICAgICAgY29udGV4dC5kZXNjcmliZS5za2lwID1cbiAgICAgICAgZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICAgICAgICAgIHJldHVybiBjb21tb24uc3VpdGUuc2tpcCh7XG4gICAgICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgICAgICBmaWxlOiBmaWxlLFxuICAgICAgICAgICAgZm46IGZuXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeGNsdXNpdmUgc3VpdGUuXG4gICAgICovXG5cbiAgICBjb250ZXh0LmRlc2NyaWJlLm9ubHkgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLm9ubHkoe1xuICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgIGZpbGU6IGZpbGUsXG4gICAgICAgIGZuOiBmblxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIGEgc3BlY2lmaWNhdGlvbiBvciB0ZXN0LWNhc2VcbiAgICAgKiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gXG4gICAgICogYWN0aW5nIGFzIGEgdGh1bmsuXG4gICAgICovXG5cbiAgICBjb250ZXh0Lml0ID0gY29udGV4dC5zcGVjaWZ5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICAgICAgdmFyIHN1aXRlID0gc3VpdGVzWzBdO1xuICAgICAgaWYgKHN1aXRlLmlzUGVuZGluZygpKSB7XG4gICAgICAgIGZuID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciB0ZXN0ID0gbmV3IFRlc3QodGl0bGUsIGZuKTtcbiAgICAgIHRlc3QuZmlsZSA9IGZpbGU7XG4gICAgICBzdWl0ZS5hZGRUZXN0KHRlc3QpO1xuICAgICAgcmV0dXJuIHRlc3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4Y2x1c2l2ZSB0ZXN0LWNhc2UuXG4gICAgICovXG5cbiAgICBjb250ZXh0Lml0Lm9ubHkgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gICAgICByZXR1cm4gY29tbW9uLnRlc3Qub25seShtb2NoYSwgY29udGV4dC5pdCh0aXRsZSwgZm4pKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVuZGluZyB0ZXN0IGNhc2UuXG4gICAgICovXG5cbiAgICBjb250ZXh0LnhpdCA9XG4gICAgICBjb250ZXh0LnhzcGVjaWZ5ID1cbiAgICAgIGNvbnRleHQuaXQuc2tpcCA9XG4gICAgICAgIGZ1bmN0aW9uICh0aXRsZSkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Lml0KHRpdGxlKTtcbiAgICAgICAgfTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5kZXNjcmlwdGlvbiA9ICdCREQgb3IgUlNwZWMgc3R5bGUgW2RlZmF1bHRdJztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gQG1vZHVsZSBpbnRlcmZhY2VzL2NvbW1vblxuKi9cblxudmFyIFN1aXRlID0gcmVxdWlyZSgnLi4vc3VpdGUnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbnZhciBjcmVhdGVNaXNzaW5nQXJndW1lbnRFcnJvciA9IGVycm9ycy5jcmVhdGVNaXNzaW5nQXJndW1lbnRFcnJvcjtcbnZhciBjcmVhdGVVbnN1cHBvcnRlZEVycm9yID0gZXJyb3JzLmNyZWF0ZVVuc3VwcG9ydGVkRXJyb3I7XG52YXIgY3JlYXRlRm9yYmlkZGVuRXhjbHVzaXZpdHlFcnJvciA9IGVycm9ycy5jcmVhdGVGb3JiaWRkZW5FeGNsdXNpdml0eUVycm9yO1xuXG4vKipcbiAqIEZ1bmN0aW9ucyBjb21tb24gdG8gbW9yZSB0aGFuIG9uZSBpbnRlcmZhY2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3VpdGVbXX0gc3VpdGVzXG4gKiBAcGFyYW0ge0NvbnRleHR9IGNvbnRleHRcbiAqIEBwYXJhbSB7TW9jaGF9IG1vY2hhXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIGNvbW1vbiBmdW5jdGlvbnMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN1aXRlcywgY29udGV4dCwgbW9jaGEpIHtcbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBzdWl0ZSBzaG91bGQgYmUgdGVzdGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSAtIHN1aXRlIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gc2hvdWxkQmVUZXN0ZWQoc3VpdGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIW1vY2hhLm9wdGlvbnMuZ3JlcCB8fFxuICAgICAgKG1vY2hhLm9wdGlvbnMuZ3JlcCAmJlxuICAgICAgICBtb2NoYS5vcHRpb25zLmdyZXAudGVzdChzdWl0ZS5mdWxsVGl0bGUoKSkgJiZcbiAgICAgICAgIW1vY2hhLm9wdGlvbnMuaW52ZXJ0KVxuICAgICk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgb25seSBwcmVzZW50IGlmIGZsYWcgLS1kZWxheSBpcyBwYXNzZWQgaW50byBNb2NoYS4gSXQgdHJpZ2dlcnNcbiAgICAgKiByb290IHN1aXRlIGV4ZWN1dGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFRoZSByb290IHN1aXRlLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHdoaWNoIHJ1bnMgdGhlIHJvb3Qgc3VpdGVcbiAgICAgKi9cbiAgICBydW5XaXRoU3VpdGU6IGZ1bmN0aW9uIHJ1bldpdGhTdWl0ZShzdWl0ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgICAgc3VpdGUucnVuKCk7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGJlZm9yZSBydW5uaW5nIHRlc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqL1xuICAgIGJlZm9yZTogZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgICBzdWl0ZXNbMF0uYmVmb3JlQWxsKG5hbWUsIGZuKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhZnRlciBydW5uaW5nIHRlc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqL1xuICAgIGFmdGVyOiBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICAgIHN1aXRlc1swXS5hZnRlckFsbChuYW1lLCBmbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYmVmb3JlIGVhY2ggdGVzdCBjYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqL1xuICAgIGJlZm9yZUVhY2g6IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgICAgc3VpdGVzWzBdLmJlZm9yZUVhY2gobmFtZSwgZm4pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGFmdGVyIGVhY2ggdGVzdCBjYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqL1xuICAgIGFmdGVyRWFjaDogZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgICBzdWl0ZXNbMF0uYWZ0ZXJFYWNoKG5hbWUsIGZuKTtcbiAgICB9LFxuXG4gICAgc3VpdGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIGFuIGV4Y2x1c2l2ZSBTdWl0ZTsgY29udmVuaWVuY2UgZnVuY3Rpb25cbiAgICAgICAqIFNlZSBkb2NzdHJpbmcgZm9yIGNyZWF0ZSgpIGJlbG93LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICAgKiBAcmV0dXJucyB7U3VpdGV9XG4gICAgICAgKi9cbiAgICAgIG9ubHk6IGZ1bmN0aW9uIG9ubHkob3B0cykge1xuICAgICAgICBpZiAobW9jaGEub3B0aW9ucy5mb3JiaWRPbmx5KSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlRm9yYmlkZGVuRXhjbHVzaXZpdHlFcnJvcihtb2NoYSk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0cy5pc09ubHkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUob3B0cyk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSBhIFN1aXRlLCBidXQgc2tpcCBpdDsgY29udmVuaWVuY2UgZnVuY3Rpb25cbiAgICAgICAqIFNlZSBkb2NzdHJpbmcgZm9yIGNyZWF0ZSgpIGJlbG93LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICAgKiBAcmV0dXJucyB7U3VpdGV9XG4gICAgICAgKi9cbiAgICAgIHNraXA6IGZ1bmN0aW9uIHNraXAob3B0cykge1xuICAgICAgICBvcHRzLnBlbmRpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUob3B0cyk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBzdWl0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25zXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy50aXRsZSBUaXRsZSBvZiBTdWl0ZVxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMuZm5dIFN1aXRlIEZ1bmN0aW9uIChub3QgYWx3YXlzIGFwcGxpY2FibGUpXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnBlbmRpbmddIElzIFN1aXRlIHBlbmRpbmc/XG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZmlsZV0gRmlsZXBhdGggd2hlcmUgdGhpcyBTdWl0ZSByZXNpZGVzXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmlzT25seV0gSXMgU3VpdGUgZXhjbHVzaXZlP1xuICAgICAgICogQHJldHVybnMge1N1aXRlfVxuICAgICAgICovXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShvcHRzKSB7XG4gICAgICAgIHZhciBzdWl0ZSA9IFN1aXRlLmNyZWF0ZShzdWl0ZXNbMF0sIG9wdHMudGl0bGUpO1xuICAgICAgICBzdWl0ZS5wZW5kaW5nID0gQm9vbGVhbihvcHRzLnBlbmRpbmcpO1xuICAgICAgICBzdWl0ZS5maWxlID0gb3B0cy5maWxlO1xuICAgICAgICBzdWl0ZXMudW5zaGlmdChzdWl0ZSk7XG4gICAgICAgIGlmIChvcHRzLmlzT25seSkge1xuICAgICAgICAgIHN1aXRlLm1hcmtPbmx5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHN1aXRlLnBlbmRpbmcgJiZcbiAgICAgICAgICBtb2NoYS5vcHRpb25zLmZvcmJpZFBlbmRpbmcgJiZcbiAgICAgICAgICBzaG91bGRCZVRlc3RlZChzdWl0ZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlVW5zdXBwb3J0ZWRFcnJvcignUGVuZGluZyB0ZXN0IGZvcmJpZGRlbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5mbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9wdHMuZm4uY2FsbChzdWl0ZSk7XG4gICAgICAgICAgc3VpdGVzLnNoaWZ0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuZm4gPT09ICd1bmRlZmluZWQnICYmICFzdWl0ZS5wZW5kaW5nKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlTWlzc2luZ0FyZ3VtZW50RXJyb3IoXG4gICAgICAgICAgICAnU3VpdGUgXCInICtcbiAgICAgICAgICAgICAgc3VpdGUuZnVsbFRpdGxlKCkgK1xuICAgICAgICAgICAgICAnXCIgd2FzIGRlZmluZWQgYnV0IG5vIGNhbGxiYWNrIHdhcyBzdXBwbGllZC4gJyArXG4gICAgICAgICAgICAgICdTdXBwbHkgYSBjYWxsYmFjayBvciBleHBsaWNpdGx5IHNraXAgdGhlIHN1aXRlLicsXG4gICAgICAgICAgICAnY2FsbGJhY2snLFxuICAgICAgICAgICAgJ2Z1bmN0aW9uJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdHMuZm4gJiYgc3VpdGUucGVuZGluZykge1xuICAgICAgICAgIHN1aXRlcy5zaGlmdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1aXRlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0ZXN0OiB7XG4gICAgICAvKipcbiAgICAgICAqIEV4Y2x1c2l2ZSB0ZXN0LWNhc2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vY2hhXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0ZXN0XG4gICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAqL1xuICAgICAgb25seTogZnVuY3Rpb24gKG1vY2hhLCB0ZXN0KSB7XG4gICAgICAgIGlmIChtb2NoYS5vcHRpb25zLmZvcmJpZE9ubHkpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVGb3JiaWRkZW5FeGNsdXNpdml0eUVycm9yKG1vY2hhKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXN0Lm1hcmtPbmx5KCk7XG4gICAgICAgIHJldHVybiB0ZXN0O1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQZW5kaW5nIHRlc3QgY2FzZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcbiAgICAgICAqL1xuICAgICAgc2tpcDogZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgICAgIGNvbnRleHQudGVzdCh0aXRsZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBTdWl0ZSA9IHJlcXVpcmUoJy4uL3N1aXRlJyk7XG52YXIgVGVzdCA9IHJlcXVpcmUoJy4uL3Rlc3QnKTtcblxuLyoqXG4gKiBFeHBvcnRzLXN0eWxlIChhcyBOb2RlLmpzIG1vZHVsZSkgaW50ZXJmYWNlOlxuICpcbiAqICAgICBleHBvcnRzLkFycmF5ID0ge1xuICogICAgICAgJyNpbmRleE9mKCknOiB7XG4gKiAgICAgICAgICdzaG91bGQgcmV0dXJuIC0xIHdoZW4gdGhlIHZhbHVlIGlzIG5vdCBwcmVzZW50JzogZnVuY3Rpb24oKSB7XG4gKlxuICogICAgICAgICB9LFxuICpcbiAqICAgICAgICAgJ3Nob3VsZCByZXR1cm4gdGhlIGNvcnJlY3QgaW5kZXggd2hlbiB0aGUgdmFsdWUgaXMgcHJlc2VudCc6IGZ1bmN0aW9uKCkge1xuICpcbiAqICAgICAgICAgfVxuICogICAgICAgfVxuICogICAgIH07XG4gKlxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgUm9vdCBzdWl0ZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3VpdGUpIHtcbiAgdmFyIHN1aXRlcyA9IFtzdWl0ZV07XG5cbiAgc3VpdGUub24oU3VpdGUuY29uc3RhbnRzLkVWRU5UX0ZJTEVfUkVRVUlSRSwgdmlzaXQpO1xuXG4gIGZ1bmN0aW9uIHZpc2l0KG9iaiwgZmlsZSkge1xuICAgIHZhciBzdWl0ZTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBmbiA9IG9ialtrZXldO1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2UgJ2JlZm9yZSc6XG4gICAgICAgICAgICBzdWl0ZXNbMF0uYmVmb3JlQWxsKGZuKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2FmdGVyJzpcbiAgICAgICAgICAgIHN1aXRlc1swXS5hZnRlckFsbChmbik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdiZWZvcmVFYWNoJzpcbiAgICAgICAgICAgIHN1aXRlc1swXS5iZWZvcmVFYWNoKGZuKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2FmdGVyRWFjaCc6XG4gICAgICAgICAgICBzdWl0ZXNbMF0uYWZ0ZXJFYWNoKGZuKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgdGVzdCA9IG5ldyBUZXN0KGtleSwgZm4pO1xuICAgICAgICAgICAgdGVzdC5maWxlID0gZmlsZTtcbiAgICAgICAgICAgIHN1aXRlc1swXS5hZGRUZXN0KHRlc3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWl0ZSA9IFN1aXRlLmNyZWF0ZShzdWl0ZXNbMF0sIGtleSk7XG4gICAgICAgIHN1aXRlcy51bnNoaWZ0KHN1aXRlKTtcbiAgICAgICAgdmlzaXQob2JqW2tleV0sIGZpbGUpO1xuICAgICAgICBzdWl0ZXMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmRlc2NyaXB0aW9uID0gJ05vZGUuanMgbW9kdWxlIChcImV4cG9ydHNcIikgc3R5bGUnO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmJkZCA9IHJlcXVpcmUoJy4vYmRkJyk7XG5leHBvcnRzLnRkZCA9IHJlcXVpcmUoJy4vdGRkJyk7XG5leHBvcnRzLnF1bml0ID0gcmVxdWlyZSgnLi9xdW5pdCcpO1xuZXhwb3J0cy5leHBvcnRzID0gcmVxdWlyZSgnLi9leHBvcnRzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUZXN0ID0gcmVxdWlyZSgnLi4vdGVzdCcpO1xudmFyIEVWRU5UX0ZJTEVfUFJFX1JFUVVJUkUgPVxuICByZXF1aXJlKCcuLi9zdWl0ZScpLmNvbnN0YW50cy5FVkVOVF9GSUxFX1BSRV9SRVFVSVJFO1xuXG4vKipcbiAqIFFVbml0LXN0eWxlIGludGVyZmFjZTpcbiAqXG4gKiAgICAgc3VpdGUoJ0FycmF5Jyk7XG4gKlxuICogICAgIHRlc3QoJyNsZW5ndGgnLCBmdW5jdGlvbigpIHtcbiAqICAgICAgIHZhciBhcnIgPSBbMSwyLDNdO1xuICogICAgICAgb2soYXJyLmxlbmd0aCA9PSAzKTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgdGVzdCgnI2luZGV4T2YoKScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgdmFyIGFyciA9IFsxLDIsM107XG4gKiAgICAgICBvayhhcnIuaW5kZXhPZigxKSA9PSAwKTtcbiAqICAgICAgIG9rKGFyci5pbmRleE9mKDIpID09IDEpO1xuICogICAgICAgb2soYXJyLmluZGV4T2YoMykgPT0gMik7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIHN1aXRlKCdTdHJpbmcnKTtcbiAqXG4gKiAgICAgdGVzdCgnI2xlbmd0aCcsIGZ1bmN0aW9uKCkge1xuICogICAgICAgb2soJ2ZvbycubGVuZ3RoID09IDMpO1xuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFJvb3Qgc3VpdGUuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcVVuaXRJbnRlcmZhY2Uoc3VpdGUpIHtcbiAgdmFyIHN1aXRlcyA9IFtzdWl0ZV07XG5cbiAgc3VpdGUub24oRVZFTlRfRklMRV9QUkVfUkVRVUlSRSwgZnVuY3Rpb24gKGNvbnRleHQsIGZpbGUsIG1vY2hhKSB7XG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJykoc3VpdGVzLCBjb250ZXh0LCBtb2NoYSk7XG5cbiAgICBjb250ZXh0LmJlZm9yZSA9IGNvbW1vbi5iZWZvcmU7XG4gICAgY29udGV4dC5hZnRlciA9IGNvbW1vbi5hZnRlcjtcbiAgICBjb250ZXh0LmJlZm9yZUVhY2ggPSBjb21tb24uYmVmb3JlRWFjaDtcbiAgICBjb250ZXh0LmFmdGVyRWFjaCA9IGNvbW1vbi5hZnRlckVhY2g7XG4gICAgY29udGV4dC5ydW4gPSBtb2NoYS5vcHRpb25zLmRlbGF5ICYmIGNvbW1vbi5ydW5XaXRoU3VpdGUoc3VpdGUpO1xuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIGEgXCJzdWl0ZVwiIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAuXG4gICAgICovXG5cbiAgICBjb250ZXh0LnN1aXRlID0gZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgICBpZiAoc3VpdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc3VpdGVzLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLmNyZWF0ZSh7XG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgZmlsZTogZmlsZSxcbiAgICAgICAgZm46IGZhbHNlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhjbHVzaXZlIFN1aXRlLlxuICAgICAqL1xuXG4gICAgY29udGV4dC5zdWl0ZS5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgICBpZiAoc3VpdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc3VpdGVzLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLm9ubHkoe1xuICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgIGZpbGU6IGZpbGUsXG4gICAgICAgIGZuOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIGEgc3BlY2lmaWNhdGlvbiBvciB0ZXN0LWNhc2VcbiAgICAgKiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gXG4gICAgICogYWN0aW5nIGFzIGEgdGh1bmsuXG4gICAgICovXG5cbiAgICBjb250ZXh0LnRlc3QgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gICAgICB2YXIgdGVzdCA9IG5ldyBUZXN0KHRpdGxlLCBmbik7XG4gICAgICB0ZXN0LmZpbGUgPSBmaWxlO1xuICAgICAgc3VpdGVzWzBdLmFkZFRlc3QodGVzdCk7XG4gICAgICByZXR1cm4gdGVzdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhjbHVzaXZlIHRlc3QtY2FzZS5cbiAgICAgKi9cblxuICAgIGNvbnRleHQudGVzdC5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICAgICAgcmV0dXJuIGNvbW1vbi50ZXN0Lm9ubHkobW9jaGEsIGNvbnRleHQudGVzdCh0aXRsZSwgZm4pKTtcbiAgICB9O1xuXG4gICAgY29udGV4dC50ZXN0LnNraXAgPSBjb21tb24udGVzdC5za2lwO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmRlc2NyaXB0aW9uID0gJ1FVbml0IHN0eWxlJztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRlc3QgPSByZXF1aXJlKCcuLi90ZXN0Jyk7XG52YXIgRVZFTlRfRklMRV9QUkVfUkVRVUlSRSA9XG4gIHJlcXVpcmUoJy4uL3N1aXRlJykuY29uc3RhbnRzLkVWRU5UX0ZJTEVfUFJFX1JFUVVJUkU7XG5cbi8qKlxuICogVERELXN0eWxlIGludGVyZmFjZTpcbiAqXG4gKiAgICAgIHN1aXRlKCdBcnJheScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgIHN1aXRlKCcjaW5kZXhPZigpJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICBzdWl0ZVNldHVwKGZ1bmN0aW9uKCkge1xuICpcbiAqICAgICAgICAgIH0pO1xuICpcbiAqICAgICAgICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gLTEgd2hlbiBub3QgcHJlc2VudCcsIGZ1bmN0aW9uKCkge1xuICpcbiAqICAgICAgICAgIH0pO1xuICpcbiAqICAgICAgICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdGhlIGluZGV4IHdoZW4gcHJlc2VudCcsIGZ1bmN0aW9uKCkge1xuICpcbiAqICAgICAgICAgIH0pO1xuICpcbiAqICAgICAgICAgIHN1aXRlVGVhcmRvd24oZnVuY3Rpb24oKSB7XG4gKlxuICogICAgICAgICAgfSk7XG4gKiAgICAgICAgfSk7XG4gKiAgICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFJvb3Qgc3VpdGUuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN1aXRlKSB7XG4gIHZhciBzdWl0ZXMgPSBbc3VpdGVdO1xuXG4gIHN1aXRlLm9uKEVWRU5UX0ZJTEVfUFJFX1JFUVVJUkUsIGZ1bmN0aW9uIChjb250ZXh0LCBmaWxlLCBtb2NoYSkge1xuICAgIHZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpKHN1aXRlcywgY29udGV4dCwgbW9jaGEpO1xuXG4gICAgY29udGV4dC5zZXR1cCA9IGNvbW1vbi5iZWZvcmVFYWNoO1xuICAgIGNvbnRleHQudGVhcmRvd24gPSBjb21tb24uYWZ0ZXJFYWNoO1xuICAgIGNvbnRleHQuc3VpdGVTZXR1cCA9IGNvbW1vbi5iZWZvcmU7XG4gICAgY29udGV4dC5zdWl0ZVRlYXJkb3duID0gY29tbW9uLmFmdGVyO1xuICAgIGNvbnRleHQucnVuID0gbW9jaGEub3B0aW9ucy5kZWxheSAmJiBjb21tb24ucnVuV2l0aFN1aXRlKHN1aXRlKTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIGEgXCJzdWl0ZVwiIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmAgY29udGFpbmluZ1xuICAgICAqIG5lc3RlZCBzdWl0ZXMgYW5kL29yIHRlc3RzLlxuICAgICAqL1xuICAgIGNvbnRleHQuc3VpdGUgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLmNyZWF0ZSh7XG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgZmlsZTogZmlsZSxcbiAgICAgICAgZm46IGZuXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVuZGluZyBzdWl0ZS5cbiAgICAgKi9cbiAgICBjb250ZXh0LnN1aXRlLnNraXAgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLnNraXAoe1xuICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgIGZpbGU6IGZpbGUsXG4gICAgICAgIGZuOiBmblxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4Y2x1c2l2ZSB0ZXN0LWNhc2UuXG4gICAgICovXG4gICAgY29udGV4dC5zdWl0ZS5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5vbmx5KHtcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICBmaWxlOiBmaWxlLFxuICAgICAgICBmbjogZm5cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSBhIHNwZWNpZmljYXRpb24gb3IgdGVzdC1jYXNlIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kXG4gICAgICogY2FsbGJhY2sgYGZuYCBhY3RpbmcgYXMgYSB0aHVuay5cbiAgICAgKi9cbiAgICBjb250ZXh0LnRlc3QgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gICAgICB2YXIgc3VpdGUgPSBzdWl0ZXNbMF07XG4gICAgICBpZiAoc3VpdGUuaXNQZW5kaW5nKCkpIHtcbiAgICAgICAgZm4gPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHRlc3QgPSBuZXcgVGVzdCh0aXRsZSwgZm4pO1xuICAgICAgdGVzdC5maWxlID0gZmlsZTtcbiAgICAgIHN1aXRlLmFkZFRlc3QodGVzdCk7XG4gICAgICByZXR1cm4gdGVzdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhjbHVzaXZlIHRlc3QtY2FzZS5cbiAgICAgKi9cblxuICAgIGNvbnRleHQudGVzdC5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICAgICAgcmV0dXJuIGNvbW1vbi50ZXN0Lm9ubHkobW9jaGEsIGNvbnRleHQudGVzdCh0aXRsZSwgZm4pKTtcbiAgICB9O1xuXG4gICAgY29udGV4dC50ZXN0LnNraXAgPSBjb21tb24udGVzdC5za2lwO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmRlc2NyaXB0aW9uID1cbiAgJ3RyYWRpdGlvbmFsIFwic3VpdGVcIi9cInRlc3RcIiBpbnN0ZWFkIG9mIEJERFxcJ3MgXCJkZXNjcmliZVwiL1wiaXRcIic7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogbW9jaGFcbiAqIENvcHlyaWdodChjKSAyMDExIFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgZXNjYXBlUmUgPSByZXF1aXJlKCdlc2NhcGUtc3RyaW5nLXJlZ2V4cCcpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgYnVpbHRpblJlcG9ydGVycyA9IHJlcXVpcmUoJy4vcmVwb3J0ZXJzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbW9jaGFyYyA9IHJlcXVpcmUoJy4vbW9jaGFyYy5qc29uJyk7XG52YXIgU3VpdGUgPSByZXF1aXJlKCcuL3N1aXRlJyk7XG52YXIgZXNtVXRpbHMgPSByZXF1aXJlKCcuL25vZGVqcy9lc20tdXRpbHMnKTtcbnZhciBjcmVhdGVTdGF0c0NvbGxlY3RvciA9IHJlcXVpcmUoJy4vc3RhdHMtY29sbGVjdG9yJyk7XG5jb25zdCB7XG4gIGNyZWF0ZUludmFsaWRSZXBvcnRlckVycm9yLFxuICBjcmVhdGVJbnZhbGlkSW50ZXJmYWNlRXJyb3IsXG4gIGNyZWF0ZU1vY2hhSW5zdGFuY2VBbHJlYWR5RGlzcG9zZWRFcnJvcixcbiAgY3JlYXRlTW9jaGFJbnN0YW5jZUFscmVhZHlSdW5uaW5nRXJyb3IsXG4gIGNyZWF0ZVVuc3VwcG9ydGVkRXJyb3Jcbn0gPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3Qge0VWRU5UX0ZJTEVfUFJFX1JFUVVJUkUsIEVWRU5UX0ZJTEVfUE9TVF9SRVFVSVJFLCBFVkVOVF9GSUxFX1JFUVVJUkV9ID1cbiAgU3VpdGUuY29uc3RhbnRzO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6bW9jaGEnKTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTW9jaGE7XG5cbi8qKlxuICogQSBNb2NoYSBpbnN0YW5jZSBpcyBhIGZpbml0ZSBzdGF0ZSBtYWNoaW5lLlxuICogVGhlc2UgYXJlIHRoZSBzdGF0ZXMgaXQgY2FuIGJlIGluLlxuICogQHByaXZhdGVcbiAqL1xudmFyIG1vY2hhU3RhdGVzID0gdXRpbHMuZGVmaW5lQ29uc3RhbnRzKHtcbiAgLyoqXG4gICAqIEluaXRpYWwgc3RhdGUgb2YgdGhlIG1vY2hhIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJTklUOiAnaW5pdCcsXG4gIC8qKlxuICAgKiBNb2NoYSBpbnN0YW5jZSBpcyBydW5uaW5nIHRlc3RzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBSVU5OSU5HOiAncnVubmluZycsXG4gIC8qKlxuICAgKiBNb2NoYSBpbnN0YW5jZSBpcyBkb25lIHJ1bm5pbmcgdGVzdHMgYW5kIHJlZmVyZW5jZXMgdG8gdGVzdCBmdW5jdGlvbnMgYW5kIGhvb2tzIGFyZSBjbGVhbmVkLlxuICAgKiBZb3UgY2FuIHJlc2V0IHRoaXMgc3RhdGUgYnkgdW5sb2FkaW5nIHRoZSB0ZXN0IGZpbGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUkVGRVJFTkNFU19DTEVBTkVEOiAncmVmZXJlbmNlc0NsZWFuZWQnLFxuICAvKipcbiAgICogTW9jaGEgaW5zdGFuY2UgaXMgZGlzcG9zZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERJU1BPU0VEOiAnZGlzcG9zZWQnXG59KTtcblxuLyoqXG4gKiBUbyByZXF1aXJlIGxvY2FsIFVJcyBhbmQgcmVwb3J0ZXJzIHdoZW4gcnVubmluZyBpbiBub2RlLlxuICovXG5cbmlmICghdXRpbHMuaXNCcm93c2VyKCkgJiYgdHlwZW9mIG1vZHVsZS5wYXRocyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIGN3ZCA9IHV0aWxzLmN3ZCgpO1xuICBtb2R1bGUucGF0aHMucHVzaChjd2QsIHBhdGguam9pbihjd2QsICdub2RlX21vZHVsZXMnKSk7XG59XG5cbi8qKlxuICogRXhwb3NlIGludGVybmFscy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy51dGlscyA9IHV0aWxzO1xuZXhwb3J0cy5pbnRlcmZhY2VzID0gcmVxdWlyZSgnLi9pbnRlcmZhY2VzJyk7XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBtZW1iZXJvZiBNb2NoYVxuICovXG5leHBvcnRzLnJlcG9ydGVycyA9IGJ1aWx0aW5SZXBvcnRlcnM7XG5leHBvcnRzLlJ1bm5hYmxlID0gcmVxdWlyZSgnLi9ydW5uYWJsZScpO1xuZXhwb3J0cy5Db250ZXh0ID0gcmVxdWlyZSgnLi9jb250ZXh0Jyk7XG4vKipcbiAqXG4gKiBAbWVtYmVyb2YgTW9jaGFcbiAqL1xuZXhwb3J0cy5SdW5uZXIgPSByZXF1aXJlKCcuL3J1bm5lcicpO1xuZXhwb3J0cy5TdWl0ZSA9IFN1aXRlO1xuZXhwb3J0cy5Ib29rID0gcmVxdWlyZSgnLi9ob29rJyk7XG5leHBvcnRzLlRlc3QgPSByZXF1aXJlKCcuL3Rlc3QnKTtcblxubGV0IGN1cnJlbnRDb250ZXh0O1xuZXhwb3J0cy5hZnRlckVhY2ggPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICByZXR1cm4gKGN1cnJlbnRDb250ZXh0LmFmdGVyRWFjaCB8fCBjdXJyZW50Q29udGV4dC50ZWFyZG93bikuYXBwbHkoXG4gICAgdGhpcyxcbiAgICBhcmdzXG4gICk7XG59O1xuZXhwb3J0cy5hZnRlciA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIHJldHVybiAoY3VycmVudENvbnRleHQuYWZ0ZXIgfHwgY3VycmVudENvbnRleHQuc3VpdGVUZWFyZG93bikuYXBwbHkoXG4gICAgdGhpcyxcbiAgICBhcmdzXG4gICk7XG59O1xuZXhwb3J0cy5iZWZvcmVFYWNoID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIChjdXJyZW50Q29udGV4dC5iZWZvcmVFYWNoIHx8IGN1cnJlbnRDb250ZXh0LnNldHVwKS5hcHBseSh0aGlzLCBhcmdzKTtcbn07XG5leHBvcnRzLmJlZm9yZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIHJldHVybiAoY3VycmVudENvbnRleHQuYmVmb3JlIHx8IGN1cnJlbnRDb250ZXh0LnN1aXRlU2V0dXApLmFwcGx5KHRoaXMsIGFyZ3MpO1xufTtcbmV4cG9ydHMuZGVzY3JpYmUgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICByZXR1cm4gKGN1cnJlbnRDb250ZXh0LmRlc2NyaWJlIHx8IGN1cnJlbnRDb250ZXh0LnN1aXRlKS5hcHBseSh0aGlzLCBhcmdzKTtcbn07XG5leHBvcnRzLmRlc2NyaWJlLm9ubHkgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICByZXR1cm4gKGN1cnJlbnRDb250ZXh0LmRlc2NyaWJlIHx8IGN1cnJlbnRDb250ZXh0LnN1aXRlKS5vbmx5LmFwcGx5KFxuICAgIHRoaXMsXG4gICAgYXJnc1xuICApO1xufTtcbmV4cG9ydHMuZGVzY3JpYmUuc2tpcCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIHJldHVybiAoY3VycmVudENvbnRleHQuZGVzY3JpYmUgfHwgY3VycmVudENvbnRleHQuc3VpdGUpLnNraXAuYXBwbHkoXG4gICAgdGhpcyxcbiAgICBhcmdzXG4gICk7XG59O1xuZXhwb3J0cy5pdCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIHJldHVybiAoY3VycmVudENvbnRleHQuaXQgfHwgY3VycmVudENvbnRleHQudGVzdCkuYXBwbHkodGhpcywgYXJncyk7XG59O1xuZXhwb3J0cy5pdC5vbmx5ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIChjdXJyZW50Q29udGV4dC5pdCB8fCBjdXJyZW50Q29udGV4dC50ZXN0KS5vbmx5LmFwcGx5KHRoaXMsIGFyZ3MpO1xufTtcbmV4cG9ydHMuaXQuc2tpcCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIHJldHVybiAoY3VycmVudENvbnRleHQuaXQgfHwgY3VycmVudENvbnRleHQudGVzdCkuc2tpcC5hcHBseSh0aGlzLCBhcmdzKTtcbn07XG5leHBvcnRzLnhkZXNjcmliZSA9IGV4cG9ydHMuZGVzY3JpYmUuc2tpcDtcbmV4cG9ydHMueGl0ID0gZXhwb3J0cy5pdC5za2lwO1xuZXhwb3J0cy5zZXR1cCA9IGV4cG9ydHMuYmVmb3JlRWFjaDtcbmV4cG9ydHMuc3VpdGVTZXR1cCA9IGV4cG9ydHMuYmVmb3JlO1xuZXhwb3J0cy5zdWl0ZVRlYXJkb3duID0gZXhwb3J0cy5hZnRlcjtcbmV4cG9ydHMuc3VpdGUgPSBleHBvcnRzLmRlc2NyaWJlO1xuZXhwb3J0cy50ZWFyZG93biA9IGV4cG9ydHMuYWZ0ZXJFYWNoO1xuZXhwb3J0cy50ZXN0ID0gZXhwb3J0cy5pdDtcbmV4cG9ydHMucnVuID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGN1cnJlbnRDb250ZXh0LnJ1bi5hcHBseSh0aGlzLCBhcmdzKTtcbn07XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBNb2NoYSBpbnN0YW5jZSB3aXRoIGBvcHRpb25zYC5cbiAqXG4gKiBAcHVibGljXG4gKiBAY2xhc3MgTW9jaGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBTZXR0aW5ncyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFsbG93VW5jYXVnaHRdIC0gUHJvcGFnYXRlIHVuY2F1Z2h0IGVycm9ycz9cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXN5bmNPbmx5XSAtIEZvcmNlIGBkb25lYCBjYWxsYmFjayBvciBwcm9taXNlP1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iYWlsXSAtIEJhaWwgYWZ0ZXIgZmlyc3QgdGVzdCBmYWlsdXJlP1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0xlYWtzXSAtIENoZWNrIGZvciBnbG9iYWwgdmFyaWFibGUgbGVha3M/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbG9yXSAtIENvbG9yIFRUWSBvdXRwdXQgZnJvbSByZXBvcnRlcj9cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVsYXldIC0gRGVsYXkgcm9vdCBzdWl0ZSBleGVjdXRpb24/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRpZmZdIC0gU2hvdyBkaWZmIG9uIGZhaWx1cmU/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRyeVJ1bl0gLSBSZXBvcnQgdGVzdHMgd2l0aG91dCBydW5uaW5nIHRoZW0/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZhaWxaZXJvXSAtIEZhaWwgdGVzdCBydW4gaWYgemVybyB0ZXN0cz9cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mZ3JlcF0gLSBUZXN0IGZpbHRlciBnaXZlbiBzdHJpbmcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvcmJpZE9ubHldIC0gVGVzdHMgbWFya2VkIGBvbmx5YCBmYWlsIHRoZSBzdWl0ZT9cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZm9yYmlkUGVuZGluZ10gLSBQZW5kaW5nIHRlc3RzIGZhaWwgdGhlIHN1aXRlP1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mdWxsVHJhY2VdIC0gRnVsbCBzdGFja3RyYWNlIHVwb24gZmFpbHVyZT9cbiAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zLmdsb2JhbF0gLSBWYXJpYWJsZXMgZXhwZWN0ZWQgaW4gZ2xvYmFsIHNjb3BlLlxuICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbb3B0aW9ucy5ncmVwXSAtIFRlc3QgZmlsdGVyIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaW5saW5lRGlmZnNdIC0gRGlzcGxheSBpbmxpbmUgZGlmZnM/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmludmVydF0gLSBJbnZlcnQgdGVzdCBmaWx0ZXIgbWF0Y2hlcz9cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubm9IaWdobGlnaHRpbmddIC0gRGlzYWJsZSBzeW50YXggaGlnaGxpZ2h0aW5nP1xuICogQHBhcmFtIHtzdHJpbmd8Y29uc3RydWN0b3J9IFtvcHRpb25zLnJlcG9ydGVyXSAtIFJlcG9ydGVyIG5hbWUgb3IgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucmVwb3J0ZXJPcHRpb25dIC0gUmVwb3J0ZXIgc2V0dGluZ3Mgb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJldHJpZXNdIC0gTnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IGZhaWxlZCB0ZXN0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zbG93XSAtIFNsb3cgdGhyZXNob2xkIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0aW9ucy50aW1lb3V0XSAtIFRpbWVvdXQgdGhyZXNob2xkIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnVpXSAtIEludGVyZmFjZSBuYW1lLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wYXJhbGxlbF0gLSBSdW4gam9icyBpbiBwYXJhbGxlbC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5qb2JzXSAtIE1heCBudW1iZXIgb2Ygd29ya2VyIHByb2Nlc3NlcyBmb3IgcGFyYWxsZWwgcnVucy5cbiAqIEBwYXJhbSB7TW9jaGFSb290SG9va09iamVjdH0gW29wdGlvbnMucm9vdEhvb2tzXSAtIEhvb2tzIHRvIGJvb3RzdHJhcCB0aGUgcm9vdCBzdWl0ZSB3aXRoLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gW29wdGlvbnMucmVxdWlyZV0gLSBQYXRobmFtZSBvZiBgcm9vdEhvb2tzYCBwbHVnaW4gZm9yIHBhcmFsbGVsIHJ1bnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzV29ya2VyXSAtIFNob3VsZCBiZSBgdHJ1ZWAgaWYgYE1vY2hhYCBwcm9jZXNzIGlzIHJ1bm5pbmcgaW4gYSB3b3JrZXIgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gTW9jaGEob3B0aW9ucyA9IHt9KSB7XG4gIG9wdGlvbnMgPSB7Li4ubW9jaGFyYywgLi4ub3B0aW9uc307XG4gIHRoaXMuZmlsZXMgPSBbXTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgLy8gcm9vdCBzdWl0ZVxuICB0aGlzLnN1aXRlID0gbmV3IGV4cG9ydHMuU3VpdGUoJycsIG5ldyBleHBvcnRzLkNvbnRleHQoKSwgdHJ1ZSk7XG4gIHRoaXMuX2NsZWFuUmVmZXJlbmNlc0FmdGVyUnVuID0gdHJ1ZTtcbiAgdGhpcy5fc3RhdGUgPSBtb2NoYVN0YXRlcy5JTklUO1xuXG4gIHRoaXMuZ3JlcChvcHRpb25zLmdyZXApXG4gICAgLmZncmVwKG9wdGlvbnMuZmdyZXApXG4gICAgLnVpKG9wdGlvbnMudWkpXG4gICAgLnJlcG9ydGVyKFxuICAgICAgb3B0aW9ucy5yZXBvcnRlcixcbiAgICAgIG9wdGlvbnMucmVwb3J0ZXJPcHRpb24gfHwgb3B0aW9ucy5yZXBvcnRlck9wdGlvbnMgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgKVxuICAgIC5zbG93KG9wdGlvbnMuc2xvdylcbiAgICAuZ2xvYmFsKG9wdGlvbnMuZ2xvYmFsKTtcblxuICAvLyB0aGlzIGd1YXJkIGV4aXN0cyBiZWNhdXNlIFN1aXRlI3RpbWVvdXQgZG9lcyBub3QgY29uc2lkZXIgYHVuZGVmaW5lZGAgdG8gYmUgdmFsaWQgaW5wdXRcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnRpbWVvdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy50aW1lb3V0KG9wdGlvbnMudGltZW91dCA9PT0gZmFsc2UgPyAwIDogb3B0aW9ucy50aW1lb3V0KTtcbiAgfVxuXG4gIGlmICgncmV0cmllcycgaW4gb3B0aW9ucykge1xuICAgIHRoaXMucmV0cmllcyhvcHRpb25zLnJldHJpZXMpO1xuICB9XG5cbiAgW1xuICAgICdhbGxvd1VuY2F1Z2h0JyxcbiAgICAnYXN5bmNPbmx5JyxcbiAgICAnYmFpbCcsXG4gICAgJ2NoZWNrTGVha3MnLFxuICAgICdjb2xvcicsXG4gICAgJ2RlbGF5JyxcbiAgICAnZGlmZicsXG4gICAgJ2RyeVJ1bicsXG4gICAgJ2ZhaWxaZXJvJyxcbiAgICAnZm9yYmlkT25seScsXG4gICAgJ2ZvcmJpZFBlbmRpbmcnLFxuICAgICdmdWxsVHJhY2UnLFxuICAgICdpbmxpbmVEaWZmcycsXG4gICAgJ2ludmVydCdcbiAgXS5mb3JFYWNoKGZ1bmN0aW9uIChvcHQpIHtcbiAgICBpZiAob3B0aW9uc1tvcHRdKSB7XG4gICAgICB0aGlzW29wdF0oKTtcbiAgICB9XG4gIH0sIHRoaXMpO1xuXG4gIGlmIChvcHRpb25zLnJvb3RIb29rcykge1xuICAgIHRoaXMucm9vdEhvb2tzKG9wdGlvbnMucm9vdEhvb2tzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY2xhc3Mgd2hpY2ggd2UnbGwgaW5zdGFudGlhdGUgaW4ge0BsaW5rIE1vY2hhI3J1bn0uICBEZWZhdWx0cyB0b1xuICAgKiB7QGxpbmsgUnVubmVyfSBpbiBzZXJpYWwgbW9kZTsgY2hhbmdlcyBpbiBwYXJhbGxlbCBtb2RlLlxuICAgKiBAbWVtYmVyb2YgTW9jaGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuX3J1bm5lckNsYXNzID0gZXhwb3J0cy5SdW5uZXI7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRvIGNhbGwge0BsaW5rIE1vY2hhI2xvYWRGaWxlc30gaW1wbGljaXRseSB3aGVuIGNhbGxpbmdcbiAgICoge0BsaW5rIE1vY2hhI3J1bn0uICBJZiB0aGlzIGlzIGB0cnVlYCwgdGhlbiBpdCdzIHVwIHRvIHRoZSBjb25zdW1lciB0byBjYWxsXG4gICAqIHtAbGluayBNb2NoYSNsb2FkRmlsZXN9IF9vcl8ge0BsaW5rIE1vY2hhI2xvYWRGaWxlc0FzeW5jfS5cbiAgICogQHByaXZhdGVcbiAgICogQG1lbWJlcm9mIE1vY2hhXG4gICAqL1xuICB0aGlzLl9sYXp5TG9hZEZpbGVzID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEl0J3MgdXNlZnVsIGZvciBhIE1vY2hhIGluc3RhbmNlIHRvIGtub3cgaWYgaXQncyBydW5uaW5nIGluIGEgd29ya2VyIHByb2Nlc3MuXG4gICAqIFdlIGNvdWxkIGRlcml2ZSB0aGlzIHZpYSBvdGhlciBtZWFucywgYnV0IGl0J3MgaGVscGZ1bCB0byBoYXZlIGEgZmxhZyB0byByZWZlciB0by5cbiAgICogQG1lbWJlcm9mIE1vY2hhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmlzV29ya2VyID0gQm9vbGVhbihvcHRpb25zLmlzV29ya2VyKTtcblxuICB0aGlzLmdsb2JhbFNldHVwKG9wdGlvbnMuZ2xvYmFsU2V0dXApXG4gICAgLmdsb2JhbFRlYXJkb3duKG9wdGlvbnMuZ2xvYmFsVGVhcmRvd24pXG4gICAgLmVuYWJsZUdsb2JhbFNldHVwKG9wdGlvbnMuZW5hYmxlR2xvYmFsU2V0dXApXG4gICAgLmVuYWJsZUdsb2JhbFRlYXJkb3duKG9wdGlvbnMuZW5hYmxlR2xvYmFsVGVhcmRvd24pO1xuXG4gIGlmIChcbiAgICBvcHRpb25zLnBhcmFsbGVsICYmXG4gICAgKHR5cGVvZiBvcHRpb25zLmpvYnMgPT09ICd1bmRlZmluZWQnIHx8IG9wdGlvbnMuam9icyA+IDEpXG4gICkge1xuICAgIGRlYnVnKCdhdHRlbXB0aW5nIHRvIGVuYWJsZSBwYXJhbGxlbCBtb2RlJyk7XG4gICAgdGhpcy5wYXJhbGxlbE1vZGUodHJ1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGVzIG9yIGRpc2FibGVzIGJhaWxpbmcgb24gdGhlIGZpcnN0IGZhaWx1cmUuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1iYWlsLWIpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtiYWlsPXRydWVdIC0gV2hldGhlciB0byBiYWlsIG9uIGZpcnN0IGVycm9yLlxuICogQHJldHVybnMge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5iYWlsID0gZnVuY3Rpb24gKGJhaWwpIHtcbiAgdGhpcy5zdWl0ZS5iYWlsKGJhaWwgIT09IGZhbHNlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBzdW1tYXJ5XG4gKiBBZGRzIGBmaWxlYCB0byBiZSBsb2FkZWQgZm9yIGV4ZWN1dGlvbi5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFVzZWZ1bCBmb3IgZ2VuZXJpYyBzZXR1cCBjb2RlIHRoYXQgbXVzdCBiZSBpbmNsdWRlZCB3aXRoaW4gdGVzdCBzdWl0ZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWZpbGUtZmlsZWRpcmVjdG9yeWdsb2IpXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZSAtIFBhdGhuYW1lIG9mIGZpbGUgdG8gYmUgbG9hZGVkLlxuICogQHJldHVybnMge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5hZGRGaWxlID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgdGhpcy5maWxlcy5wdXNoKGZpbGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyByZXBvcnRlciB0byBgcmVwb3J0ZXJgLCBkZWZhdWx0cyB0byBcInNwZWNcIi5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLXJlcG9ydGVyLW5hbWUtci1uYW1lKVxuICogQHNlZSBbUmVwb3J0ZXJzXSguLi8jcmVwb3J0ZXJzKVxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHJlcG9ydGVyTmFtZSAtIFJlcG9ydGVyIG5hbWUgb3IgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcG9ydGVyT3B0aW9uc10gLSBPcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoZSByZXBvcnRlci5cbiAqIEByZXR1cm5zIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICogQHRocm93cyB7RXJyb3J9IGlmIHJlcXVlc3RlZCByZXBvcnRlciBjYW5ub3QgYmUgbG9hZGVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFVzZSBYVW5pdCByZXBvcnRlciBhbmQgZGlyZWN0IGl0cyBvdXRwdXQgdG8gZmlsZVxuICogbW9jaGEucmVwb3J0ZXIoJ3h1bml0JywgeyBvdXRwdXQ6ICcvcGF0aC90by90ZXN0c3BlYy54dW5pdC54bWwnIH0pO1xuICovXG5Nb2NoYS5wcm90b3R5cGUucmVwb3J0ZXIgPSBmdW5jdGlvbiAocmVwb3J0ZXJOYW1lLCByZXBvcnRlck9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiByZXBvcnRlck5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9yZXBvcnRlciA9IHJlcG9ydGVyTmFtZTtcbiAgfSBlbHNlIHtcbiAgICByZXBvcnRlck5hbWUgPSByZXBvcnRlck5hbWUgfHwgJ3NwZWMnO1xuICAgIHZhciByZXBvcnRlcjtcbiAgICAvLyBUcnkgdG8gbG9hZCBhIGJ1aWx0LWluIHJlcG9ydGVyLlxuICAgIGlmIChidWlsdGluUmVwb3J0ZXJzW3JlcG9ydGVyTmFtZV0pIHtcbiAgICAgIHJlcG9ydGVyID0gYnVpbHRpblJlcG9ydGVyc1tyZXBvcnRlck5hbWVdO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gbG9hZCByZXBvcnRlcnMgZnJvbSBwcm9jZXNzLmN3ZCgpIGFuZCBub2RlX21vZHVsZXNcbiAgICBpZiAoIXJlcG9ydGVyKSB7XG4gICAgICBsZXQgZm91bmRSZXBvcnRlcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvdW5kUmVwb3J0ZXIgPSByZXF1aXJlLnJlc29sdmUocmVwb3J0ZXJOYW1lKTtcbiAgICAgICAgcmVwb3J0ZXIgPSByZXF1aXJlKGZvdW5kUmVwb3J0ZXIpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChmb3VuZFJlcG9ydGVyKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFJlcG9ydGVyRXJyb3IoZXJyLm1lc3NhZ2UsIGZvdW5kUmVwb3J0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBsb2FkIHJlcG9ydGVycyBmcm9tIGEgY3dkLXJlbGF0aXZlIHBhdGhcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXBvcnRlciA9IHJlcXVpcmUocGF0aC5yZXNvbHZlKHJlcG9ydGVyTmFtZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFJlcG9ydGVyRXJyb3IoZS5tZXNzYWdlLCByZXBvcnRlck5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3JlcG9ydGVyID0gcmVwb3J0ZXI7XG4gIH1cbiAgdGhpcy5vcHRpb25zLnJlcG9ydGVyT3B0aW9uID0gcmVwb3J0ZXJPcHRpb25zO1xuICAvLyBhbGlhcyBvcHRpb24gbmFtZSBpcyB1c2VkIGluIGJ1aWx0LWluIHJlcG9ydGVycyB4dW5pdC90YXAvcHJvZ3Jlc3NcbiAgdGhpcy5vcHRpb25zLnJlcG9ydGVyT3B0aW9ucyA9IHJlcG9ydGVyT3B0aW9ucztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGVzdCBVSSBgbmFtZWAsIGRlZmF1bHRzIHRvIFwiYmRkXCIuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy11aS1uYW1lLXUtbmFtZSlcbiAqIEBzZWUgW0ludGVyZmFjZSBEU0xzXSguLi8jaW50ZXJmYWNlcylcbiAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufSBbdWk9YmRkXSAtIEludGVyZmFjZSBuYW1lIG9yIGNsYXNzLlxuICogQHJldHVybnMge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgcmVxdWVzdGVkIGludGVyZmFjZSBjYW5ub3QgYmUgbG9hZGVkXG4gKi9cbk1vY2hhLnByb3RvdHlwZS51aSA9IGZ1bmN0aW9uICh1aSkge1xuICB2YXIgYmluZEludGVyZmFjZTtcbiAgaWYgKHR5cGVvZiB1aSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGJpbmRJbnRlcmZhY2UgPSB1aTtcbiAgfSBlbHNlIHtcbiAgICB1aSA9IHVpIHx8ICdiZGQnO1xuICAgIGJpbmRJbnRlcmZhY2UgPSBleHBvcnRzLmludGVyZmFjZXNbdWldO1xuICAgIGlmICghYmluZEludGVyZmFjZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYmluZEludGVyZmFjZSA9IHJlcXVpcmUodWkpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRJbnRlcmZhY2VFcnJvcihgaW52YWxpZCBpbnRlcmZhY2UgJyR7dWl9J2AsIHVpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYmluZEludGVyZmFjZSh0aGlzLnN1aXRlKTtcblxuICB0aGlzLnN1aXRlLm9uKEVWRU5UX0ZJTEVfUFJFX1JFUVVJUkUsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgY3VycmVudENvbnRleHQgPSBjb250ZXh0O1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTG9hZHMgYGZpbGVzYCBwcmlvciB0byBleGVjdXRpb24uIERvZXMgbm90IHN1cHBvcnQgRVMgTW9kdWxlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiByZWxpZXMgb24gTm9kZSdzIGByZXF1aXJlYCB0byBleGVjdXRlXG4gKiB0aGUgdGVzdCBpbnRlcmZhY2UgZnVuY3Rpb25zIGFuZCB3aWxsIGJlIHN1YmplY3QgdG8gaXRzIGNhY2hlLlxuICogU3VwcG9ydHMgb25seSBDb21tb25KUyBtb2R1bGVzLiBUbyBsb2FkIEVTIG1vZHVsZXMsIHVzZSBNb2NoYSNsb2FkRmlsZXNBc3luYy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHNlZSB7QGxpbmsgTW9jaGEjYWRkRmlsZX1cbiAqIEBzZWUge0BsaW5rIE1vY2hhI3J1bn1cbiAqIEBzZWUge0BsaW5rIE1vY2hhI3VubG9hZEZpbGVzfVxuICogQHNlZSB7QGxpbmsgTW9jaGEjbG9hZEZpbGVzQXN5bmN9XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIC0gQ2FsbGJhY2sgaW52b2tlZCB1cG9uIGNvbXBsZXRpb24uXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5sb2FkRmlsZXMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc3VpdGUgPSB0aGlzLnN1aXRlO1xuICB0aGlzLmZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICBmaWxlID0gcGF0aC5yZXNvbHZlKGZpbGUpO1xuICAgIHN1aXRlLmVtaXQoRVZFTlRfRklMRV9QUkVfUkVRVUlSRSwgZ2xvYmFsLCBmaWxlLCBzZWxmKTtcbiAgICBzdWl0ZS5lbWl0KEVWRU5UX0ZJTEVfUkVRVUlSRSwgcmVxdWlyZShmaWxlKSwgZmlsZSwgc2VsZik7XG4gICAgc3VpdGUuZW1pdChFVkVOVF9GSUxFX1BPU1RfUkVRVUlSRSwgZ2xvYmFsLCBmaWxlLCBzZWxmKTtcbiAgfSk7XG4gIGZuICYmIGZuKCk7XG59O1xuXG4vKipcbiAqIExvYWRzIGBmaWxlc2AgcHJpb3IgdG8gZXhlY3V0aW9uLiBTdXBwb3J0cyBOb2RlIEVTIE1vZHVsZXMuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gcmVsaWVzIG9uIE5vZGUncyBgcmVxdWlyZWAgYW5kIGBpbXBvcnRgIHRvIGV4ZWN1dGVcbiAqIHRoZSB0ZXN0IGludGVyZmFjZSBmdW5jdGlvbnMgYW5kIHdpbGwgYmUgc3ViamVjdCB0byBpdHMgY2FjaGUuXG4gKiBTdXBwb3J0cyBib3RoIENKUyBhbmQgRVNNIG1vZHVsZXMuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSB7QGxpbmsgTW9jaGEjYWRkRmlsZX1cbiAqIEBzZWUge0BsaW5rIE1vY2hhI3J1bn1cbiAqIEBzZWUge0BsaW5rIE1vY2hhI3VubG9hZEZpbGVzfVxuICogQHJldHVybnMge1Byb21pc2V9XG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGxvYWRzIEVTTSAoYW5kIENKUykgdGVzdCBmaWxlcyBhc3luY2hyb25vdXNseSwgdGhlbiBydW5zIHJvb3Qgc3VpdGVcbiAqIG1vY2hhLmxvYWRGaWxlc0FzeW5jKClcbiAqICAgLnRoZW4oKCkgPT4gbW9jaGEucnVuKGZhaWx1cmVzID0+IHByb2Nlc3MuZXhpdENvZGUgPSBmYWlsdXJlcyA/IDEgOiAwKSlcbiAqICAgLmNhdGNoKCgpID0+IHByb2Nlc3MuZXhpdENvZGUgPSAxKTtcbiAqL1xuTW9jaGEucHJvdG90eXBlLmxvYWRGaWxlc0FzeW5jID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdWl0ZSA9IHRoaXMuc3VpdGU7XG4gIHRoaXMubGF6eUxvYWRGaWxlcyh0cnVlKTtcblxuICByZXR1cm4gZXNtVXRpbHMubG9hZEZpbGVzQXN5bmMoXG4gICAgdGhpcy5maWxlcyxcbiAgICBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgc3VpdGUuZW1pdChFVkVOVF9GSUxFX1BSRV9SRVFVSVJFLCBnbG9iYWwsIGZpbGUsIHNlbGYpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gKGZpbGUsIHJlc3VsdE1vZHVsZSkge1xuICAgICAgc3VpdGUuZW1pdChFVkVOVF9GSUxFX1JFUVVJUkUsIHJlc3VsdE1vZHVsZSwgZmlsZSwgc2VsZik7XG4gICAgICBzdWl0ZS5lbWl0KEVWRU5UX0ZJTEVfUE9TVF9SRVFVSVJFLCBnbG9iYWwsIGZpbGUsIHNlbGYpO1xuICAgIH1cbiAgKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgbG9hZGVkIGZpbGUgZnJvbSBOb2RlJ3MgYHJlcXVpcmVgIGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBAc2VlIHtAbGluayBNb2NoYSN1bmxvYWRGaWxlc31cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlIC0gUGF0aG5hbWUgb2YgZmlsZSB0byBiZSB1bmxvYWRlZC5cbiAqL1xuTW9jaGEudW5sb2FkRmlsZSA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gIGlmICh1dGlscy5pc0Jyb3dzZXIoKSkge1xuICAgIHRocm93IGNyZWF0ZVVuc3VwcG9ydGVkRXJyb3IoXG4gICAgICAndW5sb2FkRmlsZSgpIGlzIG9ubHkgc3VwcG9ydGVkIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudCdcbiAgICApO1xuICB9XG4gIHJldHVybiByZXF1aXJlKCcuL25vZGVqcy9maWxlLXVubG9hZGVyJykudW5sb2FkRmlsZShmaWxlKTtcbn07XG5cbi8qKlxuICogVW5sb2FkcyBgZmlsZXNgIGZyb20gTm9kZSdzIGByZXF1aXJlYCBjYWNoZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgYWxsb3dzIHJlcXVpcmVkIGZpbGVzIHRvIGJlIFwiZnJlc2hseVwiIHJlbG9hZGVkLCBwcm92aWRpbmcgdGhlIGFiaWxpdHlcbiAqIHRvIHJldXNlIGEgTW9jaGEgaW5zdGFuY2UgcHJvZ3JhbW1hdGljYWxseS5cbiAqIE5vdGU6IGRvZXMgbm90IGNsZWFyIEVTTSBtb2R1bGUgZmlsZXMgZnJvbSB0aGUgY2FjaGVcbiAqXG4gKiA8c3Ryb25nPkludGVuZGVkIGZvciBjb25zdW1lcnMgJm1kYXNoOyBub3QgdXNlZCBpbnRlcm5hbGx5PC9zdHJvbmc+XG4gKlxuICogQHB1YmxpY1xuICogQHNlZSB7QGxpbmsgTW9jaGEjcnVufVxuICogQHJldHVybnMge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS51bmxvYWRGaWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX3N0YXRlID09PSBtb2NoYVN0YXRlcy5ESVNQT1NFRCkge1xuICAgIHRocm93IGNyZWF0ZU1vY2hhSW5zdGFuY2VBbHJlYWR5RGlzcG9zZWRFcnJvcihcbiAgICAgICdNb2NoYSBpbnN0YW5jZSBpcyBhbHJlYWR5IGRpc3Bvc2VkLCBpdCBjYW5ub3QgYmUgdXNlZCBhZ2Fpbi4nLFxuICAgICAgdGhpcy5fY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW4sXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuXG4gIHRoaXMuZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgIE1vY2hhLnVubG9hZEZpbGUoZmlsZSk7XG4gIH0pO1xuICB0aGlzLl9zdGF0ZSA9IG1vY2hhU3RhdGVzLklOSVQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIGBncmVwYCBmaWx0ZXIgYWZ0ZXIgZXNjYXBpbmcgUmVnRXhwIHNwZWNpYWwgY2hhcmFjdGVycy5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIHtAbGluayBNb2NoYSNncmVwfVxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFZhbHVlIHRvIGJlIGNvbnZlcnRlZCB0byBhIHJlZ2V4cC5cbiAqIEByZXR1cm5zIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBTZWxlY3QgdGVzdHMgd2hvc2UgZnVsbCB0aXRsZSBiZWdpbnMgd2l0aCBgXCJmb29cImAgZm9sbG93ZWQgYnkgYSBwZXJpb2RcbiAqIG1vY2hhLmZncmVwKCdmb28uJyk7XG4gKi9cbk1vY2hhLnByb3RvdHlwZS5mZ3JlcCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKCFzdHIpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXR1cm4gdGhpcy5ncmVwKG5ldyBSZWdFeHAoZXNjYXBlUmUoc3RyKSkpO1xufTtcblxuLyoqXG4gKiBAc3VtbWFyeVxuICogU2V0cyBgZ3JlcGAgZmlsdGVyIHVzZWQgdG8gc2VsZWN0IHNwZWNpZmljIHRlc3RzIGZvciBleGVjdXRpb24uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJZiBgcmVgIGlzIGEgcmVnZXhwLWxpa2Ugc3RyaW5nLCBpdCB3aWxsIGJlIGNvbnZlcnRlZCB0byByZWdleHAuXG4gKiBUaGUgcmVnZXhwIGlzIHRlc3RlZCBhZ2FpbnN0IHRoZSBmdWxsIHRpdGxlIG9mIGVhY2ggdGVzdCAoaS5lLiwgdGhlXG4gKiBuYW1lIG9mIHRoZSB0ZXN0IHByZWNlZGVkIGJ5IHRpdGxlcyBvZiBlYWNoIGl0cyBhbmNlc3RyYWwgc3VpdGVzKS5cbiAqIEFzIHN1Y2gsIHVzaW5nIGFuIDxlbT5leGFjdC1tYXRjaDwvZW0+IGZpeGVkIHBhdHRlcm4gYWdhaW5zdCB0aGVcbiAqIHRlc3QgbmFtZSBpdHNlbGYgd2lsbCBub3QgeWllbGQgYW55IG1hdGNoZXMuXG4gKiA8YnI+XG4gKiA8c3Ryb25nPlByZXZpb3VzIGZpbHRlciB2YWx1ZSB3aWxsIGJlIG92ZXJ3cml0dGVuIG9uIGVhY2ggY2FsbCE8L3N0cm9uZz5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWdyZXAtcmVnZXhwLWctcmVnZXhwKVxuICogQHNlZSB7QGxpbmsgTW9jaGEjZmdyZXB9XG4gKiBAc2VlIHtAbGluayBNb2NoYSNpbnZlcnR9XG4gKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHJlIC0gUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gc2VsZWN0IHRlc3RzLlxuICogQHJldHVybiB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gU2VsZWN0IHRlc3RzIHdob3NlIGZ1bGwgdGl0bGUgY29udGFpbnMgYFwibWF0Y2hcImAsIGlnbm9yaW5nIGNhc2VcbiAqIG1vY2hhLmdyZXAoL21hdGNoL2kpO1xuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBTYW1lIGFzIGFib3ZlIGJ1dCB3aXRoIHJlZ2V4cC1saWtlIHN0cmluZyBhcmd1bWVudFxuICogbW9jaGEuZ3JlcCgnL21hdGNoL2knKTtcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gIyMgQW50aS1leGFtcGxlXG4gKiAvLyBHaXZlbiBlbWJlZGRlZCB0ZXN0IGBpdCgnb25seS10aGlzLXRlc3QnKWAuLi5cbiAqIG1vY2hhLmdyZXAoJy9eb25seS10aGlzLXRlc3QkLycpOyAgICAvLyBOTyEgVXNlIGAub25seSgpYCB0byBkbyB0aGlzIVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZ3JlcCA9IGZ1bmN0aW9uIChyZSkge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmUpKSB7XG4gICAgLy8gZXh0cmFjdCBhcmdzIGlmIGl0J3MgcmVnZXgtbGlrZSwgaS5lOiBbc3RyaW5nLCBwYXR0ZXJuLCBmbGFnXVxuICAgIHZhciBhcmcgPSByZS5tYXRjaCgvXlxcLyguKilcXC8oW2dpbXldezAsNH0pJHwuKi8pO1xuICAgIHRoaXMub3B0aW9ucy5ncmVwID0gbmV3IFJlZ0V4cChhcmdbMV0gfHwgYXJnWzBdLCBhcmdbMl0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5ncmVwID0gcmU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEludmVydHMgYGdyZXBgIG1hdGNoZXMuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSB7QGxpbmsgTW9jaGEjZ3JlcH1cbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFNlbGVjdCB0ZXN0cyB3aG9zZSBmdWxsIHRpdGxlIGRvZXMgKm5vdCogY29udGFpbiBgXCJtYXRjaFwiYCwgaWdub3JpbmcgY2FzZVxuICogbW9jaGEuZ3JlcCgvbWF0Y2gvaSkuaW52ZXJ0KCk7XG4gKi9cbk1vY2hhLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMub3B0aW9ucy5pbnZlcnQgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW5hYmxlcyBvciBkaXNhYmxlcyBjaGVja2luZyBmb3IgZ2xvYmFsIHZhcmlhYmxlcyBsZWFrZWQgd2hpbGUgcnVubmluZyB0ZXN0cy5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWNoZWNrLWxlYWtzKVxuICogQHBhcmFtIHtib29sZWFufSBbY2hlY2tMZWFrcz10cnVlXSAtIFdoZXRoZXIgdG8gY2hlY2sgZm9yIGdsb2JhbCB2YXJpYWJsZSBsZWFrcy5cbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5jaGVja0xlYWtzID0gZnVuY3Rpb24gKGNoZWNrTGVha3MpIHtcbiAgdGhpcy5vcHRpb25zLmNoZWNrTGVha3MgPSBjaGVja0xlYWtzICE9PSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgd2hldGhlciBvciBub3QgdG8gZGlzcG9zZSBhZnRlciBlYWNoIHRlc3QgcnVuLlxuICogRGlzYWJsZSB0aGlzIHRvIGVuc3VyZSB5b3UgY2FuIHJ1biB0aGUgdGVzdCBzdWl0ZSBtdWx0aXBsZSB0aW1lcy5cbiAqIElmIGRpc2FibGVkLCBiZSBzdXJlIHRvIGRpc3Bvc2UgbW9jaGEgd2hlbiB5b3UncmUgZG9uZSB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy5cbiAqIEBwdWJsaWNcbiAqIEBzZWUge0BsaW5rIE1vY2hhI2Rpc3Bvc2V9XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFuUmVmZXJlbmNlc0FmdGVyUnVuXG4gKiBAcmV0dXJuIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUuY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW4gPSBmdW5jdGlvbiAoY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW4pIHtcbiAgdGhpcy5fY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW4gPSBjbGVhblJlZmVyZW5jZXNBZnRlclJ1biAhPT0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNYW51YWxseSBkaXNwb3NlIHRoaXMgbW9jaGEgaW5zdGFuY2UuIE1hcmsgdGhpcyBpbnN0YW5jZSBhcyBgZGlzcG9zZWRgIGFuZCB1bmFibGUgdG8gcnVuIG1vcmUgdGVzdHMuXG4gKiBJdCBhbHNvIHJlbW92ZXMgZnVuY3Rpb24gcmVmZXJlbmNlcyB0byB0ZXN0cyBmdW5jdGlvbnMgYW5kIGhvb2tzLCBzbyB2YXJpYWJsZXMgdHJhcHBlZCBpbiBjbG9zdXJlcyBjYW4gYmUgY2xlYW5lZCBieSB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IuXG4gKiBAcHVibGljXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fc3RhdGUgPT09IG1vY2hhU3RhdGVzLlJVTk5JTkcpIHtcbiAgICB0aHJvdyBjcmVhdGVNb2NoYUluc3RhbmNlQWxyZWFkeVJ1bm5pbmdFcnJvcihcbiAgICAgICdDYW5ub3QgZGlzcG9zZSB3aGlsZSB0aGUgbW9jaGEgaW5zdGFuY2UgaXMgc3RpbGwgcnVubmluZyB0ZXN0cy4nXG4gICAgKTtcbiAgfVxuICB0aGlzLnVubG9hZEZpbGVzKCk7XG4gIHRoaXMuX3ByZXZpb3VzUnVubmVyICYmIHRoaXMuX3ByZXZpb3VzUnVubmVyLmRpc3Bvc2UoKTtcbiAgdGhpcy5zdWl0ZS5kaXNwb3NlKCk7XG4gIHRoaXMuX3N0YXRlID0gbW9jaGFTdGF0ZXMuRElTUE9TRUQ7XG59O1xuXG4vKipcbiAqIERpc3BsYXlzIGZ1bGwgc3RhY2sgdHJhY2UgdXBvbiB0ZXN0IGZhaWx1cmUuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1mdWxsLXRyYWNlKVxuICogQHBhcmFtIHtib29sZWFufSBbZnVsbFRyYWNlPXRydWVdIC0gV2hldGhlciB0byBwcmludCBmdWxsIHN0YWNrdHJhY2UgdXBvbiBmYWlsdXJlLlxuICogQHJldHVybiB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqL1xuTW9jaGEucHJvdG90eXBlLmZ1bGxUcmFjZSA9IGZ1bmN0aW9uIChmdWxsVHJhY2UpIHtcbiAgdGhpcy5vcHRpb25zLmZ1bGxUcmFjZSA9IGZ1bGxUcmFjZSAhPT0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgd2hpdGVsaXN0IG9mIHZhcmlhYmxlIG5hbWVzIHRvIGJlIGV4cGVjdGVkIGluIGdsb2JhbCBzY29wZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWdsb2JhbC12YXJpYWJsZS1uYW1lKVxuICogQHNlZSB7QGxpbmsgTW9jaGEjY2hlY2tMZWFrc31cbiAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfSBnbG9iYWwgLSBBY2NlcHRlZCBnbG9iYWwgdmFyaWFibGUgbmFtZShzKS5cbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFNwZWNpZnkgdmFyaWFibGVzIHRvIGJlIGV4cGVjdGVkIGluIGdsb2JhbCBzY29wZVxuICogbW9jaGEuZ2xvYmFsKFsnalF1ZXJ5JywgJ015TGliJ10pO1xuICovXG5Nb2NoYS5wcm90b3R5cGUuZ2xvYmFsID0gZnVuY3Rpb24gKGdsb2JhbCkge1xuICB0aGlzLm9wdGlvbnMuZ2xvYmFsID0gKHRoaXMub3B0aW9ucy5nbG9iYWwgfHwgW10pXG4gICAgLmNvbmNhdChnbG9iYWwpXG4gICAgLmZpbHRlcihCb29sZWFuKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsdCwgaWR4LCBhcnIpIHtcbiAgICAgIHJldHVybiBhcnIuaW5kZXhPZihlbHQpID09PSBpZHg7XG4gICAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcbi8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgJ2dsb2JhbHMnIGlzIGFuIGFsaWFzIG9mICdnbG9iYWwnXG5Nb2NoYS5wcm90b3R5cGUuZ2xvYmFscyA9IE1vY2hhLnByb3RvdHlwZS5nbG9iYWw7XG5cbi8qKlxuICogRW5hYmxlcyBvciBkaXNhYmxlcyBUVFkgY29sb3Igb3V0cHV0IGJ5IHNjcmVlbi1vcmllbnRlZCByZXBvcnRlcnMuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1jb2xvci1jLWNvbG9ycylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbG9yPXRydWVdIC0gV2hldGhlciB0byBlbmFibGUgY29sb3Igb3V0cHV0LlxuICogQHJldHVybiB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqL1xuTW9jaGEucHJvdG90eXBlLmNvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gIHRoaXMub3B0aW9ucy5jb2xvciA9IGNvbG9yICE9PSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgcmVwb3J0ZXIgdG8gdXNlIGlubGluZSBkaWZmcyAocmF0aGVyIHRoYW4gKy8tKVxuICogaW4gdGVzdCBmYWlsdXJlIG91dHB1dC5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWlubGluZS1kaWZmcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lubGluZURpZmZzPXRydWVdIC0gV2hldGhlciB0byB1c2UgaW5saW5lIGRpZmZzLlxuICogQHJldHVybiB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqL1xuTW9jaGEucHJvdG90eXBlLmlubGluZURpZmZzID0gZnVuY3Rpb24gKGlubGluZURpZmZzKSB7XG4gIHRoaXMub3B0aW9ucy5pbmxpbmVEaWZmcyA9IGlubGluZURpZmZzICE9PSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgcmVwb3J0ZXIgdG8gaW5jbHVkZSBkaWZmIGluIHRlc3QgZmFpbHVyZSBvdXRwdXQuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1kaWZmKVxuICogQHBhcmFtIHtib29sZWFufSBbZGlmZj10cnVlXSAtIFdoZXRoZXIgdG8gc2hvdyBkaWZmIG9uIGZhaWx1cmUuXG4gKiBAcmV0dXJuIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIChkaWZmKSB7XG4gIHRoaXMub3B0aW9ucy5kaWZmID0gZGlmZiAhPT0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAc3VtbWFyeVxuICogU2V0cyB0aW1lb3V0IHRocmVzaG9sZCB2YWx1ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgc3RyaW5nIGFyZ3VtZW50IGNhbiB1c2Ugc2hvcnRoYW5kIChzdWNoIGFzIFwiMnNcIikgYW5kIHdpbGwgYmUgY29udmVydGVkLlxuICogSWYgdGhlIHZhbHVlIGlzIGAwYCwgdGltZW91dHMgd2lsbCBiZSBkaXNhYmxlZC5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLXRpbWVvdXQtbXMtdC1tcylcbiAqIEBzZWUgW1RpbWVvdXRzXSguLi8jdGltZW91dHMpXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG1zZWNzIC0gVGltZW91dCB0aHJlc2hvbGQgdmFsdWUuXG4gKiBAcmV0dXJuIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBTZXRzIHRpbWVvdXQgdG8gb25lIHNlY29uZFxuICogbW9jaGEudGltZW91dCgxMDAwKTtcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gU2FtZSBhcyBhYm92ZSBidXQgdXNpbmcgc3RyaW5nIGFyZ3VtZW50XG4gKiBtb2NoYS50aW1lb3V0KCcxcycpO1xuICovXG5Nb2NoYS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChtc2Vjcykge1xuICB0aGlzLnN1aXRlLnRpbWVvdXQobXNlY3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IGZhaWxlZCB0ZXN0cy5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLXJldHJpZXMtbilcbiAqIEBzZWUgW1JldHJ5IFRlc3RzXSguLi8jcmV0cnktdGVzdHMpXG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cnkgLSBOdW1iZXIgb2YgdGltZXMgdG8gcmV0cnkgZmFpbGVkIHRlc3RzLlxuICogQHJldHVybiB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQWxsb3cgYW55IGZhaWxlZCB0ZXN0IHRvIHJldHJ5IG9uZSBtb3JlIHRpbWVcbiAqIG1vY2hhLnJldHJpZXMoMSk7XG4gKi9cbk1vY2hhLnByb3RvdHlwZS5yZXRyaWVzID0gZnVuY3Rpb24gKHJldHJ5KSB7XG4gIHRoaXMuc3VpdGUucmV0cmllcyhyZXRyeSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHNsb3duZXNzIHRocmVzaG9sZCB2YWx1ZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLXNsb3ctbXMtcy1tcylcbiAqIEBwYXJhbSB7bnVtYmVyfSBtc2VjcyAtIFNsb3duZXNzIHRocmVzaG9sZCB2YWx1ZS5cbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFNldHMgXCJzbG93XCIgdGhyZXNob2xkIHRvIGhhbGYgYSBzZWNvbmRcbiAqIG1vY2hhLnNsb3coNTAwKTtcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gU2FtZSBhcyBhYm92ZSBidXQgdXNpbmcgc3RyaW5nIGFyZ3VtZW50XG4gKiBtb2NoYS5zbG93KCcwLjVzJyk7XG4gKi9cbk1vY2hhLnByb3RvdHlwZS5zbG93ID0gZnVuY3Rpb24gKG1zZWNzKSB7XG4gIHRoaXMuc3VpdGUuc2xvdyhtc2Vjcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGb3JjZXMgYWxsIHRlc3RzIHRvIGVpdGhlciBhY2NlcHQgYSBgZG9uZWAgY2FsbGJhY2sgb3IgcmV0dXJuIGEgcHJvbWlzZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWFzeW5jLW9ubHktYSlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzeW5jT25seT10cnVlXSAtIFdoZXRoZXIgdG8gZm9yY2UgYGRvbmVgIGNhbGxiYWNrIG9yIHByb21pc2UuXG4gKiBAcmV0dXJuIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUuYXN5bmNPbmx5ID0gZnVuY3Rpb24gKGFzeW5jT25seSkge1xuICB0aGlzLm9wdGlvbnMuYXN5bmNPbmx5ID0gYXN5bmNPbmx5ICE9PSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERpc2FibGVzIHN5bnRheCBoaWdobGlnaHRpbmcgKGluIGJyb3dzZXIpLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5ub0hpZ2hsaWdodGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5vcHRpb25zLm5vSGlnaGxpZ2h0aW5nID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdW5jYXVnaHQgZXJyb3JzIHRvIHByb3BhZ2F0ZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWFsbG93LXVuY2F1Z2h0KVxuICogQHBhcmFtIHtib29sZWFufSBbYWxsb3dVbmNhdWdodD10cnVlXSAtIFdoZXRoZXIgdG8gcHJvcGFnYXRlIHVuY2F1Z2h0IGVycm9ycy5cbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5hbGxvd1VuY2F1Z2h0ID0gZnVuY3Rpb24gKGFsbG93VW5jYXVnaHQpIHtcbiAgdGhpcy5vcHRpb25zLmFsbG93VW5jYXVnaHQgPSBhbGxvd1VuY2F1Z2h0ICE9PSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBzdW1tYXJ5XG4gKiBEZWxheXMgcm9vdCBzdWl0ZSBleGVjdXRpb24uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBVc2VkIHRvIHBlcmZvcm0gYXN5bmMgb3BlcmF0aW9ucyBiZWZvcmUgYW55IHN1aXRlcyBhcmUgcnVuLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBzZWUgW2RlbGF5ZWQgcm9vdCBzdWl0ZV0oLi4vI2RlbGF5ZWQtcm9vdC1zdWl0ZSlcbiAqIEByZXR1cm5zIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiBkZWxheSgpIHtcbiAgdGhpcy5vcHRpb25zLmRlbGF5ID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgcnVubmluZyB0ZXN0cyBpbiBkcnktcnVuIG1vZGUuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1kcnktcnVuKVxuICogQHBhcmFtIHtib29sZWFufSBbZHJ5UnVuPXRydWVdIC0gV2hldGhlciB0byBhY3RpdmF0ZSBkcnktcnVuIG1vZGUuXG4gKiBAcmV0dXJuIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZHJ5UnVuID0gZnVuY3Rpb24gKGRyeVJ1bikge1xuICB0aGlzLm9wdGlvbnMuZHJ5UnVuID0gZHJ5UnVuICE9PSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZhaWxzIHRlc3QgcnVuIGlmIG5vIHRlc3RzIGVuY291bnRlcmVkIHdpdGggZXhpdC1jb2RlIDEuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1mYWlsLXplcm8pXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmYWlsWmVybz10cnVlXSAtIFdoZXRoZXIgdG8gZmFpbCB0ZXN0IHJ1bi5cbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5mYWlsWmVybyA9IGZ1bmN0aW9uIChmYWlsWmVybykge1xuICB0aGlzLm9wdGlvbnMuZmFpbFplcm8gPSBmYWlsWmVybyAhPT0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYXVzZXMgdGVzdHMgbWFya2VkIGBvbmx5YCB0byBmYWlsIHRoZSBzdWl0ZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWZvcmJpZC1vbmx5KVxuICogQHBhcmFtIHtib29sZWFufSBbZm9yYmlkT25seT10cnVlXSAtIFdoZXRoZXIgdGVzdHMgbWFya2VkIGBvbmx5YCBmYWlsIHRoZSBzdWl0ZS5cbiAqIEByZXR1cm5zIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZm9yYmlkT25seSA9IGZ1bmN0aW9uIChmb3JiaWRPbmx5KSB7XG4gIHRoaXMub3B0aW9ucy5mb3JiaWRPbmx5ID0gZm9yYmlkT25seSAhPT0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYXVzZXMgcGVuZGluZyB0ZXN0cyBhbmQgdGVzdHMgbWFya2VkIGBza2lwYCB0byBmYWlsIHRoZSBzdWl0ZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWZvcmJpZC1wZW5kaW5nKVxuICogQHBhcmFtIHtib29sZWFufSBbZm9yYmlkUGVuZGluZz10cnVlXSAtIFdoZXRoZXIgcGVuZGluZyB0ZXN0cyBmYWlsIHRoZSBzdWl0ZS5cbiAqIEByZXR1cm5zIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZm9yYmlkUGVuZGluZyA9IGZ1bmN0aW9uIChmb3JiaWRQZW5kaW5nKSB7XG4gIHRoaXMub3B0aW9ucy5mb3JiaWRQZW5kaW5nID0gZm9yYmlkUGVuZGluZyAhPT0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgbW9jaGEgaXMgaW4gdGhlIHdyb25nIHN0YXRlIHRvIGJlIGFibGUgdG8gdHJhbnNpdGlvbiB0byBhIFwicnVubmluZ1wiIHN0YXRlLlxuICogQHByaXZhdGVcbiAqL1xuTW9jaGEucHJvdG90eXBlLl9ndWFyZFJ1bm5pbmdTdGF0ZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9zdGF0ZSA9PT0gbW9jaGFTdGF0ZXMuUlVOTklORykge1xuICAgIHRocm93IGNyZWF0ZU1vY2hhSW5zdGFuY2VBbHJlYWR5UnVubmluZ0Vycm9yKFxuICAgICAgJ01vY2hhIGluc3RhbmNlIGlzIGN1cnJlbnRseSBydW5uaW5nIHRlc3RzLCBjYW5ub3Qgc3RhcnQgYSBuZXh0IHRlc3QgcnVuIHVudGlsIHRoaXMgb25lIGlzIGRvbmUnLFxuICAgICAgdGhpc1xuICAgICk7XG4gIH1cbiAgaWYgKFxuICAgIHRoaXMuX3N0YXRlID09PSBtb2NoYVN0YXRlcy5ESVNQT1NFRCB8fFxuICAgIHRoaXMuX3N0YXRlID09PSBtb2NoYVN0YXRlcy5SRUZFUkVOQ0VTX0NMRUFORURcbiAgKSB7XG4gICAgdGhyb3cgY3JlYXRlTW9jaGFJbnN0YW5jZUFscmVhZHlEaXNwb3NlZEVycm9yKFxuICAgICAgJ01vY2hhIGluc3RhbmNlIGlzIGFscmVhZHkgZGlzcG9zZWQsIGNhbm5vdCBzdGFydCBhIG5ldyB0ZXN0IHJ1bi4gUGxlYXNlIGNyZWF0ZSBhIG5ldyBtb2NoYSBpbnN0YW5jZS4gQmUgc3VyZSB0byBzZXQgZGlzYWJsZSBgY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW5gIHdoZW4geW91IHdhbnQgdG8gcmV1c2UgdGhlIHNhbWUgbW9jaGEgaW5zdGFuY2UgZm9yIG11bHRpcGxlIHRlc3QgcnVucy4nLFxuICAgICAgdGhpcy5fY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW4sXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNb2NoYSB2ZXJzaW9uIGFzIHNwZWNpZmllZCBieSBcInBhY2thZ2UuanNvblwiLlxuICpcbiAqIEBuYW1lIE1vY2hhI3ZlcnNpb25cbiAqIEB0eXBlIHN0cmluZ1xuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2NoYS5wcm90b3R5cGUsICd2ZXJzaW9uJywge1xuICB2YWx1ZTogcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbixcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IGZhbHNlXG59KTtcblxuLyoqXG4gKiBDYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGVzdCBleGVjdXRpb24gaXMgY29tcGxldGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYWxsYmFjayBEb25lQ0JcbiAqIEBwYXJhbSB7bnVtYmVyfSBmYWlsdXJlcyAtIE51bWJlciBvZiBmYWlsdXJlcyB0aGF0IG9jY3VycmVkLlxuICovXG5cbi8qKlxuICogUnVucyByb290IHN1aXRlIGFuZCBpbnZva2VzIGBmbigpYCB3aGVuIGNvbXBsZXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVG8gcnVuIHRlc3RzIG11bHRpcGxlIHRpbWVzIChvciB0byBydW4gdGVzdHMgaW4gZmlsZXMgdGhhdCBhcmVcbiAqIGFscmVhZHkgaW4gdGhlIGByZXF1aXJlYCBjYWNoZSksIG1ha2Ugc3VyZSB0byBjbGVhciB0aGVtIGZyb21cbiAqIHRoZSBjYWNoZSBmaXJzdCFcbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIHtAbGluayBNb2NoYSN1bmxvYWRGaWxlc31cbiAqIEBzZWUge0BsaW5rIFJ1bm5lciNydW59XG4gKiBAcGFyYW0ge0RvbmVDQn0gW2ZuXSAtIENhbGxiYWNrIGludm9rZWQgd2hlbiB0ZXN0IGV4ZWN1dGlvbiBjb21wbGV0ZWQuXG4gKiBAcmV0dXJucyB7UnVubmVyfSBydW5uZXIgaW5zdGFuY2VcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZXhpdCB3aXRoIG5vbi16ZXJvIHN0YXR1cyBpZiB0aGVyZSB3ZXJlIHRlc3QgZmFpbHVyZXNcbiAqIG1vY2hhLnJ1bihmYWlsdXJlcyA9PiBwcm9jZXNzLmV4aXRDb2RlID0gZmFpbHVyZXMgPyAxIDogMCk7XG4gKi9cbk1vY2hhLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoZm4pIHtcbiAgdGhpcy5fZ3VhcmRSdW5uaW5nU3RhdGVUcmFuc2l0aW9uKCk7XG4gIHRoaXMuX3N0YXRlID0gbW9jaGFTdGF0ZXMuUlVOTklORztcbiAgaWYgKHRoaXMuX3ByZXZpb3VzUnVubmVyKSB7XG4gICAgdGhpcy5fcHJldmlvdXNSdW5uZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuc3VpdGUucmVzZXQoKTtcbiAgfVxuICBpZiAodGhpcy5maWxlcy5sZW5ndGggJiYgIXRoaXMuX2xhenlMb2FkRmlsZXMpIHtcbiAgICB0aGlzLmxvYWRGaWxlcygpO1xuICB9XG4gIHZhciBzdWl0ZSA9IHRoaXMuc3VpdGU7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICBvcHRpb25zLmZpbGVzID0gdGhpcy5maWxlcztcbiAgY29uc3QgcnVubmVyID0gbmV3IHRoaXMuX3J1bm5lckNsYXNzKHN1aXRlLCB7XG4gICAgY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW46IHRoaXMuX2NsZWFuUmVmZXJlbmNlc0FmdGVyUnVuLFxuICAgIGRlbGF5OiBvcHRpb25zLmRlbGF5LFxuICAgIGRyeVJ1bjogb3B0aW9ucy5kcnlSdW4sXG4gICAgZmFpbFplcm86IG9wdGlvbnMuZmFpbFplcm9cbiAgfSk7XG4gIGNyZWF0ZVN0YXRzQ29sbGVjdG9yKHJ1bm5lcik7XG4gIHZhciByZXBvcnRlciA9IG5ldyB0aGlzLl9yZXBvcnRlcihydW5uZXIsIG9wdGlvbnMpO1xuICBydW5uZXIuY2hlY2tMZWFrcyA9IG9wdGlvbnMuY2hlY2tMZWFrcyA9PT0gdHJ1ZTtcbiAgcnVubmVyLmZ1bGxTdGFja1RyYWNlID0gb3B0aW9ucy5mdWxsVHJhY2U7XG4gIHJ1bm5lci5hc3luY09ubHkgPSBvcHRpb25zLmFzeW5jT25seTtcbiAgcnVubmVyLmFsbG93VW5jYXVnaHQgPSBvcHRpb25zLmFsbG93VW5jYXVnaHQ7XG4gIHJ1bm5lci5mb3JiaWRPbmx5ID0gb3B0aW9ucy5mb3JiaWRPbmx5O1xuICBydW5uZXIuZm9yYmlkUGVuZGluZyA9IG9wdGlvbnMuZm9yYmlkUGVuZGluZztcbiAgaWYgKG9wdGlvbnMuZ3JlcCkge1xuICAgIHJ1bm5lci5ncmVwKG9wdGlvbnMuZ3JlcCwgb3B0aW9ucy5pbnZlcnQpO1xuICB9XG4gIGlmIChvcHRpb25zLmdsb2JhbCkge1xuICAgIHJ1bm5lci5nbG9iYWxzKG9wdGlvbnMuZ2xvYmFsKTtcbiAgfVxuICBpZiAob3B0aW9ucy5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwb3J0cy5yZXBvcnRlcnMuQmFzZS51c2VDb2xvcnMgPSBvcHRpb25zLmNvbG9yO1xuICB9XG4gIGV4cG9ydHMucmVwb3J0ZXJzLkJhc2UuaW5saW5lRGlmZnMgPSBvcHRpb25zLmlubGluZURpZmZzO1xuICBleHBvcnRzLnJlcG9ydGVycy5CYXNlLmhpZGVEaWZmID0gIW9wdGlvbnMuZGlmZjtcblxuICBjb25zdCBkb25lID0gZmFpbHVyZXMgPT4ge1xuICAgIHRoaXMuX3ByZXZpb3VzUnVubmVyID0gcnVubmVyO1xuICAgIHRoaXMuX3N0YXRlID0gdGhpcy5fY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW5cbiAgICAgID8gbW9jaGFTdGF0ZXMuUkVGRVJFTkNFU19DTEVBTkVEXG4gICAgICA6IG1vY2hhU3RhdGVzLklOSVQ7XG4gICAgZm4gPSBmbiB8fCB1dGlscy5ub29wO1xuICAgIGlmICh0eXBlb2YgcmVwb3J0ZXIuZG9uZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVwb3J0ZXIuZG9uZShmYWlsdXJlcywgZm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbihmYWlsdXJlcyk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJ1bkFzeW5jID0gYXN5bmMgcnVubmVyID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID1cbiAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVHbG9iYWxTZXR1cCAmJiB0aGlzLmhhc0dsb2JhbFNldHVwRml4dHVyZXMoKVxuICAgICAgICA/IGF3YWl0IHRoaXMucnVuR2xvYmFsU2V0dXAocnVubmVyKVxuICAgICAgICA6IHt9O1xuICAgIGNvbnN0IGZhaWx1cmVDb3VudCA9IGF3YWl0IHJ1bm5lci5ydW5Bc3luYyh7XG4gICAgICBmaWxlczogdGhpcy5maWxlcyxcbiAgICAgIG9wdGlvbnNcbiAgICB9KTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZUdsb2JhbFRlYXJkb3duICYmIHRoaXMuaGFzR2xvYmFsVGVhcmRvd25GaXh0dXJlcygpKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkdsb2JhbFRlYXJkb3duKHJ1bm5lciwge2NvbnRleHR9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhaWx1cmVDb3VudDtcbiAgfTtcblxuICAvLyBubyBcImNhdGNoXCIgaGVyZSBpcyBpbnRlbnRpb25hbC4gZXJyb3JzIGNvbWluZyBvdXQgb2ZcbiAgLy8gUnVubmVyI3J1biBhcmUgY29uc2lkZXJlZCB1bmNhdWdodC91bmhhbmRsZWQgYW5kIGNhdWdodFxuICAvLyBieSB0aGUgYHByb2Nlc3NgIGV2ZW50IGxpc3RlbmVycy5cbiAgLy8gYWxzbzogcmV0dXJuaW5nIGFueXRoaW5nIG90aGVyIHRoYW4gYHJ1bm5lcmAgd291bGQgYmUgYSBicmVha2luZ1xuICAvLyBjaGFuZ2VcbiAgcnVuQXN5bmMocnVubmVyKS50aGVuKGRvbmUpO1xuXG4gIHJldHVybiBydW5uZXI7XG59O1xuXG4vKipcbiAqIEFzc2lnbnMgaG9va3MgdG8gdGhlIHJvb3Qgc3VpdGVcbiAqIEBwYXJhbSB7TW9jaGFSb290SG9va09iamVjdH0gW2hvb2tzXSAtIEhvb2tzIHRvIGFzc2lnbiB0byByb290IHN1aXRlXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5yb290SG9va3MgPSBmdW5jdGlvbiByb290SG9va3Moe1xuICBiZWZvcmVBbGwgPSBbXSxcbiAgYmVmb3JlRWFjaCA9IFtdLFxuICBhZnRlckFsbCA9IFtdLFxuICBhZnRlckVhY2ggPSBbXVxufSA9IHt9KSB7XG4gIGJlZm9yZUFsbCA9IHV0aWxzLmNhc3RBcnJheShiZWZvcmVBbGwpO1xuICBiZWZvcmVFYWNoID0gdXRpbHMuY2FzdEFycmF5KGJlZm9yZUVhY2gpO1xuICBhZnRlckFsbCA9IHV0aWxzLmNhc3RBcnJheShhZnRlckFsbCk7XG4gIGFmdGVyRWFjaCA9IHV0aWxzLmNhc3RBcnJheShhZnRlckVhY2gpO1xuICBiZWZvcmVBbGwuZm9yRWFjaChob29rID0+IHtcbiAgICB0aGlzLnN1aXRlLmJlZm9yZUFsbChob29rKTtcbiAgfSk7XG4gIGJlZm9yZUVhY2guZm9yRWFjaChob29rID0+IHtcbiAgICB0aGlzLnN1aXRlLmJlZm9yZUVhY2goaG9vayk7XG4gIH0pO1xuICBhZnRlckFsbC5mb3JFYWNoKGhvb2sgPT4ge1xuICAgIHRoaXMuc3VpdGUuYWZ0ZXJBbGwoaG9vayk7XG4gIH0pO1xuICBhZnRlckVhY2guZm9yRWFjaChob29rID0+IHtcbiAgICB0aGlzLnN1aXRlLmFmdGVyRWFjaChob29rKTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUb2dnbGVzIHBhcmFsbGVsIG1vZGUuXG4gKlxuICogTXVzdCBiZSBydW4gYmVmb3JlIGNhbGxpbmcge0BsaW5rIE1vY2hhI3J1bn0uIENoYW5nZXMgdGhlIGBSdW5uZXJgIGNsYXNzIHRvXG4gKiB1c2U7IGFsc28gZW5hYmxlcyBsYXp5IGZpbGUgbG9hZGluZyBpZiBub3QgYWxyZWFkeSBkb25lIHNvLlxuICpcbiAqIFdhcm5pbmc6IHdoZW4gcGFzc2VkIGBmYWxzZWAgYW5kIGxhenkgbG9hZGluZyBoYXMgYmVlbiBlbmFibGVkIF92aWEgYW55IG1lYW5zXyAoaW5jbHVkaW5nIGNhbGxpbmcgYHBhcmFsbGVsTW9kZSh0cnVlKWApLCB0aGlzIG1ldGhvZCB3aWxsIF9ub3RfIGRpc2FibGUgbGF6eSBsb2FkaW5nLiBMYXp5IGxvYWRpbmcgaXMgYSBwcmVyZXF1aXNpdGUgZm9yIHBhcmFsbGVsXG4gKiBtb2RlLCBidXQgcGFyYWxsZWwgbW9kZSBpcyBfbm90XyBhIHByZXJlcXVpc2l0ZSBmb3IgbGF6eSBsb2FkaW5nIVxuICogQHBhcmFtIHtib29sZWFufSBbZW5hYmxlXSAtIElmIGB0cnVlYCwgZW5hYmxlOyBvdGhlcndpc2UgZGlzYWJsZS5cbiAqIEB0aHJvd3MgSWYgcnVuIGluIGJyb3dzZXJcbiAqIEB0aHJvd3MgSWYgTW9jaGEgbm90IGluIGBJTklUYCBzdGF0ZVxuICogQHJldHVybnMge01vY2hhfVxuICogQGNoYWluYWJsZVxuICogQHB1YmxpY1xuICovXG5Nb2NoYS5wcm90b3R5cGUucGFyYWxsZWxNb2RlID0gZnVuY3Rpb24gcGFyYWxsZWxNb2RlKGVuYWJsZSA9IHRydWUpIHtcbiAgaWYgKHV0aWxzLmlzQnJvd3NlcigpKSB7XG4gICAgdGhyb3cgY3JlYXRlVW5zdXBwb3J0ZWRFcnJvcigncGFyYWxsZWwgbW9kZSBpcyBvbmx5IHN1cHBvcnRlZCBpbiBOb2RlLmpzJyk7XG4gIH1cbiAgY29uc3QgcGFyYWxsZWwgPSBCb29sZWFuKGVuYWJsZSk7XG4gIGlmIChcbiAgICBwYXJhbGxlbCA9PT0gdGhpcy5vcHRpb25zLnBhcmFsbGVsICYmXG4gICAgdGhpcy5fbGF6eUxvYWRGaWxlcyAmJlxuICAgIHRoaXMuX3J1bm5lckNsYXNzICE9PSBleHBvcnRzLlJ1bm5lclxuICApIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpZiAodGhpcy5fc3RhdGUgIT09IG1vY2hhU3RhdGVzLklOSVQpIHtcbiAgICB0aHJvdyBjcmVhdGVVbnN1cHBvcnRlZEVycm9yKFxuICAgICAgJ2Nhbm5vdCBjaGFuZ2UgcGFyYWxsZWwgbW9kZSBhZnRlciBoYXZpbmcgY2FsbGVkIHJ1bigpJ1xuICAgICk7XG4gIH1cbiAgdGhpcy5vcHRpb25zLnBhcmFsbGVsID0gcGFyYWxsZWw7XG5cbiAgLy8gc3dhcCBSdW5uZXIgY2xhc3NcbiAgdGhpcy5fcnVubmVyQ2xhc3MgPSBwYXJhbGxlbFxuICAgID8gcmVxdWlyZSgnLi9ub2RlanMvcGFyYWxsZWwtYnVmZmVyZWQtcnVubmVyJylcbiAgICA6IGV4cG9ydHMuUnVubmVyO1xuXG4gIC8vIGxhenlMb2FkRmlsZXMgbWF5IGhhdmUgYmVlbiBzZXQgYHRydWVgIG90aGVyd2lzZSAoZm9yIEVTTSBsb2FkaW5nKSxcbiAgLy8gc28ga2VlcCBgdHJ1ZWAgaWYgc28uXG4gIHJldHVybiB0aGlzLmxhenlMb2FkRmlsZXModGhpcy5fbGF6eUxvYWRGaWxlcyB8fCBwYXJhbGxlbCk7XG59O1xuXG4vKipcbiAqIERpc2FibGVzIGltcGxpY2l0IGNhbGwgdG8ge0BsaW5rIE1vY2hhI2xvYWRGaWxlc30gaW4ge0BsaW5rIE1vY2hhI3J1bn0uIFRoaXNcbiAqIHNldHRpbmcgaXMgdXNlZCBieSB3YXRjaCBtb2RlLCBwYXJhbGxlbCBtb2RlLCBhbmQgZm9yIGxvYWRpbmcgRVNNIGZpbGVzLlxuICogQHRvZG8gVGhpcyBzaG91bGQgdGhyb3cgaWYgd2UndmUgYWxyZWFkeSBsb2FkZWQgZmlsZXM7IHN1Y2ggYmVoYXZpb3JcbiAqIG5lY2Vzc2l0YXRlcyBhZGRpbmcgYSBuZXcgc3RhdGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmFibGVdIC0gSWYgYHRydWVgLCBkaXNhYmxlIGVhZ2VyIGxvYWRpbmcgb2YgZmlsZXMgaW5cbiAqIHtAbGluayBNb2NoYSNydW59XG4gKiBAY2hhaW5hYmxlXG4gKiBAcHVibGljXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5sYXp5TG9hZEZpbGVzID0gZnVuY3Rpb24gbGF6eUxvYWRGaWxlcyhlbmFibGUpIHtcbiAgdGhpcy5fbGF6eUxvYWRGaWxlcyA9IGVuYWJsZSA9PT0gdHJ1ZTtcbiAgZGVidWcoJ3NldCBsYXp5IGxvYWQgdG8gJXMnLCBlbmFibGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29uZmlndXJlcyBvbmUgb3IgbW9yZSBnbG9iYWwgc2V0dXAgZml4dHVyZXMuXG4gKlxuICogSWYgZ2l2ZW4gbm8gcGFyYW1ldGVycywgX3Vuc2V0c18gYW55IHByZXZpb3VzbHktc2V0IGZpeHR1cmVzLlxuICogQGNoYWluYWJsZVxuICogQHB1YmxpY1xuICogQHBhcmFtIHtNb2NoYUdsb2JhbEZpeHR1cmV8TW9jaGFHbG9iYWxGaXh0dXJlW119IFtzZXR1cEZuc10gLSBHbG9iYWwgc2V0dXAgZml4dHVyZShzKVxuICogQHJldHVybnMge01vY2hhfVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZ2xvYmFsU2V0dXAgPSBmdW5jdGlvbiBnbG9iYWxTZXR1cChzZXR1cEZucyA9IFtdKSB7XG4gIHNldHVwRm5zID0gdXRpbHMuY2FzdEFycmF5KHNldHVwRm5zKTtcbiAgdGhpcy5vcHRpb25zLmdsb2JhbFNldHVwID0gc2V0dXBGbnM7XG4gIGRlYnVnKCdjb25maWd1cmVkICVkIGdsb2JhbCBzZXR1cCBmdW5jdGlvbnMnLCBzZXR1cEZucy5sZW5ndGgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29uZmlndXJlcyBvbmUgb3IgbW9yZSBnbG9iYWwgdGVhcmRvd24gZml4dHVyZXMuXG4gKlxuICogSWYgZ2l2ZW4gbm8gcGFyYW1ldGVycywgX3Vuc2V0c18gYW55IHByZXZpb3VzbHktc2V0IGZpeHR1cmVzLlxuICogQGNoYWluYWJsZVxuICogQHB1YmxpY1xuICogQHBhcmFtIHtNb2NoYUdsb2JhbEZpeHR1cmV8TW9jaGFHbG9iYWxGaXh0dXJlW119IFt0ZWFyZG93bkZuc10gLSBHbG9iYWwgdGVhcmRvd24gZml4dHVyZShzKVxuICogQHJldHVybnMge01vY2hhfVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZ2xvYmFsVGVhcmRvd24gPSBmdW5jdGlvbiBnbG9iYWxUZWFyZG93bih0ZWFyZG93bkZucyA9IFtdKSB7XG4gIHRlYXJkb3duRm5zID0gdXRpbHMuY2FzdEFycmF5KHRlYXJkb3duRm5zKTtcbiAgdGhpcy5vcHRpb25zLmdsb2JhbFRlYXJkb3duID0gdGVhcmRvd25GbnM7XG4gIGRlYnVnKCdjb25maWd1cmVkICVkIGdsb2JhbCB0ZWFyZG93biBmdW5jdGlvbnMnLCB0ZWFyZG93bkZucy5sZW5ndGgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUnVuIGFueSBnbG9iYWwgc2V0dXAgZml4dHVyZXMgc2VxdWVudGlhbGx5LCBpZiBhbnkuXG4gKlxuICogVGhpcyBpcyBfYXV0b21hdGljYWxseSBjYWxsZWRfIGJ5IHtAbGluayBNb2NoYSNydW59IF91bmxlc3NfIHRoZSBgcnVuR2xvYmFsU2V0dXBgIG9wdGlvbiBpcyBgZmFsc2VgOyBzZWUge0BsaW5rIE1vY2hhI2VuYWJsZUdsb2JhbFNldHVwfS5cbiAqXG4gKiBUaGUgY29udGV4dCBvYmplY3QgdGhpcyBmdW5jdGlvbiByZXNvbHZlcyB3aXRoIHNob3VsZCBiZSBjb25zdW1lZCBieSB7QGxpbmsgTW9jaGEjcnVuR2xvYmFsVGVhcmRvd259LlxuICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSAtIENvbnRleHQgb2JqZWN0IGlmIGFscmVhZHkgaGF2ZSBvbmVcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IENvbnRleHQgb2JqZWN0XG4gKi9cbk1vY2hhLnByb3RvdHlwZS5ydW5HbG9iYWxTZXR1cCA9IGFzeW5jIGZ1bmN0aW9uIHJ1bkdsb2JhbFNldHVwKGNvbnRleHQgPSB7fSkge1xuICBjb25zdCB7Z2xvYmFsU2V0dXB9ID0gdGhpcy5vcHRpb25zO1xuICBpZiAoZ2xvYmFsU2V0dXAgJiYgZ2xvYmFsU2V0dXAubGVuZ3RoKSB7XG4gICAgZGVidWcoJ3J1bigpOiBnbG9iYWwgc2V0dXAgc3RhcnRpbmcnKTtcbiAgICBhd2FpdCB0aGlzLl9ydW5HbG9iYWxGaXh0dXJlcyhnbG9iYWxTZXR1cCwgY29udGV4dCk7XG4gICAgZGVidWcoJ3J1bigpOiBnbG9iYWwgc2V0dXAgY29tcGxldGUnKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbi8qKlxuICogUnVuIGFueSBnbG9iYWwgdGVhcmRvd24gZml4dHVyZXMgc2VxdWVudGlhbGx5LCBpZiBhbnkuXG4gKlxuICogVGhpcyBpcyBfYXV0b21hdGljYWxseSBjYWxsZWRfIGJ5IHtAbGluayBNb2NoYSNydW59IF91bmxlc3NfIHRoZSBgcnVuR2xvYmFsVGVhcmRvd25gIG9wdGlvbiBpcyBgZmFsc2VgOyBzZWUge0BsaW5rIE1vY2hhI2VuYWJsZUdsb2JhbFRlYXJkb3dufS5cbiAqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHdpdGggY29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkge0BsaW5rIE1vY2hhI3J1bkdsb2JhbFNldHVwfSwgaWYgYXBwbGljYWJsZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBDb250ZXh0IG9iamVjdCBpZiBhbHJlYWR5IGhhdmUgb25lXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBDb250ZXh0IG9iamVjdFxuICovXG5Nb2NoYS5wcm90b3R5cGUucnVuR2xvYmFsVGVhcmRvd24gPSBhc3luYyBmdW5jdGlvbiBydW5HbG9iYWxUZWFyZG93bihcbiAgY29udGV4dCA9IHt9XG4pIHtcbiAgY29uc3Qge2dsb2JhbFRlYXJkb3dufSA9IHRoaXMub3B0aW9ucztcbiAgaWYgKGdsb2JhbFRlYXJkb3duICYmIGdsb2JhbFRlYXJkb3duLmxlbmd0aCkge1xuICAgIGRlYnVnKCdydW4oKTogZ2xvYmFsIHRlYXJkb3duIHN0YXJ0aW5nJyk7XG4gICAgYXdhaXQgdGhpcy5fcnVuR2xvYmFsRml4dHVyZXMoZ2xvYmFsVGVhcmRvd24sIGNvbnRleHQpO1xuICB9XG4gIGRlYnVnKCdydW4oKTogZ2xvYmFsIHRlYXJkb3duIGNvbXBsZXRlJyk7XG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuLyoqXG4gKiBSdW4gZ2xvYmFsIGZpeHR1cmVzIHNlcXVlbnRpYWxseSB3aXRoIGNvbnRleHQgYGNvbnRleHRgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtNb2NoYUdsb2JhbEZpeHR1cmVbXX0gW2ZpeHR1cmVGbnNdIC0gRml4dHVyZXMgdG8gcnVuXG4gKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIC0gY29udGV4dCBvYmplY3RcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IGNvbnRleHQgb2JqZWN0XG4gKi9cbk1vY2hhLnByb3RvdHlwZS5fcnVuR2xvYmFsRml4dHVyZXMgPSBhc3luYyBmdW5jdGlvbiBfcnVuR2xvYmFsRml4dHVyZXMoXG4gIGZpeHR1cmVGbnMgPSBbXSxcbiAgY29udGV4dCA9IHt9XG4pIHtcbiAgZm9yIGF3YWl0IChjb25zdCBmaXh0dXJlRm4gb2YgZml4dHVyZUZucykge1xuICAgIGF3YWl0IGZpeHR1cmVGbi5jYWxsKGNvbnRleHQpO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuLyoqXG4gKiBUb2dnbGUgZXhlY3V0aW9uIG9mIGFueSBnbG9iYWwgc2V0dXAgZml4dHVyZShzKVxuICpcbiAqIEBjaGFpbmFibGVcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Ym9vbGVhbiB9IFtlbmFibGVkPXRydWVdIC0gSWYgYGZhbHNlYCwgZG8gbm90IHJ1biBnbG9iYWwgc2V0dXAgZml4dHVyZVxuICogQHJldHVybnMge01vY2hhfVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZW5hYmxlR2xvYmFsU2V0dXAgPSBmdW5jdGlvbiBlbmFibGVHbG9iYWxTZXR1cChlbmFibGVkID0gdHJ1ZSkge1xuICB0aGlzLm9wdGlvbnMuZW5hYmxlR2xvYmFsU2V0dXAgPSBCb29sZWFuKGVuYWJsZWQpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVG9nZ2xlIGV4ZWN1dGlvbiBvZiBhbnkgZ2xvYmFsIHRlYXJkb3duIGZpeHR1cmUocylcbiAqXG4gKiBAY2hhaW5hYmxlXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfSBbZW5hYmxlZD10cnVlXSAtIElmIGBmYWxzZWAsIGRvIG5vdCBydW4gZ2xvYmFsIHRlYXJkb3duIGZpeHR1cmVcbiAqIEByZXR1cm5zIHtNb2NoYX1cbiAqL1xuTW9jaGEucHJvdG90eXBlLmVuYWJsZUdsb2JhbFRlYXJkb3duID0gZnVuY3Rpb24gZW5hYmxlR2xvYmFsVGVhcmRvd24oXG4gIGVuYWJsZWQgPSB0cnVlXG4pIHtcbiAgdGhpcy5vcHRpb25zLmVuYWJsZUdsb2JhbFRlYXJkb3duID0gQm9vbGVhbihlbmFibGVkKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIG9uZSBvciBtb3JlIGdsb2JhbCBzZXR1cCBmaXh0dXJlcyBoYXZlIGJlZW4gc3VwcGxpZWQuXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTW9jaGEucHJvdG90eXBlLmhhc0dsb2JhbFNldHVwRml4dHVyZXMgPSBmdW5jdGlvbiBoYXNHbG9iYWxTZXR1cEZpeHR1cmVzKCkge1xuICByZXR1cm4gQm9vbGVhbih0aGlzLm9wdGlvbnMuZ2xvYmFsU2V0dXAubGVuZ3RoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgb25lIG9yIG1vcmUgZ2xvYmFsIHRlYXJkb3duIGZpeHR1cmVzIGhhdmUgYmVlbiBzdXBwbGllZC5cbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Nb2NoYS5wcm90b3R5cGUuaGFzR2xvYmFsVGVhcmRvd25GaXh0dXJlcyA9XG4gIGZ1bmN0aW9uIGhhc0dsb2JhbFRlYXJkb3duRml4dHVyZXMoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5vcHRpb25zLmdsb2JhbFRlYXJkb3duLmxlbmd0aCk7XG4gIH07XG5cbi8qKlxuICogQW4gYWx0ZXJuYXRpdmUgd2F5IHRvIGRlZmluZSByb290IGhvb2tzIHRoYXQgd29ya3Mgd2l0aCBwYXJhbGxlbCBydW5zLlxuICogQHR5cGVkZWYge09iamVjdH0gTW9jaGFSb290SG9va09iamVjdFxuICogQHByb3BlcnR5IHtGdW5jdGlvbnxGdW5jdGlvbltdfSBbYmVmb3JlQWxsXSAtIFwiQmVmb3JlIGFsbFwiIGhvb2socylcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb258RnVuY3Rpb25bXX0gW2JlZm9yZUVhY2hdIC0gXCJCZWZvcmUgZWFjaFwiIGhvb2socylcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb258RnVuY3Rpb25bXX0gW2FmdGVyQWxsXSAtIFwiQWZ0ZXIgYWxsXCIgaG9vayhzKVxuICogQHByb3BlcnR5IHtGdW5jdGlvbnxGdW5jdGlvbltdfSBbYWZ0ZXJFYWNoXSAtIFwiQWZ0ZXIgZWFjaFwiIGhvb2socylcbiAqL1xuXG4vKipcbiAqIEFuIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHtAbGluayBNb2NoYVJvb3RIb29rT2JqZWN0fSwgZWl0aGVyIHN5bmMgb3IgYXN5bmMuXG4gICBAY2FsbGJhY2sgTW9jaGFSb290SG9va0Z1bmN0aW9uXG4gKiBAcmV0dXJucyB7TW9jaGFSb290SG9va09iamVjdHxQcm9taXNlPE1vY2hhUm9vdEhvb2tPYmplY3Q+fVxuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0J3MgaW52b2tlZCBfb25jZV8gd2hpY2ggaXMgZWl0aGVyIHN5bmMgb3IgYXN5bmMuXG4gKiBDYW4gYmUgYSBcInRlYXJkb3duXCIgb3IgXCJzZXR1cFwiLiAgVGhlc2Ugd2lsbCBhbGwgc2hhcmUgdGhlIHNhbWUgY29udGV4dC5cbiAqIEBjYWxsYmFjayBNb2NoYUdsb2JhbEZpeHR1cmVcbiAqIEByZXR1cm5zIHt2b2lkfFByb21pc2U8dm9pZD59XG4gKi9cblxuLyoqXG4gKiBBbiBvYmplY3QgbWFraW5nIHVwIGFsbCBuZWNlc3NhcnkgcGFydHMgb2YgYSBwbHVnaW4gbG9hZGVyIGFuZCBhZ2dyZWdhdG9yXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQbHVnaW5EZWZpbml0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZXhwb3J0TmFtZSAtIE5hbWVkIGV4cG9ydCB0byB1c2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9uTmFtZV0gLSBPcHRpb24gbmFtZSBmb3IgTW9jaGEgY29uc3RydWN0b3IgKHVzZSBgZXhwb3J0TmFtZWAgaWYgb21pdHRlZClcbiAqIEBwcm9wZXJ0eSB7UGx1Z2luVmFsaWRhdG9yfSBbdmFsaWRhdGVdIC0gVmFsaWRhdG9yIGZ1bmN0aW9uXG4gKiBAcHJvcGVydHkge1BsdWdpbkZpbmFsaXplcn0gW2ZpbmFsaXplXSAtIEZpbmFsaXplci9hZ2dyZWdhdG9yIGZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIChzeW5jKSBmdW5jdGlvbiB0byBhc3NlcnQgYSB1c2VyLXN1cHBsaWVkIHBsdWdpbiBpbXBsZW1lbnRhdGlvbiBpcyB2YWxpZC5cbiAqXG4gKiBEZWZpbmVkIGluIGEge0BsaW5rIFBsdWdpbkRlZmluaXRpb259LlxuXG4gKiBAY2FsbGJhY2sgUGx1Z2luVmFsaWRhdG9yXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2tcbiAqIEB0aGlzIHtQbHVnaW5EZWZpbml0aW9ufVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGZpbmFsaXplIHBsdWdpbnMgaW1wbHMgb2YgYSBwYXJ0aWN1bGFyIGlsa1xuICogQGNhbGxiYWNrIFBsdWdpbkZpbmFsaXplclxuICogQHBhcmFtIHtBcnJheTwqPn0gaW1wbHMgLSBVc2VyLXN1cHBsaWVkIGltcGxlbWVudGF0aW9uc1xuICogQHJldHVybnMge1Byb21pc2U8Kj58Kn1cbiAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiBAbW9kdWxlIFBlbmRpbmdcbiovXG5cbm1vZHVsZS5leHBvcnRzID0gUGVuZGluZztcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBQZW5kaW5nYCBlcnJvciB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIFBlbmRpbmcobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIEJhc2VcbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBkaWZmID0gcmVxdWlyZSgnZGlmZicpO1xudmFyIG1pbGxpc2Vjb25kcyA9IHJlcXVpcmUoJ21zJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xudmFyIHN5bWJvbHMgPSByZXF1aXJlKCdsb2ctc3ltYm9scycpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL3J1bm5lcicpLmNvbnN0YW50cztcbnZhciBFVkVOVF9URVNUX1BBU1MgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9QQVNTO1xudmFyIEVWRU5UX1RFU1RfRkFJTCA9IGNvbnN0YW50cy5FVkVOVF9URVNUX0ZBSUw7XG5cbmNvbnN0IGlzQnJvd3NlciA9IHV0aWxzLmlzQnJvd3NlcigpO1xuXG5mdW5jdGlvbiBnZXRCcm93c2VyV2luZG93U2l6ZSgpIHtcbiAgaWYgKCdpbm5lckhlaWdodCcgaW4gZ2xvYmFsKSB7XG4gICAgcmV0dXJuIFtnbG9iYWwuaW5uZXJIZWlnaHQsIGdsb2JhbC5pbm5lcldpZHRoXTtcbiAgfVxuICAvLyBJbiBhIFdlYiBXb3JrZXIsIHRoZSBET00gV2luZG93IGlzIG5vdCBhdmFpbGFibGUuXG4gIHJldHVybiBbNjQwLCA0ODBdO1xufVxuXG4vKipcbiAqIEV4cG9zZSBgQmFzZWAuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQmFzZTtcblxuLyoqXG4gKiBDaGVjayBpZiBib3RoIHN0ZGlvIHN0cmVhbXMgYXJlIGFzc29jaWF0ZWQgd2l0aCBhIHR0eS5cbiAqL1xuXG52YXIgaXNhdHR5ID0gaXNCcm93c2VyIHx8IChwcm9jZXNzLnN0ZG91dC5pc1RUWSAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSk7XG5cbi8qKlxuICogU2F2ZSBsb2cgcmVmZXJlbmNlcyB0byBhdm9pZCB0ZXN0cyBpbnRlcmZlcmluZyAoc2VlIEdILTM2MDQpLlxuICovXG52YXIgY29uc29sZUxvZyA9IGNvbnNvbGUubG9nO1xuXG4vKipcbiAqIEVuYWJsZSBjb2xvcmluZyBieSBkZWZhdWx0LCBleGNlcHQgaW4gdGhlIGJyb3dzZXIgaW50ZXJmYWNlLlxuICovXG5cbmV4cG9ydHMudXNlQ29sb3JzID1cbiAgIWlzQnJvd3NlciAmJlxuICAoc3VwcG9ydHNDb2xvci5zdGRvdXQgfHwgcHJvY2Vzcy5lbnYuTU9DSEFfQ09MT1JTICE9PSB1bmRlZmluZWQpO1xuXG4vKipcbiAqIElubGluZSBkaWZmcyBpbnN0ZWFkIG9mICsvLVxuICovXG5cbmV4cG9ydHMuaW5saW5lRGlmZnMgPSBmYWxzZTtcblxuLyoqXG4gKiBUcnVuY2F0ZSBkaWZmcyBsb25nZXIgdGhhbiB0aGlzIHZhbHVlIHRvIGF2b2lkIHNsb3cgcGVyZm9ybWFuY2VcbiAqL1xuZXhwb3J0cy5tYXhEaWZmU2l6ZSA9IDgxOTI7XG5cbi8qKlxuICogRGVmYXVsdCBjb2xvciBtYXAuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSB7XG4gIHBhc3M6IDkwLFxuICBmYWlsOiAzMSxcbiAgJ2JyaWdodCBwYXNzJzogOTIsXG4gICdicmlnaHQgZmFpbCc6IDkxLFxuICAnYnJpZ2h0IHllbGxvdyc6IDkzLFxuICBwZW5kaW5nOiAzNixcbiAgc3VpdGU6IDAsXG4gICdlcnJvciB0aXRsZSc6IDAsXG4gICdlcnJvciBtZXNzYWdlJzogMzEsXG4gICdlcnJvciBzdGFjayc6IDkwLFxuICBjaGVja21hcms6IDMyLFxuICBmYXN0OiA5MCxcbiAgbWVkaXVtOiAzMyxcbiAgc2xvdzogMzEsXG4gIGdyZWVuOiAzMixcbiAgbGlnaHQ6IDkwLFxuICAnZGlmZiBndXR0ZXInOiA5MCxcbiAgJ2RpZmYgYWRkZWQnOiAzMixcbiAgJ2RpZmYgcmVtb3ZlZCc6IDMxLFxuICAnZGlmZiBhZGRlZCBpbmxpbmUnOiAnMzA7NDInLFxuICAnZGlmZiByZW1vdmVkIGlubGluZSc6ICczMDs0MSdcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzeW1ib2wgbWFwLlxuICovXG5cbmV4cG9ydHMuc3ltYm9scyA9IHtcbiAgb2s6IHN5bWJvbHMuc3VjY2VzcyxcbiAgZXJyOiBzeW1ib2xzLmVycm9yLFxuICBkb3Q6ICcuJyxcbiAgY29tbWE6ICcsJyxcbiAgYmFuZzogJyEnXG59O1xuXG4vKipcbiAqIENvbG9yIGBzdHJgIHdpdGggdGhlIGdpdmVuIGB0eXBlYCxcbiAqIGFsbG93aW5nIGNvbG9ycyB0byBiZSBkaXNhYmxlZCxcbiAqIGFzIHdlbGwgYXMgdXNlci1kZWZpbmVkIGNvbG9yXG4gKiBzY2hlbWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG52YXIgY29sb3IgPSAoZXhwb3J0cy5jb2xvciA9IGZ1bmN0aW9uICh0eXBlLCBzdHIpIHtcbiAgaWYgKCFleHBvcnRzLnVzZUNvbG9ycykge1xuICAgIHJldHVybiBTdHJpbmcoc3RyKTtcbiAgfVxuICByZXR1cm4gJ1xcdTAwMWJbJyArIGV4cG9ydHMuY29sb3JzW3R5cGVdICsgJ20nICsgc3RyICsgJ1xcdTAwMWJbMG0nO1xufSk7XG5cbi8qKlxuICogRXhwb3NlIHRlcm0gd2luZG93IHNpemUsIHdpdGggc29tZSBkZWZhdWx0cyBmb3Igd2hlbiBzdGRlcnIgaXMgbm90IGEgdHR5LlxuICovXG5cbmV4cG9ydHMud2luZG93ID0ge1xuICB3aWR0aDogNzVcbn07XG5cbmlmIChpc2F0dHkpIHtcbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgIGV4cG9ydHMud2luZG93LndpZHRoID0gZ2V0QnJvd3NlcldpbmRvd1NpemUoKVsxXTtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLndpbmRvdy53aWR0aCA9IHByb2Nlc3Muc3Rkb3V0LmdldFdpbmRvd1NpemUoMSlbMF07XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2Ugc29tZSBiYXNpYyBjdXJzb3IgaW50ZXJhY3Rpb25zIHRoYXQgYXJlIGNvbW1vbiBhbW9uZyByZXBvcnRlcnMuXG4gKi9cblxuZXhwb3J0cy5jdXJzb3IgPSB7XG4gIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcdTAwMWJbPzI1bCcpO1xuICB9LFxuXG4gIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcdTAwMWJbPzI1aCcpO1xuICB9LFxuXG4gIGRlbGV0ZUxpbmU6IGZ1bmN0aW9uICgpIHtcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcdTAwMWJbMksnKTtcbiAgfSxcblxuICBiZWdpbm5pbmdPZkxpbmU6IGZ1bmN0aW9uICgpIHtcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcdTAwMWJbMEcnKTtcbiAgfSxcblxuICBDUjogZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc2F0dHkpIHtcbiAgICAgIGV4cG9ydHMuY3Vyc29yLmRlbGV0ZUxpbmUoKTtcbiAgICAgIGV4cG9ydHMuY3Vyc29yLmJlZ2lubmluZ09mTGluZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxyJyk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2hvd0RpZmYgPSAoZXhwb3J0cy5zaG93RGlmZiA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgcmV0dXJuIChcbiAgICBlcnIgJiZcbiAgICBlcnIuc2hvd0RpZmYgIT09IGZhbHNlICYmXG4gICAgc2FtZVR5cGUoZXJyLmFjdHVhbCwgZXJyLmV4cGVjdGVkKSAmJlxuICAgIGVyci5leHBlY3RlZCAhPT0gdW5kZWZpbmVkXG4gICk7XG59KTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5RGlmZk9ianMoZXJyKSB7XG4gIGlmICghdXRpbHMuaXNTdHJpbmcoZXJyLmFjdHVhbCkgfHwgIXV0aWxzLmlzU3RyaW5nKGVyci5leHBlY3RlZCkpIHtcbiAgICBlcnIuYWN0dWFsID0gdXRpbHMuc3RyaW5naWZ5KGVyci5hY3R1YWwpO1xuICAgIGVyci5leHBlY3RlZCA9IHV0aWxzLnN0cmluZ2lmeShlcnIuZXhwZWN0ZWQpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGRpZmYgYmV0d2VlbiAyIHN0cmluZ3Mgd2l0aCBjb2xvdXJlZCBBTlNJIG91dHB1dC5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBkaWZmIHdpbGwgYmUgZWl0aGVyIGlubGluZSBvciB1bmlmaWVkIGRlcGVuZGVudCBvbiB0aGUgdmFsdWVcbiAqIG9mIGBCYXNlLmlubGluZURpZmZgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3R1YWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZFxuICogQHJldHVybiB7c3RyaW5nfSBEaWZmXG4gKi9cblxudmFyIGdlbmVyYXRlRGlmZiA9IChleHBvcnRzLmdlbmVyYXRlRGlmZiA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIHRyeSB7XG4gICAgdmFyIG1heExlbiA9IGV4cG9ydHMubWF4RGlmZlNpemU7XG4gICAgdmFyIHNraXBwZWQgPSAwO1xuICAgIGlmIChtYXhMZW4gPiAwKSB7XG4gICAgICBza2lwcGVkID0gTWF0aC5tYXgoYWN0dWFsLmxlbmd0aCAtIG1heExlbiwgZXhwZWN0ZWQubGVuZ3RoIC0gbWF4TGVuKTtcbiAgICAgIGFjdHVhbCA9IGFjdHVhbC5zbGljZSgwLCBtYXhMZW4pO1xuICAgICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5zbGljZSgwLCBtYXhMZW4pO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gZXhwb3J0cy5pbmxpbmVEaWZmc1xuICAgICAgPyBpbmxpbmVEaWZmKGFjdHVhbCwgZXhwZWN0ZWQpXG4gICAgICA6IHVuaWZpZWREaWZmKGFjdHVhbCwgZXhwZWN0ZWQpO1xuICAgIGlmIChza2lwcGVkID4gMCkge1xuICAgICAgcmVzdWx0ID0gYCR7cmVzdWx0fVxcbiAgICAgIFttb2NoYV0gb3V0cHV0IHRydW5jYXRlZCB0byAke21heExlbn0gY2hhcmFjdGVycywgc2VlIFwibWF4RGlmZlNpemVcIiByZXBvcnRlci1vcHRpb25cXG5gO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB2YXIgbXNnID1cbiAgICAgICdcXG4gICAgICAnICtcbiAgICAgIGNvbG9yKCdkaWZmIGFkZGVkJywgJysgZXhwZWN0ZWQnKSArXG4gICAgICAnICcgK1xuICAgICAgY29sb3IoJ2RpZmYgcmVtb3ZlZCcsICctIGFjdHVhbDogIGZhaWxlZCB0byBnZW5lcmF0ZSBNb2NoYSBkaWZmJykgK1xuICAgICAgJ1xcbic7XG4gICAgcmV0dXJuIG1zZztcbiAgfVxufSk7XG5cbi8qKlxuICogT3V0cHV0cyB0aGUgZ2l2ZW4gYGZhaWx1cmVzYCBhcyBhIGxpc3QuXG4gKlxuICogQHB1YmxpY1xuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVycy5CYXNlXG4gKiBAdmFyaWF0aW9uIDFcbiAqIEBwYXJhbSB7T2JqZWN0W119IGZhaWx1cmVzIC0gRWFjaCBpcyBUZXN0IGluc3RhbmNlIHdpdGggY29ycmVzcG9uZGluZ1xuICogICAgIEVycm9yIHByb3BlcnR5XG4gKi9cbmV4cG9ydHMubGlzdCA9IGZ1bmN0aW9uIChmYWlsdXJlcykge1xuICB2YXIgbXVsdGlwbGVFcnIsIG11bHRpcGxlVGVzdDtcbiAgQmFzZS5jb25zb2xlTG9nKCk7XG4gIGZhaWx1cmVzLmZvckVhY2goZnVuY3Rpb24gKHRlc3QsIGkpIHtcbiAgICAvLyBmb3JtYXRcbiAgICB2YXIgZm10ID1cbiAgICAgIGNvbG9yKCdlcnJvciB0aXRsZScsICcgICVzKSAlczpcXG4nKSArXG4gICAgICBjb2xvcignZXJyb3IgbWVzc2FnZScsICcgICAgICVzJykgK1xuICAgICAgY29sb3IoJ2Vycm9yIHN0YWNrJywgJ1xcbiVzXFxuJyk7XG5cbiAgICAvLyBtc2dcbiAgICB2YXIgbXNnO1xuICAgIHZhciBlcnI7XG4gICAgaWYgKHRlc3QuZXJyICYmIHRlc3QuZXJyLm11bHRpcGxlKSB7XG4gICAgICBpZiAobXVsdGlwbGVUZXN0ICE9PSB0ZXN0KSB7XG4gICAgICAgIG11bHRpcGxlVGVzdCA9IHRlc3Q7XG4gICAgICAgIG11bHRpcGxlRXJyID0gW3Rlc3QuZXJyXS5jb25jYXQodGVzdC5lcnIubXVsdGlwbGUpO1xuICAgICAgfVxuICAgICAgZXJyID0gbXVsdGlwbGVFcnIuc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyID0gdGVzdC5lcnI7XG4gICAgfVxuICAgIHZhciBtZXNzYWdlO1xuICAgIGlmICh0eXBlb2YgZXJyLmluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1lc3NhZ2UgPSBlcnIuaW5zcGVjdCgpICsgJyc7XG4gICAgfSBlbHNlIGlmIChlcnIubWVzc2FnZSAmJiB0eXBlb2YgZXJyLm1lc3NhZ2UudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1lc3NhZ2UgPSBlcnIubWVzc2FnZSArICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlID0gJyc7XG4gICAgfVxuICAgIHZhciBzdGFjayA9IGVyci5zdGFjayB8fCBtZXNzYWdlO1xuICAgIHZhciBpbmRleCA9IG1lc3NhZ2UgPyBzdGFjay5pbmRleE9mKG1lc3NhZ2UpIDogLTE7XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICBtc2cgPSBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCArPSBtZXNzYWdlLmxlbmd0aDtcbiAgICAgIG1zZyA9IHN0YWNrLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgIC8vIHJlbW92ZSBtc2cgZnJvbSBzdGFja1xuICAgICAgc3RhY2sgPSBzdGFjay5zbGljZShpbmRleCArIDEpO1xuICAgIH1cblxuICAgIC8vIHVuY2F1Z2h0XG4gICAgaWYgKGVyci51bmNhdWdodCkge1xuICAgICAgbXNnID0gJ1VuY2F1Z2h0ICcgKyBtc2c7XG4gICAgfVxuICAgIC8vIGV4cGxpY2l0bHkgc2hvdyBkaWZmXG4gICAgaWYgKCFleHBvcnRzLmhpZGVEaWZmICYmIHNob3dEaWZmKGVycikpIHtcbiAgICAgIHN0cmluZ2lmeURpZmZPYmpzKGVycik7XG4gICAgICBmbXQgPVxuICAgICAgICBjb2xvcignZXJyb3IgdGl0bGUnLCAnICAlcykgJXM6XFxuJXMnKSArIGNvbG9yKCdlcnJvciBzdGFjaycsICdcXG4lc1xcbicpO1xuICAgICAgdmFyIG1hdGNoID0gbWVzc2FnZS5tYXRjaCgvXihbXjpdKyk6IGV4cGVjdGVkLyk7XG4gICAgICBtc2cgPSAnXFxuICAgICAgJyArIGNvbG9yKCdlcnJvciBtZXNzYWdlJywgbWF0Y2ggPyBtYXRjaFsxXSA6IG1zZyk7XG5cbiAgICAgIG1zZyArPSBnZW5lcmF0ZURpZmYoZXJyLmFjdHVhbCwgZXJyLmV4cGVjdGVkKTtcbiAgICB9XG5cbiAgICAvLyBpbmRlbnQgc3RhY2sgdHJhY2VcbiAgICBzdGFjayA9IHN0YWNrLnJlcGxhY2UoL14vZ20sICcgICcpO1xuXG4gICAgLy8gaW5kZW50ZWQgdGVzdCB0aXRsZVxuICAgIHZhciB0ZXN0VGl0bGUgPSAnJztcbiAgICB0ZXN0LnRpdGxlUGF0aCgpLmZvckVhY2goZnVuY3Rpb24gKHN0ciwgaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICB0ZXN0VGl0bGUgKz0gJ1xcbiAgICAgJztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICB0ZXN0VGl0bGUgKz0gJyAgJztcbiAgICAgIH1cbiAgICAgIHRlc3RUaXRsZSArPSBzdHI7XG4gICAgfSk7XG5cbiAgICBCYXNlLmNvbnNvbGVMb2coZm10LCBpICsgMSwgdGVzdFRpdGxlLCBtc2csIHN0YWNrKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYEJhc2VgIHJlcG9ydGVyIGluc3RhbmNlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQWxsIG90aGVyIHJlcG9ydGVycyBnZW5lcmFsbHkgaW5oZXJpdCBmcm9tIHRoaXMgcmVwb3J0ZXIuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyIC0gSW5zdGFuY2UgdHJpZ2dlcnMgcmVwb3J0ZXIgYWN0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBydW5uZXIgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBCYXNlKHJ1bm5lciwgb3B0aW9ucykge1xuICB2YXIgZmFpbHVyZXMgPSAodGhpcy5mYWlsdXJlcyA9IFtdKTtcblxuICBpZiAoIXJ1bm5lcikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgcnVubmVyIGFyZ3VtZW50Jyk7XG4gIH1cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5ydW5uZXIgPSBydW5uZXI7XG4gIHRoaXMuc3RhdHMgPSBydW5uZXIuc3RhdHM7IC8vIGFzc2lnbmVkIHNvIFJlcG9ydGVycyBrZWVwIGEgY2xvc2VyIHJlZmVyZW5jZVxuXG4gIHZhciBtYXhEaWZmU2l6ZU9wdCA9XG4gICAgdGhpcy5vcHRpb25zLnJlcG9ydGVyT3B0aW9uICYmIHRoaXMub3B0aW9ucy5yZXBvcnRlck9wdGlvbi5tYXhEaWZmU2l6ZTtcbiAgaWYgKG1heERpZmZTaXplT3B0ICE9PSB1bmRlZmluZWQgJiYgIWlzTmFOKE51bWJlcihtYXhEaWZmU2l6ZU9wdCkpKSB7XG4gICAgZXhwb3J0cy5tYXhEaWZmU2l6ZSA9IE51bWJlcihtYXhEaWZmU2l6ZU9wdCk7XG4gIH1cblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9QQVNTLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIGlmICh0ZXN0LmR1cmF0aW9uID4gdGVzdC5zbG93KCkpIHtcbiAgICAgIHRlc3Quc3BlZWQgPSAnc2xvdyc7XG4gICAgfSBlbHNlIGlmICh0ZXN0LmR1cmF0aW9uID4gdGVzdC5zbG93KCkgLyAyKSB7XG4gICAgICB0ZXN0LnNwZWVkID0gJ21lZGl1bSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlc3Quc3BlZWQgPSAnZmFzdCc7XG4gICAgfVxuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9GQUlMLCBmdW5jdGlvbiAodGVzdCwgZXJyKSB7XG4gICAgaWYgKHNob3dEaWZmKGVycikpIHtcbiAgICAgIHN0cmluZ2lmeURpZmZPYmpzKGVycik7XG4gICAgfVxuICAgIC8vIG1vcmUgdGhhbiBvbmUgZXJyb3IgcGVyIHRlc3RcbiAgICBpZiAodGVzdC5lcnIgJiYgZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRlc3QuZXJyLm11bHRpcGxlID0gKHRlc3QuZXJyLm11bHRpcGxlIHx8IFtdKS5jb25jYXQoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGVzdC5lcnIgPSBlcnI7XG4gICAgfVxuICAgIGZhaWx1cmVzLnB1c2godGVzdCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIE91dHB1dHMgY29tbW9uIGVwaWxvZ3VlIHVzZWQgYnkgbWFueSBvZiB0aGUgYnVuZGxlZCByZXBvcnRlcnMuXG4gKlxuICogQHB1YmxpY1xuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xuICovXG5CYXNlLnByb3RvdHlwZS5lcGlsb2d1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgdmFyIGZtdDtcblxuICBCYXNlLmNvbnNvbGVMb2coKTtcblxuICAvLyBwYXNzZXNcbiAgZm10ID1cbiAgICBjb2xvcignYnJpZ2h0IHBhc3MnLCAnICcpICtcbiAgICBjb2xvcignZ3JlZW4nLCAnICVkIHBhc3NpbmcnKSArXG4gICAgY29sb3IoJ2xpZ2h0JywgJyAoJXMpJyk7XG5cbiAgQmFzZS5jb25zb2xlTG9nKGZtdCwgc3RhdHMucGFzc2VzIHx8IDAsIG1pbGxpc2Vjb25kcyhzdGF0cy5kdXJhdGlvbikpO1xuXG4gIC8vIHBlbmRpbmdcbiAgaWYgKHN0YXRzLnBlbmRpbmcpIHtcbiAgICBmbXQgPSBjb2xvcigncGVuZGluZycsICcgJykgKyBjb2xvcigncGVuZGluZycsICcgJWQgcGVuZGluZycpO1xuXG4gICAgQmFzZS5jb25zb2xlTG9nKGZtdCwgc3RhdHMucGVuZGluZyk7XG4gIH1cblxuICAvLyBmYWlsdXJlc1xuICBpZiAoc3RhdHMuZmFpbHVyZXMpIHtcbiAgICBmbXQgPSBjb2xvcignZmFpbCcsICcgICVkIGZhaWxpbmcnKTtcblxuICAgIEJhc2UuY29uc29sZUxvZyhmbXQsIHN0YXRzLmZhaWx1cmVzKTtcblxuICAgIEJhc2UubGlzdCh0aGlzLmZhaWx1cmVzKTtcbiAgICBCYXNlLmNvbnNvbGVMb2coKTtcbiAgfVxuXG4gIEJhc2UuY29uc29sZUxvZygpO1xufTtcblxuLyoqXG4gKiBQYWRzIHRoZSBnaXZlbiBgc3RyYCB0byBgbGVuYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtzdHJpbmd9IGxlblxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBwYWQoc3RyLCBsZW4pIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIHJldHVybiBBcnJheShsZW4gLSBzdHIubGVuZ3RoICsgMSkuam9pbignICcpICsgc3RyO1xufVxuXG4vKipcbiAqIFJldHVybnMgaW5saW5lIGRpZmYgYmV0d2VlbiAyIHN0cmluZ3Mgd2l0aCBjb2xvdXJlZCBBTlNJIG91dHB1dC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IGFjdHVhbFxuICogQHBhcmFtIHtTdHJpbmd9IGV4cGVjdGVkXG4gKiBAcmV0dXJuIHtzdHJpbmd9IERpZmZcbiAqL1xuZnVuY3Rpb24gaW5saW5lRGlmZihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIHZhciBtc2cgPSBlcnJvckRpZmYoYWN0dWFsLCBleHBlY3RlZCk7XG5cbiAgLy8gbGluZW5vc1xuICB2YXIgbGluZXMgPSBtc2cuc3BsaXQoJ1xcbicpO1xuICBpZiAobGluZXMubGVuZ3RoID4gNCkge1xuICAgIHZhciB3aWR0aCA9IFN0cmluZyhsaW5lcy5sZW5ndGgpLmxlbmd0aDtcbiAgICBtc2cgPSBsaW5lc1xuICAgICAgLm1hcChmdW5jdGlvbiAoc3RyLCBpKSB7XG4gICAgICAgIHJldHVybiBwYWQoKytpLCB3aWR0aCkgKyAnIHwnICsgJyAnICsgc3RyO1xuICAgICAgfSlcbiAgICAgIC5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIC8vIGxlZ2VuZFxuICBtc2cgPVxuICAgICdcXG4nICtcbiAgICBjb2xvcignZGlmZiByZW1vdmVkIGlubGluZScsICdhY3R1YWwnKSArXG4gICAgJyAnICtcbiAgICBjb2xvcignZGlmZiBhZGRlZCBpbmxpbmUnLCAnZXhwZWN0ZWQnKSArXG4gICAgJ1xcblxcbicgK1xuICAgIG1zZyArXG4gICAgJ1xcbic7XG5cbiAgLy8gaW5kZW50XG4gIG1zZyA9IG1zZy5yZXBsYWNlKC9eL2dtLCAnICAgICAgJyk7XG4gIHJldHVybiBtc2c7XG59XG5cbi8qKlxuICogUmV0dXJucyB1bmlmaWVkIGRpZmYgYmV0d2VlbiB0d28gc3RyaW5ncyB3aXRoIGNvbG91cmVkIEFOU0kgb3V0cHV0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0dWFsXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwZWN0ZWRcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGRpZmYuXG4gKi9cbmZ1bmN0aW9uIHVuaWZpZWREaWZmKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgdmFyIGluZGVudCA9ICcgICAgICAnO1xuICBmdW5jdGlvbiBjbGVhblVwKGxpbmUpIHtcbiAgICBpZiAobGluZVswXSA9PT0gJysnKSB7XG4gICAgICByZXR1cm4gaW5kZW50ICsgY29sb3JMaW5lcygnZGlmZiBhZGRlZCcsIGxpbmUpO1xuICAgIH1cbiAgICBpZiAobGluZVswXSA9PT0gJy0nKSB7XG4gICAgICByZXR1cm4gaW5kZW50ICsgY29sb3JMaW5lcygnZGlmZiByZW1vdmVkJywgbGluZSk7XG4gICAgfVxuICAgIGlmIChsaW5lLm1hdGNoKC9AQC8pKSB7XG4gICAgICByZXR1cm4gJy0tJztcbiAgICB9XG4gICAgaWYgKGxpbmUubWF0Y2goL1xcXFwgTm8gbmV3bGluZS8pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGluZGVudCArIGxpbmU7XG4gIH1cbiAgZnVuY3Rpb24gbm90QmxhbmsobGluZSkge1xuICAgIHJldHVybiB0eXBlb2YgbGluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbGluZSAhPT0gbnVsbDtcbiAgfVxuICB2YXIgbXNnID0gZGlmZi5jcmVhdGVQYXRjaCgnc3RyaW5nJywgYWN0dWFsLCBleHBlY3RlZCk7XG4gIHZhciBsaW5lcyA9IG1zZy5zcGxpdCgnXFxuJykuc3BsaWNlKDUpO1xuICByZXR1cm4gKFxuICAgICdcXG4gICAgICAnICtcbiAgICBjb2xvckxpbmVzKCdkaWZmIGFkZGVkJywgJysgZXhwZWN0ZWQnKSArXG4gICAgJyAnICtcbiAgICBjb2xvckxpbmVzKCdkaWZmIHJlbW92ZWQnLCAnLSBhY3R1YWwnKSArXG4gICAgJ1xcblxcbicgK1xuICAgIGxpbmVzLm1hcChjbGVhblVwKS5maWx0ZXIobm90QmxhbmspLmpvaW4oJ1xcbicpXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyBjaGFyYWN0ZXIgZGlmZiBmb3IgYGVycmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3R1YWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBlY3RlZFxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZGlmZlxuICovXG5mdW5jdGlvbiBlcnJvckRpZmYoYWN0dWFsLCBleHBlY3RlZCkge1xuICByZXR1cm4gZGlmZlxuICAgIC5kaWZmV29yZHNXaXRoU3BhY2UoYWN0dWFsLCBleHBlY3RlZClcbiAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIGlmIChzdHIuYWRkZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yTGluZXMoJ2RpZmYgYWRkZWQgaW5saW5lJywgc3RyLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIucmVtb3ZlZCkge1xuICAgICAgICByZXR1cm4gY29sb3JMaW5lcygnZGlmZiByZW1vdmVkIGlubGluZScsIHN0ci52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyLnZhbHVlO1xuICAgIH0pXG4gICAgLmpvaW4oJycpO1xufVxuXG4vKipcbiAqIENvbG9ycyBsaW5lcyBmb3IgYHN0cmAsIHVzaW5nIHRoZSBjb2xvciBgbmFtZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNvbG9yTGluZXMobmFtZSwgc3RyKSB7XG4gIHJldHVybiBzdHJcbiAgICAuc3BsaXQoJ1xcbicpXG4gICAgLm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gY29sb3IobmFtZSwgc3RyKTtcbiAgICB9KVxuICAgIC5qb2luKCdcXG4nKTtcbn1cblxuLyoqXG4gKiBPYmplY3QjdG9TdHJpbmcgcmVmZXJlbmNlLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyB0aGF0IGEgLyBiIGhhdmUgdGhlIHNhbWUgdHlwZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBzYW1lVHlwZShhLCBiKSB7XG4gIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKGEpID09PSBvYmpUb1N0cmluZy5jYWxsKGIpO1xufVxuXG5CYXNlLmNvbnNvbGVMb2cgPSBjb25zb2xlTG9nO1xuXG5CYXNlLmFic3RyYWN0ID0gdHJ1ZTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBEb2NcbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL3J1bm5lcicpLmNvbnN0YW50cztcbnZhciBFVkVOVF9URVNUX1BBU1MgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9QQVNTO1xudmFyIEVWRU5UX1RFU1RfRkFJTCA9IGNvbnN0YW50cy5FVkVOVF9URVNUX0ZBSUw7XG52YXIgRVZFTlRfU1VJVEVfQkVHSU4gPSBjb25zdGFudHMuRVZFTlRfU1VJVEVfQkVHSU47XG52YXIgRVZFTlRfU1VJVEVfRU5EID0gY29uc3RhbnRzLkVWRU5UX1NVSVRFX0VORDtcblxuLyoqXG4gKiBFeHBvc2UgYERvY2AuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRG9jO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYERvY2AgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gRG9jKHJ1bm5lciwgb3B0aW9ucykge1xuICBCYXNlLmNhbGwodGhpcywgcnVubmVyLCBvcHRpb25zKTtcblxuICB2YXIgaW5kZW50cyA9IDI7XG5cbiAgZnVuY3Rpb24gaW5kZW50KCkge1xuICAgIHJldHVybiBBcnJheShpbmRlbnRzKS5qb2luKCcgICcpO1xuICB9XG5cbiAgcnVubmVyLm9uKEVWRU5UX1NVSVRFX0JFR0lOLCBmdW5jdGlvbiAoc3VpdGUpIHtcbiAgICBpZiAoc3VpdGUucm9vdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICArK2luZGVudHM7XG4gICAgQmFzZS5jb25zb2xlTG9nKCclczxzZWN0aW9uIGNsYXNzPVwic3VpdGVcIj4nLCBpbmRlbnQoKSk7XG4gICAgKytpbmRlbnRzO1xuICAgIEJhc2UuY29uc29sZUxvZygnJXM8aDE+JXM8L2gxPicsIGluZGVudCgpLCB1dGlscy5lc2NhcGUoc3VpdGUudGl0bGUpKTtcbiAgICBCYXNlLmNvbnNvbGVMb2coJyVzPGRsPicsIGluZGVudCgpKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1NVSVRFX0VORCwgZnVuY3Rpb24gKHN1aXRlKSB7XG4gICAgaWYgKHN1aXRlLnJvb3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgQmFzZS5jb25zb2xlTG9nKCclczwvZGw+JywgaW5kZW50KCkpO1xuICAgIC0taW5kZW50cztcbiAgICBCYXNlLmNvbnNvbGVMb2coJyVzPC9zZWN0aW9uPicsIGluZGVudCgpKTtcbiAgICAtLWluZGVudHM7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BBU1MsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgQmFzZS5jb25zb2xlTG9nKCclcyAgPGR0PiVzPC9kdD4nLCBpbmRlbnQoKSwgdXRpbHMuZXNjYXBlKHRlc3QudGl0bGUpKTtcbiAgICBCYXNlLmNvbnNvbGVMb2coJyVzICA8ZHQ+JXM8L2R0PicsIGluZGVudCgpLCB1dGlscy5lc2NhcGUodGVzdC5maWxlKSk7XG4gICAgdmFyIGNvZGUgPSB1dGlscy5lc2NhcGUodXRpbHMuY2xlYW4odGVzdC5ib2R5KSk7XG4gICAgQmFzZS5jb25zb2xlTG9nKCclcyAgPGRkPjxwcmU+PGNvZGU+JXM8L2NvZGU+PC9wcmU+PC9kZD4nLCBpbmRlbnQoKSwgY29kZSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX0ZBSUwsIGZ1bmN0aW9uICh0ZXN0LCBlcnIpIHtcbiAgICBCYXNlLmNvbnNvbGVMb2coXG4gICAgICAnJXMgIDxkdCBjbGFzcz1cImVycm9yXCI+JXM8L2R0PicsXG4gICAgICBpbmRlbnQoKSxcbiAgICAgIHV0aWxzLmVzY2FwZSh0ZXN0LnRpdGxlKVxuICAgICk7XG4gICAgQmFzZS5jb25zb2xlTG9nKFxuICAgICAgJyVzICA8ZHQgY2xhc3M9XCJlcnJvclwiPiVzPC9kdD4nLFxuICAgICAgaW5kZW50KCksXG4gICAgICB1dGlscy5lc2NhcGUodGVzdC5maWxlKVxuICAgICk7XG4gICAgdmFyIGNvZGUgPSB1dGlscy5lc2NhcGUodXRpbHMuY2xlYW4odGVzdC5ib2R5KSk7XG4gICAgQmFzZS5jb25zb2xlTG9nKFxuICAgICAgJyVzICA8ZGQgY2xhc3M9XCJlcnJvclwiPjxwcmU+PGNvZGU+JXM8L2NvZGU+PC9wcmU+PC9kZD4nLFxuICAgICAgaW5kZW50KCksXG4gICAgICBjb2RlXG4gICAgKTtcbiAgICBCYXNlLmNvbnNvbGVMb2coXG4gICAgICAnJXMgIDxkZCBjbGFzcz1cImVycm9yXCI+JXM8L2RkPicsXG4gICAgICBpbmRlbnQoKSxcbiAgICAgIHV0aWxzLmVzY2FwZShlcnIpXG4gICAgKTtcbiAgfSk7XG59XG5cbkRvYy5kZXNjcmlwdGlvbiA9ICdIVE1MIGRvY3VtZW50YXRpb24nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIERvdFxuICovXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuaW5oZXJpdHM7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1RFU1RfUEFTUyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BBU1M7XG52YXIgRVZFTlRfVEVTVF9GQUlMID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfRkFJTDtcbnZhciBFVkVOVF9SVU5fQkVHSU4gPSBjb25zdGFudHMuRVZFTlRfUlVOX0JFR0lOO1xudmFyIEVWRU5UX1RFU1RfUEVORElORyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkc7XG52YXIgRVZFTlRfUlVOX0VORCA9IGNvbnN0YW50cy5FVkVOVF9SVU5fRU5EO1xuXG4vKipcbiAqIEV4cG9zZSBgRG90YC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBEb3Q7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgRG90YCByZXBvcnRlciBpbnN0YW5jZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyIC0gSW5zdGFuY2UgdHJpZ2dlcnMgcmVwb3J0ZXIgYWN0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBydW5uZXIgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBEb3QocnVubmVyLCBvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIsIG9wdGlvbnMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHdpZHRoID0gKEJhc2Uud2luZG93LndpZHRoICogMC43NSkgfCAwO1xuICB2YXIgbiA9IC0xO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9SVU5fQkVHSU4sIGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxuJyk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BFTkRJTkcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoKytuICUgd2lkdGggPT09IDApIHtcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXG4gICcpO1xuICAgIH1cbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShCYXNlLmNvbG9yKCdwZW5kaW5nJywgQmFzZS5zeW1ib2xzLmNvbW1hKSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BBU1MsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgaWYgKCsrbiAlIHdpZHRoID09PSAwKSB7XG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxuICAnKTtcbiAgICB9XG4gICAgaWYgKHRlc3Quc3BlZWQgPT09ICdzbG93Jykge1xuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoQmFzZS5jb2xvcignYnJpZ2h0IHllbGxvdycsIEJhc2Uuc3ltYm9scy5kb3QpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoQmFzZS5jb2xvcih0ZXN0LnNwZWVkLCBCYXNlLnN5bWJvbHMuZG90KSk7XG4gICAgfVxuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9GQUlMLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCsrbiAlIHdpZHRoID09PSAwKSB7XG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxuICAnKTtcbiAgICB9XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoQmFzZS5jb2xvcignZmFpbCcsIEJhc2Uuc3ltYm9scy5iYW5nKSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbmNlKEVWRU5UX1JVTl9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxuJyk7XG4gICAgc2VsZi5lcGlsb2d1ZSgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cbiAqL1xuaW5oZXJpdHMoRG90LCBCYXNlKTtcblxuRG90LmRlc2NyaXB0aW9uID0gJ2RvdCBtYXRyaXggcmVwcmVzZW50YXRpb24nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbi8qKlxuICogQG1vZHVsZSBIVE1MXG4gKi9cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBQcm9ncmVzcyA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvcHJvZ3Jlc3MnKTtcbnZhciBlc2NhcGVSZSA9IHJlcXVpcmUoJ2VzY2FwZS1zdHJpbmctcmVnZXhwJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1RFU1RfUEFTUyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BBU1M7XG52YXIgRVZFTlRfVEVTVF9GQUlMID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfRkFJTDtcbnZhciBFVkVOVF9TVUlURV9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9TVUlURV9CRUdJTjtcbnZhciBFVkVOVF9TVUlURV9FTkQgPSBjb25zdGFudHMuRVZFTlRfU1VJVEVfRU5EO1xudmFyIEVWRU5UX1RFU1RfUEVORElORyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkc7XG52YXIgZXNjYXBlID0gdXRpbHMuZXNjYXBlO1xuXG4vKipcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXG4gKi9cblxudmFyIERhdGUgPSBnbG9iYWwuRGF0ZTtcblxuLyoqXG4gKiBFeHBvc2UgYEhUTUxgLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEhUTUw7XG5cbi8qKlxuICogU3RhdHMgdGVtcGxhdGUuXG4gKi9cblxudmFyIHN0YXRzVGVtcGxhdGUgPVxuICAnPHVsIGlkPVwibW9jaGEtc3RhdHNcIj4nICtcbiAgJzxsaSBjbGFzcz1cInByb2dyZXNzXCI+PGNhbnZhcyB3aWR0aD1cIjQwXCIgaGVpZ2h0PVwiNDBcIj48L2NhbnZhcz48L2xpPicgK1xuICAnPGxpIGNsYXNzPVwicGFzc2VzXCI+PGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKTtcIj5wYXNzZXM6PC9hPiA8ZW0+MDwvZW0+PC9saT4nICtcbiAgJzxsaSBjbGFzcz1cImZhaWx1cmVzXCI+PGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKTtcIj5mYWlsdXJlczo8L2E+IDxlbT4wPC9lbT48L2xpPicgK1xuICAnPGxpIGNsYXNzPVwiZHVyYXRpb25cIj5kdXJhdGlvbjogPGVtPjA8L2VtPnM8L2xpPicgK1xuICAnPC91bD4nO1xuXG52YXIgcGxheUljb24gPSAnJiN4MjAyMzsnO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYEhUTUxgIHJlcG9ydGVyIGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXIgLSBJbnN0YW5jZSB0cmlnZ2VycyByZXBvcnRlciBhY3Rpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHJ1bm5lciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIEhUTUwocnVubmVyLCBvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIsIG9wdGlvbnMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgdmFyIHN0YXQgPSBmcmFnbWVudChzdGF0c1RlbXBsYXRlKTtcbiAgdmFyIGl0ZW1zID0gc3RhdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGknKTtcbiAgdmFyIHBhc3NlcyA9IGl0ZW1zWzFdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdlbScpWzBdO1xuICB2YXIgcGFzc2VzTGluayA9IGl0ZW1zWzFdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJylbMF07XG4gIHZhciBmYWlsdXJlcyA9IGl0ZW1zWzJdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdlbScpWzBdO1xuICB2YXIgZmFpbHVyZXNMaW5rID0gaXRlbXNbMl0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2EnKVswXTtcbiAgdmFyIGR1cmF0aW9uID0gaXRlbXNbM10uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2VtJylbMF07XG4gIHZhciBjYW52YXMgPSBzdGF0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjYW52YXMnKVswXTtcbiAgdmFyIHJlcG9ydCA9IGZyYWdtZW50KCc8dWwgaWQ9XCJtb2NoYS1yZXBvcnRcIj48L3VsPicpO1xuICB2YXIgc3RhY2sgPSBbcmVwb3J0XTtcbiAgdmFyIHByb2dyZXNzO1xuICB2YXIgY3R4O1xuICB2YXIgcm9vdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2NoYScpO1xuXG4gIGlmIChjYW52YXMuZ2V0Q29udGV4dCkge1xuICAgIHZhciByYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgIGNhbnZhcy53aWR0aCAqPSByYXRpbztcbiAgICBjYW52YXMuaGVpZ2h0ICo9IHJhdGlvO1xuICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgIHByb2dyZXNzID0gbmV3IFByb2dyZXNzKCk7XG4gIH1cblxuICBpZiAoIXJvb3QpIHtcbiAgICByZXR1cm4gZXJyb3IoJyNtb2NoYSBkaXYgbWlzc2luZywgYWRkIGl0IHRvIHlvdXIgZG9jdW1lbnQnKTtcbiAgfVxuXG4gIC8vIHBhc3MgdG9nZ2xlXG4gIG9uKHBhc3Nlc0xpbmssICdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB1bmhpZGUoKTtcbiAgICB2YXIgbmFtZSA9IC9wYXNzLy50ZXN0KHJlcG9ydC5jbGFzc05hbWUpID8gJycgOiAnIHBhc3MnO1xuICAgIHJlcG9ydC5jbGFzc05hbWUgPSByZXBvcnQuY2xhc3NOYW1lLnJlcGxhY2UoL2ZhaWx8cGFzcy9nLCAnJykgKyBuYW1lO1xuICAgIGlmIChyZXBvcnQuY2xhc3NOYW1lLnRyaW0oKSkge1xuICAgICAgaGlkZVN1aXRlc1dpdGhvdXQoJ3Rlc3QgcGFzcycpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZmFpbHVyZSB0b2dnbGVcbiAgb24oZmFpbHVyZXNMaW5rLCAnY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdW5oaWRlKCk7XG4gICAgdmFyIG5hbWUgPSAvZmFpbC8udGVzdChyZXBvcnQuY2xhc3NOYW1lKSA/ICcnIDogJyBmYWlsJztcbiAgICByZXBvcnQuY2xhc3NOYW1lID0gcmVwb3J0LmNsYXNzTmFtZS5yZXBsYWNlKC9mYWlsfHBhc3MvZywgJycpICsgbmFtZTtcbiAgICBpZiAocmVwb3J0LmNsYXNzTmFtZS50cmltKCkpIHtcbiAgICAgIGhpZGVTdWl0ZXNXaXRob3V0KCd0ZXN0IGZhaWwnKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJvb3QuYXBwZW5kQ2hpbGQoc3RhdCk7XG4gIHJvb3QuYXBwZW5kQ2hpbGQocmVwb3J0KTtcblxuICBpZiAocHJvZ3Jlc3MpIHtcbiAgICBwcm9ncmVzcy5zaXplKDQwKTtcbiAgfVxuXG4gIHJ1bm5lci5vbihFVkVOVF9TVUlURV9CRUdJTiwgZnVuY3Rpb24gKHN1aXRlKSB7XG4gICAgaWYgKHN1aXRlLnJvb3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzdWl0ZVxuICAgIHZhciB1cmwgPSBzZWxmLnN1aXRlVVJMKHN1aXRlKTtcbiAgICB2YXIgZWwgPSBmcmFnbWVudChcbiAgICAgICc8bGkgY2xhc3M9XCJzdWl0ZVwiPjxoMT48YSBocmVmPVwiJXNcIj4lczwvYT48L2gxPjwvbGk+JyxcbiAgICAgIHVybCxcbiAgICAgIGVzY2FwZShzdWl0ZS50aXRsZSlcbiAgICApO1xuXG4gICAgLy8gY29udGFpbmVyXG4gICAgc3RhY2tbMF0uYXBwZW5kQ2hpbGQoZWwpO1xuICAgIHN0YWNrLnVuc2hpZnQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKSk7XG4gICAgZWwuYXBwZW5kQ2hpbGQoc3RhY2tbMF0pO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfU1VJVEVfRU5ELCBmdW5jdGlvbiAoc3VpdGUpIHtcbiAgICBpZiAoc3VpdGUucm9vdCkge1xuICAgICAgdXBkYXRlU3RhdHMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhY2suc2hpZnQoKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEFTUywgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICB2YXIgdXJsID0gc2VsZi50ZXN0VVJMKHRlc3QpO1xuICAgIHZhciBtYXJrdXAgPVxuICAgICAgJzxsaSBjbGFzcz1cInRlc3QgcGFzcyAlZVwiPjxoMj4lZTxzcGFuIGNsYXNzPVwiZHVyYXRpb25cIj4lZW1zPC9zcGFuPiAnICtcbiAgICAgICc8YSBocmVmPVwiJXNcIiBjbGFzcz1cInJlcGxheVwiPicgK1xuICAgICAgcGxheUljb24gK1xuICAgICAgJzwvYT48L2gyPjwvbGk+JztcbiAgICB2YXIgZWwgPSBmcmFnbWVudChtYXJrdXAsIHRlc3Quc3BlZWQsIHRlc3QudGl0bGUsIHRlc3QuZHVyYXRpb24sIHVybCk7XG4gICAgc2VsZi5hZGRDb2RlVG9nZ2xlKGVsLCB0ZXN0LmJvZHkpO1xuICAgIGFwcGVuZFRvU3RhY2soZWwpO1xuICAgIHVwZGF0ZVN0YXRzKCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX0ZBSUwsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgdmFyIGVsID0gZnJhZ21lbnQoXG4gICAgICAnPGxpIGNsYXNzPVwidGVzdCBmYWlsXCI+PGgyPiVlIDxhIGhyZWY9XCIlZVwiIGNsYXNzPVwicmVwbGF5XCI+JyArXG4gICAgICAgIHBsYXlJY29uICtcbiAgICAgICAgJzwvYT48L2gyPjwvbGk+JyxcbiAgICAgIHRlc3QudGl0bGUsXG4gICAgICBzZWxmLnRlc3RVUkwodGVzdClcbiAgICApO1xuICAgIHZhciBzdGFja1N0cmluZzsgLy8gTm90ZTogSW5jbHVkZXMgbGVhZGluZyBuZXdsaW5lXG4gICAgdmFyIG1lc3NhZ2UgPSB0ZXN0LmVyci50b1N0cmluZygpO1xuXG4gICAgLy8gPD1JRTcgc3RyaW5naWZpZXMgdG8gW09iamVjdCBFcnJvcl0uIFNpbmNlIGl0IGNhbiBiZSBvdmVybG9hZGVkLCB3ZVxuICAgIC8vIGNoZWNrIGZvciB0aGUgcmVzdWx0IG9mIHRoZSBzdHJpbmdpZnlpbmcuXG4gICAgaWYgKG1lc3NhZ2UgPT09ICdbb2JqZWN0IEVycm9yXScpIHtcbiAgICAgIG1lc3NhZ2UgPSB0ZXN0LmVyci5tZXNzYWdlO1xuICAgIH1cblxuICAgIGlmICh0ZXN0LmVyci5zdGFjaykge1xuICAgICAgdmFyIGluZGV4T2ZNZXNzYWdlID0gdGVzdC5lcnIuc3RhY2suaW5kZXhPZih0ZXN0LmVyci5tZXNzYWdlKTtcbiAgICAgIGlmIChpbmRleE9mTWVzc2FnZSA9PT0gLTEpIHtcbiAgICAgICAgc3RhY2tTdHJpbmcgPSB0ZXN0LmVyci5zdGFjaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YWNrU3RyaW5nID0gdGVzdC5lcnIuc3RhY2suc2xpY2UoXG4gICAgICAgICAgdGVzdC5lcnIubWVzc2FnZS5sZW5ndGggKyBpbmRleE9mTWVzc2FnZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGVzdC5lcnIuc291cmNlVVJMICYmIHRlc3QuZXJyLmxpbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgZ2l2ZSB5b3UgYSBzdGFjay4gTGV0J3MgYXQgbGVhc3QgcHJvdmlkZSBhIHNvdXJjZSBsaW5lLlxuICAgICAgc3RhY2tTdHJpbmcgPSAnXFxuKCcgKyB0ZXN0LmVyci5zb3VyY2VVUkwgKyAnOicgKyB0ZXN0LmVyci5saW5lICsgJyknO1xuICAgIH1cblxuICAgIHN0YWNrU3RyaW5nID0gc3RhY2tTdHJpbmcgfHwgJyc7XG5cbiAgICBpZiAodGVzdC5lcnIuaHRtbE1lc3NhZ2UgJiYgc3RhY2tTdHJpbmcpIHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKFxuICAgICAgICBmcmFnbWVudChcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImh0bWwtZXJyb3JcIj4lc1xcbjxwcmUgY2xhc3M9XCJlcnJvclwiPiVlPC9wcmU+PC9kaXY+JyxcbiAgICAgICAgICB0ZXN0LmVyci5odG1sTWVzc2FnZSxcbiAgICAgICAgICBzdGFja1N0cmluZ1xuICAgICAgICApXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodGVzdC5lcnIuaHRtbE1lc3NhZ2UpIHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKFxuICAgICAgICBmcmFnbWVudCgnPGRpdiBjbGFzcz1cImh0bWwtZXJyb3JcIj4lczwvZGl2PicsIHRlc3QuZXJyLmh0bWxNZXNzYWdlKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuYXBwZW5kQ2hpbGQoXG4gICAgICAgIGZyYWdtZW50KCc8cHJlIGNsYXNzPVwiZXJyb3JcIj4lZSVlPC9wcmU+JywgbWVzc2FnZSwgc3RhY2tTdHJpbmcpXG4gICAgICApO1xuICAgIH1cblxuICAgIHNlbGYuYWRkQ29kZVRvZ2dsZShlbCwgdGVzdC5ib2R5KTtcbiAgICBhcHBlbmRUb1N0YWNrKGVsKTtcbiAgICB1cGRhdGVTdGF0cygpO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9QRU5ESU5HLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIHZhciBlbCA9IGZyYWdtZW50KFxuICAgICAgJzxsaSBjbGFzcz1cInRlc3QgcGFzcyBwZW5kaW5nXCI+PGgyPiVlPC9oMj48L2xpPicsXG4gICAgICB0ZXN0LnRpdGxlXG4gICAgKTtcbiAgICBhcHBlbmRUb1N0YWNrKGVsKTtcbiAgICB1cGRhdGVTdGF0cygpO1xuICB9KTtcblxuICBmdW5jdGlvbiBhcHBlbmRUb1N0YWNrKGVsKSB7XG4gICAgLy8gRG9uJ3QgY2FsbCAuYXBwZW5kQ2hpbGQgaWYgI21vY2hhLXJlcG9ydCB3YXMgYWxyZWFkeSAuc2hpZnQoKSdlZCBvZmYgdGhlIHN0YWNrLlxuICAgIGlmIChzdGFja1swXSkge1xuICAgICAgc3RhY2tbMF0uYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0YXRzKCkge1xuICAgIC8vIFRPRE86IGFkZCB0byBzdGF0c1xuICAgIHZhciBwZXJjZW50ID0gKChzdGF0cy50ZXN0cyAvIHJ1bm5lci50b3RhbCkgKiAxMDApIHwgMDtcbiAgICBpZiAocHJvZ3Jlc3MpIHtcbiAgICAgIHByb2dyZXNzLnVwZGF0ZShwZXJjZW50KS5kcmF3KGN0eCk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHN0YXRzXG4gICAgdmFyIG1zID0gbmV3IERhdGUoKSAtIHN0YXRzLnN0YXJ0O1xuICAgIHRleHQocGFzc2VzLCBzdGF0cy5wYXNzZXMpO1xuICAgIHRleHQoZmFpbHVyZXMsIHN0YXRzLmZhaWx1cmVzKTtcbiAgICB0ZXh0KGR1cmF0aW9uLCAobXMgLyAxMDAwKS50b0ZpeGVkKDIpKTtcbiAgfVxufVxuXG4vKipcbiAqIE1ha2VzIGEgVVJMLCBwcmVzZXJ2aW5nIHF1ZXJ5c3RyaW5nIChcInNlYXJjaFwiKSBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgbmV3IFVSTC5cbiAqL1xuZnVuY3Rpb24gbWFrZVVybChzKSB7XG4gIHZhciBzZWFyY2ggPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xuXG4gIC8vIFJlbW92ZSBwcmV2aW91cyBncmVwIHF1ZXJ5IHBhcmFtZXRlciBpZiBwcmVzZW50XG4gIGlmIChzZWFyY2gpIHtcbiAgICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgvWz8mXWdyZXA9W14mXFxzXSovZywgJycpLnJlcGxhY2UoL14mLywgJz8nKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICtcbiAgICAoc2VhcmNoID8gc2VhcmNoICsgJyYnIDogJz8nKSArXG4gICAgJ2dyZXA9JyArXG4gICAgZW5jb2RlVVJJQ29tcG9uZW50KGVzY2FwZVJlKHMpKVxuICApO1xufVxuXG4vKipcbiAqIFByb3ZpZGUgc3VpdGUgVVJMLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3VpdGVdXG4gKi9cbkhUTUwucHJvdG90eXBlLnN1aXRlVVJMID0gZnVuY3Rpb24gKHN1aXRlKSB7XG4gIHJldHVybiBtYWtlVXJsKHN1aXRlLmZ1bGxUaXRsZSgpKTtcbn07XG5cbi8qKlxuICogUHJvdmlkZSB0ZXN0IFVSTC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW3Rlc3RdXG4gKi9cbkhUTUwucHJvdG90eXBlLnRlc3RVUkwgPSBmdW5jdGlvbiAodGVzdCkge1xuICByZXR1cm4gbWFrZVVybCh0ZXN0LmZ1bGxUaXRsZSgpKTtcbn07XG5cbi8qKlxuICogQWRkcyBjb2RlIHRvZ2dsZSBmdW5jdGlvbmFsaXR5IGZvciB0aGUgcHJvdmlkZWQgdGVzdCdzIGxpc3QgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0hUTUxMSUVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudHNcbiAqL1xuSFRNTC5wcm90b3R5cGUuYWRkQ29kZVRvZ2dsZSA9IGZ1bmN0aW9uIChlbCwgY29udGVudHMpIHtcbiAgdmFyIGgyID0gZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2gyJylbMF07XG5cbiAgb24oaDIsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICBwcmUuc3R5bGUuZGlzcGxheSA9IHByZS5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnYmxvY2snIDogJ25vbmUnO1xuICB9KTtcblxuICB2YXIgcHJlID0gZnJhZ21lbnQoJzxwcmU+PGNvZGU+JWU8L2NvZGU+PC9wcmU+JywgdXRpbHMuY2xlYW4oY29udGVudHMpKTtcbiAgZWwuYXBwZW5kQ2hpbGQocHJlKTtcbiAgcHJlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG59O1xuXG4vKipcbiAqIERpc3BsYXkgZXJyb3IgYG1zZ2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1zZ1xuICovXG5mdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmcmFnbWVudCgnPGRpdiBpZD1cIm1vY2hhLWVycm9yXCI+JXM8L2Rpdj4nLCBtc2cpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBET00gZnJhZ21lbnQgZnJvbSBgaHRtbGAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqL1xuZnVuY3Rpb24gZnJhZ21lbnQoaHRtbCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgaSA9IDE7XG5cbiAgZGl2LmlubmVySFRNTCA9IGh0bWwucmVwbGFjZSgvJShbc2VdKS9nLCBmdW5jdGlvbiAoXywgdHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAncyc6XG4gICAgICAgIHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJ2UnOlxuICAgICAgICByZXR1cm4gZXNjYXBlKGFyZ3NbaSsrXSk7XG4gICAgICAvLyBubyBkZWZhdWx0XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGl2LmZpcnN0Q2hpbGQ7XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIHN1aXRlcyB0aGF0IGRvIG5vdCBoYXZlIGVsZW1lbnRzXG4gKiB3aXRoIGBjbGFzc25hbWVgLCBhbmQgaGlkZSB0aGVtLlxuICpcbiAqIEBwYXJhbSB7dGV4dH0gY2xhc3NuYW1lXG4gKi9cbmZ1bmN0aW9uIGhpZGVTdWl0ZXNXaXRob3V0KGNsYXNzbmFtZSkge1xuICB2YXIgc3VpdGVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc3VpdGUnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxzID0gc3VpdGVzW2ldLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NuYW1lKTtcbiAgICBpZiAoIWVscy5sZW5ndGgpIHtcbiAgICAgIHN1aXRlc1tpXS5jbGFzc05hbWUgKz0gJyBoaWRkZW4nO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFVuaGlkZSAuaGlkZGVuIHN1aXRlcy5cbiAqL1xuZnVuY3Rpb24gdW5oaWRlKCkge1xuICB2YXIgZWxzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc3VpdGUgaGlkZGVuJyk7XG4gIHdoaWxlIChlbHMubGVuZ3RoID4gMCkge1xuICAgIGVsc1swXS5jbGFzc05hbWUgPSBlbHNbMF0uY2xhc3NOYW1lLnJlcGxhY2UoJ3N1aXRlIGhpZGRlbicsICdzdWl0ZScpO1xuICB9XG59XG5cbi8qKlxuICogU2V0IGFuIGVsZW1lbnQncyB0ZXh0IGNvbnRlbnRzLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudHNcbiAqL1xuZnVuY3Rpb24gdGV4dChlbCwgY29udGVudHMpIHtcbiAgaWYgKGVsLnRleHRDb250ZW50KSB7XG4gICAgZWwudGV4dENvbnRlbnQgPSBjb250ZW50cztcbiAgfSBlbHNlIHtcbiAgICBlbC5pbm5lclRleHQgPSBjb250ZW50cztcbiAgfVxufVxuXG4vKipcbiAqIExpc3RlbiBvbiBgZXZlbnRgIHdpdGggY2FsbGJhY2sgYGZuYC5cbiAqL1xuZnVuY3Rpb24gb24oZWwsIGV2ZW50LCBmbikge1xuICBpZiAoZWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmbik7XG4gIH1cbn1cblxuSFRNTC5icm93c2VyT25seSA9IHRydWU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEFsaWFzIGV4cG9ydHMgdG8gYSB0aGVpciBub3JtYWxpemVkIGZvcm1hdCBNb2NoYSNyZXBvcnRlciB0byBwcmV2ZW50IGEgbmVlZFxuLy8gZm9yIGR5bmFtaWMgKHRyeS9jYXRjaCkgcmVxdWlyZXMsIHdoaWNoIEJyb3dzZXJpZnkgZG9lc24ndCBoYW5kbGUuXG5leHBvcnRzLkJhc2UgPSBleHBvcnRzLmJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbmV4cG9ydHMuRG90ID0gZXhwb3J0cy5kb3QgPSByZXF1aXJlKCcuL2RvdCcpO1xuZXhwb3J0cy5Eb2MgPSBleHBvcnRzLmRvYyA9IHJlcXVpcmUoJy4vZG9jJyk7XG5leHBvcnRzLlRBUCA9IGV4cG9ydHMudGFwID0gcmVxdWlyZSgnLi90YXAnKTtcbmV4cG9ydHMuSlNPTiA9IGV4cG9ydHMuanNvbiA9IHJlcXVpcmUoJy4vanNvbicpO1xuZXhwb3J0cy5IVE1MID0gZXhwb3J0cy5odG1sID0gcmVxdWlyZSgnLi9odG1sJyk7XG5leHBvcnRzLkxpc3QgPSBleHBvcnRzLmxpc3QgPSByZXF1aXJlKCcuL2xpc3QnKTtcbmV4cG9ydHMuTWluID0gZXhwb3J0cy5taW4gPSByZXF1aXJlKCcuL21pbicpO1xuZXhwb3J0cy5TcGVjID0gZXhwb3J0cy5zcGVjID0gcmVxdWlyZSgnLi9zcGVjJyk7XG5leHBvcnRzLk55YW4gPSBleHBvcnRzLm55YW4gPSByZXF1aXJlKCcuL255YW4nKTtcbmV4cG9ydHMuWFVuaXQgPSBleHBvcnRzLnh1bml0ID0gcmVxdWlyZSgnLi94dW5pdCcpO1xuZXhwb3J0cy5NYXJrZG93biA9IGV4cG9ydHMubWFya2Rvd24gPSByZXF1aXJlKCcuL21hcmtkb3duJyk7XG5leHBvcnRzLlByb2dyZXNzID0gZXhwb3J0cy5wcm9ncmVzcyA9IHJlcXVpcmUoJy4vcHJvZ3Jlc3MnKTtcbmV4cG9ydHMuTGFuZGluZyA9IGV4cG9ydHMubGFuZGluZyA9IHJlcXVpcmUoJy4vbGFuZGluZycpO1xuZXhwb3J0cy5KU09OU3RyZWFtID0gZXhwb3J0c1snanNvbi1zdHJlYW0nXSA9IHJlcXVpcmUoJy4vanNvbi1zdHJlYW0nKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBKU09OU3RyZWFtXG4gKi9cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL3J1bm5lcicpLmNvbnN0YW50cztcbnZhciBFVkVOVF9URVNUX1BBU1MgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9QQVNTO1xudmFyIEVWRU5UX1RFU1RfRkFJTCA9IGNvbnN0YW50cy5FVkVOVF9URVNUX0ZBSUw7XG52YXIgRVZFTlRfUlVOX0JFR0lOID0gY29uc3RhbnRzLkVWRU5UX1JVTl9CRUdJTjtcbnZhciBFVkVOVF9SVU5fRU5EID0gY29uc3RhbnRzLkVWRU5UX1JVTl9FTkQ7XG5cbi8qKlxuICogRXhwb3NlIGBKU09OU3RyZWFtYC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBKU09OU3RyZWFtO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYEpTT05TdHJlYW1gIHJlcG9ydGVyIGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXIgLSBJbnN0YW5jZSB0cmlnZ2VycyByZXBvcnRlciBhY3Rpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHJ1bm5lciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIEpTT05TdHJlYW0ocnVubmVyLCBvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIsIG9wdGlvbnMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRvdGFsID0gcnVubmVyLnRvdGFsO1xuXG4gIHJ1bm5lci5vbmNlKEVWRU5UX1JVTl9CRUdJTiwgZnVuY3Rpb24gKCkge1xuICAgIHdyaXRlRXZlbnQoWydzdGFydCcsIHt0b3RhbDogdG90YWx9XSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BBU1MsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgd3JpdGVFdmVudChbJ3Bhc3MnLCBjbGVhbih0ZXN0KV0pO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9GQUlMLCBmdW5jdGlvbiAodGVzdCwgZXJyKSB7XG4gICAgdGVzdCA9IGNsZWFuKHRlc3QpO1xuICAgIHRlc3QuZXJyID0gZXJyLm1lc3NhZ2U7XG4gICAgdGVzdC5zdGFjayA9IGVyci5zdGFjayB8fCBudWxsO1xuICAgIHdyaXRlRXZlbnQoWydmYWlsJywgdGVzdF0pO1xuICB9KTtcblxuICBydW5uZXIub25jZShFVkVOVF9SVU5fRU5ELCBmdW5jdGlvbiAoKSB7XG4gICAgd3JpdGVFdmVudChbJ2VuZCcsIHNlbGYuc3RhdHNdKTtcbiAgfSk7XG59XG5cbi8qKlxuICogTW9jaGEgZXZlbnQgdG8gYmUgd3JpdHRlbiB0byB0aGUgb3V0cHV0IHN0cmVhbS5cbiAqIEB0eXBlZGVmIHtBcnJheX0gSlNPTlN0cmVhbX5Nb2NoYUV2ZW50XG4gKi9cblxuLyoqXG4gKiBXcml0ZXMgTW9jaGEgZXZlbnQgdG8gcmVwb3J0ZXIgb3V0cHV0IHN0cmVhbS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtKU09OU3RyZWFtfk1vY2hhRXZlbnR9IGV2ZW50IC0gTW9jaGEgZXZlbnQgdG8gYmUgb3V0cHV0LlxuICovXG5mdW5jdGlvbiB3cml0ZUV2ZW50KGV2ZW50KSB7XG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEpTT04uc3RyaW5naWZ5KGV2ZW50KSArICdcXG4nKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBsaXRlcmFsIHJlcHJlc2VudGF0aW9uIG9mIGB0ZXN0YFxuICogZnJlZSBvZiBjeWNsaWMgcHJvcGVydGllcywgZXRjLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1Rlc3R9IHRlc3QgLSBJbnN0YW5jZSB1c2VkIGFzIGRhdGEgc291cmNlLlxuICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBwYXJlZC1kb3duIHRlc3QgaW5zdGFuY2UgZGF0YVxuICovXG5mdW5jdGlvbiBjbGVhbih0ZXN0KSB7XG4gIHJldHVybiB7XG4gICAgdGl0bGU6IHRlc3QudGl0bGUsXG4gICAgZnVsbFRpdGxlOiB0ZXN0LmZ1bGxUaXRsZSgpLFxuICAgIGZpbGU6IHRlc3QuZmlsZSxcbiAgICBkdXJhdGlvbjogdGVzdC5kdXJhdGlvbixcbiAgICBjdXJyZW50UmV0cnk6IHRlc3QuY3VycmVudFJldHJ5KCksXG4gICAgc3BlZWQ6IHRlc3Quc3BlZWRcbiAgfTtcbn1cblxuSlNPTlN0cmVhbS5kZXNjcmlwdGlvbiA9ICduZXdsaW5lIGRlbGltaXRlZCBKU09OIGV2ZW50cyc7XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgSlNPTlxuICovXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGNyZWF0ZVVuc3VwcG9ydGVkRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jcmVhdGVVbnN1cHBvcnRlZEVycm9yO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL3J1bm5lcicpLmNvbnN0YW50cztcbnZhciBFVkVOVF9URVNUX1BBU1MgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9QQVNTO1xudmFyIEVWRU5UX1RFU1RfUEVORElORyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkc7XG52YXIgRVZFTlRfVEVTVF9GQUlMID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfRkFJTDtcbnZhciBFVkVOVF9URVNUX0VORCA9IGNvbnN0YW50cy5FVkVOVF9URVNUX0VORDtcbnZhciBFVkVOVF9SVU5fRU5EID0gY29uc3RhbnRzLkVWRU5UX1JVTl9FTkQ7XG5cbi8qKlxuICogRXhwb3NlIGBKU09OYC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBKU09OUmVwb3J0ZXI7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgSlNPTmAgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzIEpTT05cbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyIC0gSW5zdGFuY2UgdHJpZ2dlcnMgcmVwb3J0ZXIgYWN0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBydW5uZXIgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBKU09OUmVwb3J0ZXIocnVubmVyLCBvcHRpb25zID0ge30pIHtcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lciwgb3B0aW9ucyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdGVzdHMgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBbXTtcbiAgdmFyIGZhaWx1cmVzID0gW107XG4gIHZhciBwYXNzZXMgPSBbXTtcbiAgdmFyIG91dHB1dDtcblxuICBpZiAob3B0aW9ucy5yZXBvcnRlck9wdGlvbiAmJiBvcHRpb25zLnJlcG9ydGVyT3B0aW9uLm91dHB1dCkge1xuICAgIGlmICh1dGlscy5pc0Jyb3dzZXIoKSkge1xuICAgICAgdGhyb3cgY3JlYXRlVW5zdXBwb3J0ZWRFcnJvcignZmlsZSBvdXRwdXQgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyJyk7XG4gICAgfVxuICAgIG91dHB1dCA9IG9wdGlvbnMucmVwb3J0ZXJPcHRpb24ub3V0cHV0O1xuICB9XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfRU5ELCBmdW5jdGlvbiAodGVzdCkge1xuICAgIHRlc3RzLnB1c2godGVzdCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BBU1MsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgcGFzc2VzLnB1c2godGVzdCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX0ZBSUwsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgZmFpbHVyZXMucHVzaCh0ZXN0KTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEVORElORywgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICBwZW5kaW5nLnB1c2godGVzdCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbmNlKEVWRU5UX1JVTl9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgc3RhdHM6IHNlbGYuc3RhdHMsXG4gICAgICB0ZXN0czogdGVzdHMubWFwKGNsZWFuKSxcbiAgICAgIHBlbmRpbmc6IHBlbmRpbmcubWFwKGNsZWFuKSxcbiAgICAgIGZhaWx1cmVzOiBmYWlsdXJlcy5tYXAoY2xlYW4pLFxuICAgICAgcGFzc2VzOiBwYXNzZXMubWFwKGNsZWFuKVxuICAgIH07XG5cbiAgICBydW5uZXIudGVzdFJlc3VsdHMgPSBvYmo7XG5cbiAgICB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gICAgaWYgKG91dHB1dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMubWtkaXJTeW5jKHBhdGguZGlybmFtZShvdXRwdXQpLCB7cmVjdXJzaXZlOiB0cnVlfSk7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMob3V0cHV0LCBqc29uKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGAke0Jhc2Uuc3ltYm9scy5lcnJ9IFttb2NoYV0gd3JpdGluZyBvdXRwdXQgdG8gXCIke291dHB1dH1cIiBmYWlsZWQ6ICR7ZXJyLm1lc3NhZ2V9XFxuYFxuICAgICAgICApO1xuICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShqc29uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoanNvbik7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBwbGFpbi1vYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYHRlc3RgXG4gKiBmcmVlIG9mIGN5Y2xpYyBwcm9wZXJ0aWVzIGV0Yy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHRlc3RcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gY2xlYW4odGVzdCkge1xuICB2YXIgZXJyID0gdGVzdC5lcnIgfHwge307XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIGVyciA9IGVycm9ySlNPTihlcnIpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0aXRsZTogdGVzdC50aXRsZSxcbiAgICBmdWxsVGl0bGU6IHRlc3QuZnVsbFRpdGxlKCksXG4gICAgZmlsZTogdGVzdC5maWxlLFxuICAgIGR1cmF0aW9uOiB0ZXN0LmR1cmF0aW9uLFxuICAgIGN1cnJlbnRSZXRyeTogdGVzdC5jdXJyZW50UmV0cnkoKSxcbiAgICBzcGVlZDogdGVzdC5zcGVlZCxcbiAgICBlcnI6IGNsZWFuQ3ljbGVzKGVycilcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXBsYWNlcyBhbnkgY2lyY3VsYXIgcmVmZXJlbmNlcyBpbnNpZGUgYG9iamAgd2l0aCAnW29iamVjdCBPYmplY3RdJ1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNsZWFuQ3ljbGVzKG9iaikge1xuICB2YXIgY2FjaGUgPSBbXTtcbiAgcmV0dXJuIEpTT04ucGFyc2UoXG4gICAgSlNPTi5zdHJpbmdpZnkob2JqLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGNhY2hlLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIC8vIEluc3RlYWQgb2YgZ29pbmcgaW4gYSBjaXJjbGUsIHdlJ2xsIHByaW50IFtvYmplY3QgT2JqZWN0XVxuICAgICAgICAgIHJldHVybiAnJyArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlLnB1c2godmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gRXJyb3Igb2JqZWN0IGludG8gYSBKU09OIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGVycm9ySlNPTihlcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlcnIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHJlc1trZXldID0gZXJyW2tleV07XG4gIH0sIGVycik7XG4gIHJldHVybiByZXM7XG59XG5cbkpTT05SZXBvcnRlci5kZXNjcmlwdGlvbiA9ICdzaW5nbGUgSlNPTiBvYmplY3QnO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIExhbmRpbmdcbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL3J1bm5lcicpLmNvbnN0YW50cztcbnZhciBFVkVOVF9SVU5fQkVHSU4gPSBjb25zdGFudHMuRVZFTlRfUlVOX0JFR0lOO1xudmFyIEVWRU5UX1JVTl9FTkQgPSBjb25zdGFudHMuRVZFTlRfUlVOX0VORDtcbnZhciBFVkVOVF9URVNUX0VORCA9IGNvbnN0YW50cy5FVkVOVF9URVNUX0VORDtcbnZhciBTVEFURV9GQUlMRUQgPSByZXF1aXJlKCcuLi9ydW5uYWJsZScpLmNvbnN0YW50cy5TVEFURV9GQUlMRUQ7XG5cbnZhciBjdXJzb3IgPSBCYXNlLmN1cnNvcjtcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XG5cbi8qKlxuICogRXhwb3NlIGBMYW5kaW5nYC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBMYW5kaW5nO1xuXG4vKipcbiAqIEFpcnBsYW5lIGNvbG9yLlxuICovXG5cbkJhc2UuY29sb3JzLnBsYW5lID0gMDtcblxuLyoqXG4gKiBBaXJwbGFuZSBjcmFzaCBjb2xvci5cbiAqL1xuXG5CYXNlLmNvbG9yc1sncGxhbmUgY3Jhc2gnXSA9IDMxO1xuXG4vKipcbiAqIFJ1bndheSBjb2xvci5cbiAqL1xuXG5CYXNlLmNvbG9ycy5ydW53YXkgPSA5MDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBMYW5kaW5nYCByZXBvcnRlciBpbnN0YW5jZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyIC0gSW5zdGFuY2UgdHJpZ2dlcnMgcmVwb3J0ZXIgYWN0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBydW5uZXIgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBMYW5kaW5nKHJ1bm5lciwgb3B0aW9ucykge1xuICBCYXNlLmNhbGwodGhpcywgcnVubmVyLCBvcHRpb25zKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB3aWR0aCA9IChCYXNlLndpbmRvdy53aWR0aCAqIDAuNzUpIHwgMDtcbiAgdmFyIHN0cmVhbSA9IHByb2Nlc3Muc3Rkb3V0O1xuXG4gIHZhciBwbGFuZSA9IGNvbG9yKCdwbGFuZScsICfinIgnKTtcbiAgdmFyIGNyYXNoZWQgPSAtMTtcbiAgdmFyIG4gPSAwO1xuICB2YXIgdG90YWwgPSAwO1xuXG4gIGZ1bmN0aW9uIHJ1bndheSgpIHtcbiAgICB2YXIgYnVmID0gQXJyYXkod2lkdGgpLmpvaW4oJy0nKTtcbiAgICByZXR1cm4gJyAgJyArIGNvbG9yKCdydW53YXknLCBidWYpO1xuICB9XG5cbiAgcnVubmVyLm9uKEVWRU5UX1JVTl9CRUdJTiwgZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS53cml0ZSgnXFxuXFxuXFxuICAnKTtcbiAgICBjdXJzb3IuaGlkZSgpO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9FTkQsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgLy8gY2hlY2sgaWYgdGhlIHBsYW5lIGNyYXNoZWRcbiAgICB2YXIgY29sID0gY3Jhc2hlZCA9PT0gLTEgPyAoKHdpZHRoICogKytuKSAvICsrdG90YWwpIHwgMCA6IGNyYXNoZWQ7XG4gICAgLy8gc2hvdyB0aGUgY3Jhc2hcbiAgICBpZiAodGVzdC5zdGF0ZSA9PT0gU1RBVEVfRkFJTEVEKSB7XG4gICAgICBwbGFuZSA9IGNvbG9yKCdwbGFuZSBjcmFzaCcsICfinIgnKTtcbiAgICAgIGNyYXNoZWQgPSBjb2w7XG4gICAgfVxuXG4gICAgLy8gcmVuZGVyIGxhbmRpbmcgc3RyaXBcbiAgICBzdHJlYW0ud3JpdGUoJ1xcdTAwMWJbJyArICh3aWR0aCArIDEpICsgJ0RcXHUwMDFiWzJBJyk7XG4gICAgc3RyZWFtLndyaXRlKHJ1bndheSgpKTtcbiAgICBzdHJlYW0ud3JpdGUoJ1xcbiAgJyk7XG4gICAgc3RyZWFtLndyaXRlKGNvbG9yKCdydW53YXknLCBBcnJheShjb2wpLmpvaW4oJ+KLhScpKSk7XG4gICAgc3RyZWFtLndyaXRlKHBsYW5lKTtcbiAgICBzdHJlYW0ud3JpdGUoY29sb3IoJ3J1bndheScsIEFycmF5KHdpZHRoIC0gY29sKS5qb2luKCfii4UnKSArICdcXG4nKSk7XG4gICAgc3RyZWFtLndyaXRlKHJ1bndheSgpKTtcbiAgICBzdHJlYW0ud3JpdGUoJ1xcdTAwMWJbMG0nKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIGN1cnNvci5zaG93KCk7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcbicpO1xuICAgIHNlbGYuZXBpbG9ndWUoKTtcbiAgfSk7XG5cbiAgLy8gaWYgY3Vyc29yIGlzIGhpZGRlbiB3aGVuIHdlIGN0cmwtQywgdGhlbiBpdCB3aWxsIHJlbWFpbiBoaWRkZW4gdW5sZXNzLi4uXG4gIHByb2Nlc3Mub25jZSgnU0lHSU5UJywgZnVuY3Rpb24gKCkge1xuICAgIGN1cnNvci5zaG93KCk7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLmtpbGwocHJvY2Vzcy5waWQsICdTSUdJTlQnKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKExhbmRpbmcsIEJhc2UpO1xuXG5MYW5kaW5nLmRlc2NyaXB0aW9uID0gJ1VuaWNvZGUgbGFuZGluZyBzdHJpcCc7XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgTGlzdFxuICovXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuaW5oZXJpdHM7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1JVTl9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9SVU5fQkVHSU47XG52YXIgRVZFTlRfUlVOX0VORCA9IGNvbnN0YW50cy5FVkVOVF9SVU5fRU5EO1xudmFyIEVWRU5UX1RFU1RfQkVHSU4gPSBjb25zdGFudHMuRVZFTlRfVEVTVF9CRUdJTjtcbnZhciBFVkVOVF9URVNUX0ZBSUwgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9GQUlMO1xudmFyIEVWRU5UX1RFU1RfUEFTUyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BBU1M7XG52YXIgRVZFTlRfVEVTVF9QRU5ESU5HID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEVORElORztcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XG52YXIgY3Vyc29yID0gQmFzZS5jdXJzb3I7XG5cbi8qKlxuICogRXhwb3NlIGBMaXN0YC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBMaXN0O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYExpc3RgIHJlcG9ydGVyIGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXIgLSBJbnN0YW5jZSB0cmlnZ2VycyByZXBvcnRlciBhY3Rpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHJ1bm5lciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIExpc3QocnVubmVyLCBvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIsIG9wdGlvbnMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG4gPSAwO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9SVU5fQkVHSU4sIGZ1bmN0aW9uICgpIHtcbiAgICBCYXNlLmNvbnNvbGVMb2coKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfQkVHSU4sIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Bhc3MnLCAnICAgICcgKyB0ZXN0LmZ1bGxUaXRsZSgpICsgJzogJykpO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9QRU5ESU5HLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIHZhciBmbXQgPSBjb2xvcignY2hlY2ttYXJrJywgJyAgLScpICsgY29sb3IoJ3BlbmRpbmcnLCAnICVzJyk7XG4gICAgQmFzZS5jb25zb2xlTG9nKGZtdCwgdGVzdC5mdWxsVGl0bGUoKSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BBU1MsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgdmFyIGZtdCA9XG4gICAgICBjb2xvcignY2hlY2ttYXJrJywgJyAgJyArIEJhc2Uuc3ltYm9scy5vaykgK1xuICAgICAgY29sb3IoJ3Bhc3MnLCAnICVzOiAnKSArXG4gICAgICBjb2xvcih0ZXN0LnNwZWVkLCAnJWRtcycpO1xuICAgIGN1cnNvci5DUigpO1xuICAgIEJhc2UuY29uc29sZUxvZyhmbXQsIHRlc3QuZnVsbFRpdGxlKCksIHRlc3QuZHVyYXRpb24pO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9GQUlMLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIGN1cnNvci5DUigpO1xuICAgIEJhc2UuY29uc29sZUxvZyhjb2xvcignZmFpbCcsICcgICVkKSAlcycpLCArK24sIHRlc3QuZnVsbFRpdGxlKCkpO1xuICB9KTtcblxuICBydW5uZXIub25jZShFVkVOVF9SVU5fRU5ELCBzZWxmLmVwaWxvZ3VlLmJpbmQoc2VsZikpO1xufVxuXG4vKipcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxuICovXG5pbmhlcml0cyhMaXN0LCBCYXNlKTtcblxuTGlzdC5kZXNjcmlwdGlvbiA9ICdsaWtlIFwic3BlY1wiIHJlcG9ydGVyIGJ1dCBmbGF0JztcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBNYXJrZG93blxuICovXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1JVTl9FTkQgPSBjb25zdGFudHMuRVZFTlRfUlVOX0VORDtcbnZhciBFVkVOVF9TVUlURV9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9TVUlURV9CRUdJTjtcbnZhciBFVkVOVF9TVUlURV9FTkQgPSBjb25zdGFudHMuRVZFTlRfU1VJVEVfRU5EO1xudmFyIEVWRU5UX1RFU1RfUEFTUyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BBU1M7XG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxudmFyIFNVSVRFX1BSRUZJWCA9ICckJztcblxuLyoqXG4gKiBFeHBvc2UgYE1hcmtkb3duYC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBNYXJrZG93bjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBNYXJrZG93bmAgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gTWFya2Rvd24ocnVubmVyLCBvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIsIG9wdGlvbnMpO1xuXG4gIHZhciBsZXZlbCA9IDA7XG4gIHZhciBidWYgPSAnJztcblxuICBmdW5jdGlvbiB0aXRsZShzdHIpIHtcbiAgICByZXR1cm4gQXJyYXkobGV2ZWwpLmpvaW4oJyMnKSArICcgJyArIHN0cjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcFRPQyhzdWl0ZSwgb2JqKSB7XG4gICAgdmFyIHJldCA9IG9iajtcbiAgICB2YXIga2V5ID0gU1VJVEVfUFJFRklYICsgc3VpdGUudGl0bGU7XG5cbiAgICBvYmogPSBvYmpba2V5XSA9IG9ialtrZXldIHx8IHtzdWl0ZTogc3VpdGV9O1xuICAgIHN1aXRlLnN1aXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdWl0ZSkge1xuICAgICAgbWFwVE9DKHN1aXRlLCBvYmopO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeVRPQyhvYmosIGxldmVsKSB7XG4gICAgKytsZXZlbDtcbiAgICB2YXIgYnVmID0gJyc7XG4gICAgdmFyIGxpbms7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKGtleSA9PT0gJ3N1aXRlJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgIT09IFNVSVRFX1BSRUZJWCkge1xuICAgICAgICBsaW5rID0gJyAtIFsnICsga2V5LnN1YnN0cmluZygxKSArICddJztcbiAgICAgICAgbGluayArPSAnKCMnICsgdXRpbHMuc2x1ZyhvYmpba2V5XS5zdWl0ZS5mdWxsVGl0bGUoKSkgKyAnKVxcbic7XG4gICAgICAgIGJ1ZiArPSBBcnJheShsZXZlbCkuam9pbignICAnKSArIGxpbms7XG4gICAgICB9XG4gICAgICBidWYgKz0gc3RyaW5naWZ5VE9DKG9ialtrZXldLCBsZXZlbCk7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZVRPQyhzdWl0ZSkge1xuICAgIHZhciBvYmogPSBtYXBUT0Moc3VpdGUsIHt9KTtcbiAgICByZXR1cm4gc3RyaW5naWZ5VE9DKG9iaiwgMCk7XG4gIH1cblxuICBnZW5lcmF0ZVRPQyhydW5uZXIuc3VpdGUpO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9TVUlURV9CRUdJTiwgZnVuY3Rpb24gKHN1aXRlKSB7XG4gICAgKytsZXZlbDtcbiAgICB2YXIgc2x1ZyA9IHV0aWxzLnNsdWcoc3VpdGUuZnVsbFRpdGxlKCkpO1xuICAgIGJ1ZiArPSAnPGEgbmFtZT1cIicgKyBzbHVnICsgJ1wiPjwvYT4nICsgJ1xcbic7XG4gICAgYnVmICs9IHRpdGxlKHN1aXRlLnRpdGxlKSArICdcXG4nO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfU1VJVEVfRU5ELCBmdW5jdGlvbiAoKSB7XG4gICAgLS1sZXZlbDtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEFTUywgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICB2YXIgY29kZSA9IHV0aWxzLmNsZWFuKHRlc3QuYm9keSk7XG4gICAgYnVmICs9IHRlc3QudGl0bGUgKyAnLlxcbic7XG4gICAgYnVmICs9ICdcXG5gYGBqc1xcbic7XG4gICAgYnVmICs9IGNvZGUgKyAnXFxuJztcbiAgICBidWYgKz0gJ2BgYFxcblxcbic7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbmNlKEVWRU5UX1JVTl9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnIyBUT0NcXG4nKTtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShnZW5lcmF0ZVRPQyhydW5uZXIuc3VpdGUpKTtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShidWYpO1xuICB9KTtcbn1cblxuTWFya2Rvd24uZGVzY3JpcHRpb24gPSAnR2l0SHViIEZsYXZvcmVkIE1hcmtkb3duJztcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBNaW5cbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL3J1bm5lcicpLmNvbnN0YW50cztcbnZhciBFVkVOVF9SVU5fRU5EID0gY29uc3RhbnRzLkVWRU5UX1JVTl9FTkQ7XG52YXIgRVZFTlRfUlVOX0JFR0lOID0gY29uc3RhbnRzLkVWRU5UX1JVTl9CRUdJTjtcblxuLyoqXG4gKiBFeHBvc2UgYE1pbmAuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTWluO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYE1pbmAgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIG1pbmltYWwgdGVzdCByZXBvcnRlciBpcyBiZXN0IHVzZWQgd2l0aCAnLS13YXRjaCcuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gTWluKHJ1bm5lciwgb3B0aW9ucykge1xuICBCYXNlLmNhbGwodGhpcywgcnVubmVyLCBvcHRpb25zKTtcblxuICBydW5uZXIub24oRVZFTlRfUlVOX0JFR0lOLCBmdW5jdGlvbiAoKSB7XG4gICAgLy8gY2xlYXIgc2NyZWVuXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcdTAwMWJbMkonKTtcbiAgICAvLyBzZXQgY3Vyc29yIHBvc2l0aW9uXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcdTAwMWJbMTszSCcpO1xuICB9KTtcblxuICBydW5uZXIub25jZShFVkVOVF9SVU5fRU5ELCB0aGlzLmVwaWxvZ3VlLmJpbmQodGhpcykpO1xufVxuXG4vKipcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxuICovXG5pbmhlcml0cyhNaW4sIEJhc2UpO1xuXG5NaW4uZGVzY3JpcHRpb24gPSAnZXNzZW50aWFsbHkganVzdCBhIHN1bW1hcnknO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIE55YW5cbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcbnZhciBFVkVOVF9SVU5fQkVHSU4gPSBjb25zdGFudHMuRVZFTlRfUlVOX0JFR0lOO1xudmFyIEVWRU5UX1RFU1RfUEVORElORyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkc7XG52YXIgRVZFTlRfVEVTVF9QQVNTID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEFTUztcbnZhciBFVkVOVF9SVU5fRU5EID0gY29uc3RhbnRzLkVWRU5UX1JVTl9FTkQ7XG52YXIgRVZFTlRfVEVTVF9GQUlMID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfRkFJTDtcblxuLyoqXG4gKiBFeHBvc2UgYERvdGAuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTnlhbkNhdDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBOeWFuYCByZXBvcnRlciBpbnN0YW5jZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAY2xhc3MgTnlhblxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXIgLSBJbnN0YW5jZSB0cmlnZ2VycyByZXBvcnRlciBhY3Rpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHJ1bm5lciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIE55YW5DYXQocnVubmVyLCBvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIsIG9wdGlvbnMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHdpZHRoID0gKEJhc2Uud2luZG93LndpZHRoICogMC43NSkgfCAwO1xuICB2YXIgbnlhbkNhdFdpZHRoID0gKHRoaXMubnlhbkNhdFdpZHRoID0gMTEpO1xuXG4gIHRoaXMuY29sb3JJbmRleCA9IDA7XG4gIHRoaXMubnVtYmVyT2ZMaW5lcyA9IDQ7XG4gIHRoaXMucmFpbmJvd0NvbG9ycyA9IHNlbGYuZ2VuZXJhdGVDb2xvcnMoKTtcbiAgdGhpcy5zY29yZWJvYXJkV2lkdGggPSA1O1xuICB0aGlzLnRpY2sgPSAwO1xuICB0aGlzLnRyYWplY3RvcmllcyA9IFtbXSwgW10sIFtdLCBbXV07XG4gIHRoaXMudHJhamVjdG9yeVdpZHRoTWF4ID0gd2lkdGggLSBueWFuQ2F0V2lkdGg7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1JVTl9CRUdJTiwgZnVuY3Rpb24gKCkge1xuICAgIEJhc2UuY3Vyc29yLmhpZGUoKTtcbiAgICBzZWxmLmRyYXcoKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEVORElORywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZHJhdygpO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9QQVNTLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5kcmF3KCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX0ZBSUwsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmRyYXcoKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIEJhc2UuY3Vyc29yLnNob3coKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubnVtYmVyT2ZMaW5lczsgaSsrKSB7XG4gICAgICB3cml0ZSgnXFxuJyk7XG4gICAgfVxuICAgIHNlbGYuZXBpbG9ndWUoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKE55YW5DYXQsIEJhc2UpO1xuXG4vKipcbiAqIERyYXcgdGhlIG55YW4gY2F0XG4gKlxuICogQHByaXZhdGVcbiAqL1xuXG5OeWFuQ2F0LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFwcGVuZFJhaW5ib3coKTtcbiAgdGhpcy5kcmF3U2NvcmVib2FyZCgpO1xuICB0aGlzLmRyYXdSYWluYm93KCk7XG4gIHRoaXMuZHJhd055YW5DYXQoKTtcbiAgdGhpcy50aWNrID0gIXRoaXMudGljaztcbn07XG5cbi8qKlxuICogRHJhdyB0aGUgXCJzY29yZWJvYXJkXCIgc2hvd2luZyB0aGUgbnVtYmVyXG4gKiBvZiBwYXNzZXMsIGZhaWx1cmVzIGFuZCBwZW5kaW5nIHRlc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuTnlhbkNhdC5wcm90b3R5cGUuZHJhd1Njb3JlYm9hcmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XG5cbiAgZnVuY3Rpb24gZHJhdyh0eXBlLCBuKSB7XG4gICAgd3JpdGUoJyAnKTtcbiAgICB3cml0ZShCYXNlLmNvbG9yKHR5cGUsIG4pKTtcbiAgICB3cml0ZSgnXFxuJyk7XG4gIH1cblxuICBkcmF3KCdncmVlbicsIHN0YXRzLnBhc3Nlcyk7XG4gIGRyYXcoJ2ZhaWwnLCBzdGF0cy5mYWlsdXJlcyk7XG4gIGRyYXcoJ3BlbmRpbmcnLCBzdGF0cy5wZW5kaW5nKTtcbiAgd3JpdGUoJ1xcbicpO1xuXG4gIHRoaXMuY3Vyc29yVXAodGhpcy5udW1iZXJPZkxpbmVzKTtcbn07XG5cbi8qKlxuICogQXBwZW5kIHRoZSByYWluYm93LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuTnlhbkNhdC5wcm90b3R5cGUuYXBwZW5kUmFpbmJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlZ21lbnQgPSB0aGlzLnRpY2sgPyAnXycgOiAnLSc7XG4gIHZhciByYWluYm93aWZpZWQgPSB0aGlzLnJhaW5ib3dpZnkoc2VnbWVudCk7XG5cbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMubnVtYmVyT2ZMaW5lczsgaW5kZXgrKykge1xuICAgIHZhciB0cmFqZWN0b3J5ID0gdGhpcy50cmFqZWN0b3JpZXNbaW5kZXhdO1xuICAgIGlmICh0cmFqZWN0b3J5Lmxlbmd0aCA+PSB0aGlzLnRyYWplY3RvcnlXaWR0aE1heCkge1xuICAgICAgdHJhamVjdG9yeS5zaGlmdCgpO1xuICAgIH1cbiAgICB0cmFqZWN0b3J5LnB1c2gocmFpbmJvd2lmaWVkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEcmF3IHRoZSByYWluYm93LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuTnlhbkNhdC5wcm90b3R5cGUuZHJhd1JhaW5ib3cgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnRyYWplY3Rvcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgd3JpdGUoJ1xcdTAwMWJbJyArIHNlbGYuc2NvcmVib2FyZFdpZHRoICsgJ0MnKTtcbiAgICB3cml0ZShsaW5lLmpvaW4oJycpKTtcbiAgICB3cml0ZSgnXFxuJyk7XG4gIH0pO1xuXG4gIHRoaXMuY3Vyc29yVXAodGhpcy5udW1iZXJPZkxpbmVzKTtcbn07XG5cbi8qKlxuICogRHJhdyB0aGUgbnlhbiBjYXRcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5OeWFuQ2F0LnByb3RvdHlwZS5kcmF3TnlhbkNhdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc3RhcnRXaWR0aCA9IHRoaXMuc2NvcmVib2FyZFdpZHRoICsgdGhpcy50cmFqZWN0b3JpZXNbMF0ubGVuZ3RoO1xuICB2YXIgZGlzdCA9ICdcXHUwMDFiWycgKyBzdGFydFdpZHRoICsgJ0MnO1xuICB2YXIgcGFkZGluZyA9ICcnO1xuXG4gIHdyaXRlKGRpc3QpO1xuICB3cml0ZSgnXywtLS0tLS0sJyk7XG4gIHdyaXRlKCdcXG4nKTtcblxuICB3cml0ZShkaXN0KTtcbiAgcGFkZGluZyA9IHNlbGYudGljayA/ICcgICcgOiAnICAgJztcbiAgd3JpdGUoJ198JyArIHBhZGRpbmcgKyAnL1xcXFxfL1xcXFwgJyk7XG4gIHdyaXRlKCdcXG4nKTtcblxuICB3cml0ZShkaXN0KTtcbiAgcGFkZGluZyA9IHNlbGYudGljayA/ICdfJyA6ICdfXyc7XG4gIHZhciB0YWlsID0gc2VsZi50aWNrID8gJ34nIDogJ14nO1xuICB3cml0ZSh0YWlsICsgJ3wnICsgcGFkZGluZyArIHRoaXMuZmFjZSgpICsgJyAnKTtcbiAgd3JpdGUoJ1xcbicpO1xuXG4gIHdyaXRlKGRpc3QpO1xuICBwYWRkaW5nID0gc2VsZi50aWNrID8gJyAnIDogJyAgJztcbiAgd3JpdGUocGFkZGluZyArICdcIlwiICBcIlwiICcpO1xuICB3cml0ZSgnXFxuJyk7XG5cbiAgdGhpcy5jdXJzb3JVcCh0aGlzLm51bWJlck9mTGluZXMpO1xufTtcblxuLyoqXG4gKiBEcmF3IG55YW4gY2F0IGZhY2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5OeWFuQ2F0LnByb3RvdHlwZS5mYWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICBpZiAoc3RhdHMuZmFpbHVyZXMpIHtcbiAgICByZXR1cm4gJyggeCAueCknO1xuICB9IGVsc2UgaWYgKHN0YXRzLnBlbmRpbmcpIHtcbiAgICByZXR1cm4gJyggbyAubyknO1xuICB9IGVsc2UgaWYgKHN0YXRzLnBhc3Nlcykge1xuICAgIHJldHVybiAnKCBeIC5eKSc7XG4gIH1cbiAgcmV0dXJuICcoIC0gLi0pJztcbn07XG5cbi8qKlxuICogTW92ZSBjdXJzb3IgdXAgYG5gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gblxuICovXG5cbk55YW5DYXQucHJvdG90eXBlLmN1cnNvclVwID0gZnVuY3Rpb24gKG4pIHtcbiAgd3JpdGUoJ1xcdTAwMWJbJyArIG4gKyAnQScpO1xufTtcblxuLyoqXG4gKiBNb3ZlIGN1cnNvciBkb3duIGBuYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqL1xuXG5OeWFuQ2F0LnByb3RvdHlwZS5jdXJzb3JEb3duID0gZnVuY3Rpb24gKG4pIHtcbiAgd3JpdGUoJ1xcdTAwMWJbJyArIG4gKyAnQicpO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSByYWluYm93IGNvbG9ycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbk55YW5DYXQucHJvdG90eXBlLmdlbmVyYXRlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY29sb3JzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA2ICogNzsgaSsrKSB7XG4gICAgdmFyIHBpMyA9IE1hdGguZmxvb3IoTWF0aC5QSSAvIDMpO1xuICAgIHZhciBuID0gaSAqICgxLjAgLyA2KTtcbiAgICB2YXIgciA9IE1hdGguZmxvb3IoMyAqIE1hdGguc2luKG4pICsgMyk7XG4gICAgdmFyIGcgPSBNYXRoLmZsb29yKDMgKiBNYXRoLnNpbihuICsgMiAqIHBpMykgKyAzKTtcbiAgICB2YXIgYiA9IE1hdGguZmxvb3IoMyAqIE1hdGguc2luKG4gKyA0ICogcGkzKSArIDMpO1xuICAgIGNvbG9ycy5wdXNoKDM2ICogciArIDYgKiBnICsgYiArIDE2KTtcbiAgfVxuXG4gIHJldHVybiBjb2xvcnM7XG59O1xuXG4vKipcbiAqIEFwcGx5IHJhaW5ib3cgdG8gdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbk55YW5DYXQucHJvdG90eXBlLnJhaW5ib3dpZnkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGlmICghQmFzZS51c2VDb2xvcnMpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHZhciBjb2xvciA9IHRoaXMucmFpbmJvd0NvbG9yc1t0aGlzLmNvbG9ySW5kZXggJSB0aGlzLnJhaW5ib3dDb2xvcnMubGVuZ3RoXTtcbiAgdGhpcy5jb2xvckluZGV4ICs9IDE7XG4gIHJldHVybiAnXFx1MDAxYlszODs1OycgKyBjb2xvciArICdtJyArIHN0ciArICdcXHUwMDFiWzBtJztcbn07XG5cbi8qKlxuICogU3Rkb3V0IGhlbHBlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIEEgbWVzc2FnZSB0byB3cml0ZSB0byBzdGRvdXQuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlKHN0cmluZykge1xuICBwcm9jZXNzLnN0ZG91dC53cml0ZShzdHJpbmcpO1xufVxuXG5OeWFuQ2F0LmRlc2NyaXB0aW9uID0gJ1wibnlhbiBjYXRcIic7XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgUHJvZ3Jlc3NcbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1JVTl9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9SVU5fQkVHSU47XG52YXIgRVZFTlRfVEVTVF9FTkQgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9FTkQ7XG52YXIgRVZFTlRfUlVOX0VORCA9IGNvbnN0YW50cy5FVkVOVF9SVU5fRU5EO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XG52YXIgY3Vyc29yID0gQmFzZS5jdXJzb3I7XG5cbi8qKlxuICogRXhwb3NlIGBQcm9ncmVzc2AuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gUHJvZ3Jlc3M7XG5cbi8qKlxuICogR2VuZXJhbCBwcm9ncmVzcyBiYXIgY29sb3IuXG4gKi9cblxuQmFzZS5jb2xvcnMucHJvZ3Jlc3MgPSA5MDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBQcm9ncmVzc2AgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUHJvZ3Jlc3MocnVubmVyLCBvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIsIG9wdGlvbnMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHdpZHRoID0gKEJhc2Uud2luZG93LndpZHRoICogMC41KSB8IDA7XG4gIHZhciB0b3RhbCA9IHJ1bm5lci50b3RhbDtcbiAgdmFyIGNvbXBsZXRlID0gMDtcbiAgdmFyIGxhc3ROID0gLTE7XG5cbiAgLy8gZGVmYXVsdCBjaGFyc1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHJlcG9ydGVyT3B0aW9ucyA9IG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zIHx8IHt9O1xuXG4gIG9wdGlvbnMub3BlbiA9IHJlcG9ydGVyT3B0aW9ucy5vcGVuIHx8ICdbJztcbiAgb3B0aW9ucy5jb21wbGV0ZSA9IHJlcG9ydGVyT3B0aW9ucy5jb21wbGV0ZSB8fCAn4pasJztcbiAgb3B0aW9ucy5pbmNvbXBsZXRlID0gcmVwb3J0ZXJPcHRpb25zLmluY29tcGxldGUgfHwgQmFzZS5zeW1ib2xzLmRvdDtcbiAgb3B0aW9ucy5jbG9zZSA9IHJlcG9ydGVyT3B0aW9ucy5jbG9zZSB8fCAnXSc7XG4gIG9wdGlvbnMudmVyYm9zZSA9IHJlcG9ydGVyT3B0aW9ucy52ZXJib3NlIHx8IGZhbHNlO1xuXG4gIC8vIHRlc3RzIHN0YXJ0ZWRcbiAgcnVubmVyLm9uKEVWRU5UX1JVTl9CRUdJTiwgZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXG4nKTtcbiAgICBjdXJzb3IuaGlkZSgpO1xuICB9KTtcblxuICAvLyB0ZXN0cyBjb21wbGV0ZVxuICBydW5uZXIub24oRVZFTlRfVEVTVF9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICBjb21wbGV0ZSsrO1xuXG4gICAgdmFyIHBlcmNlbnQgPSBjb21wbGV0ZSAvIHRvdGFsO1xuICAgIHZhciBuID0gKHdpZHRoICogcGVyY2VudCkgfCAwO1xuICAgIHZhciBpID0gd2lkdGggLSBuO1xuXG4gICAgaWYgKG4gPT09IGxhc3ROICYmICFvcHRpb25zLnZlcmJvc2UpIHtcbiAgICAgIC8vIERvbid0IHJlLXJlbmRlciB0aGUgbGluZSBpZiBpdCBoYXNuJ3QgY2hhbmdlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsYXN0TiA9IG47XG5cbiAgICBjdXJzb3IuQ1IoKTtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFx1MDAxYltKJyk7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Byb2dyZXNzJywgJyAgJyArIG9wdGlvbnMub3BlbikpO1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEFycmF5KG4pLmpvaW4ob3B0aW9ucy5jb21wbGV0ZSkpO1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEFycmF5KGkpLmpvaW4ob3B0aW9ucy5pbmNvbXBsZXRlKSk7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Byb2dyZXNzJywgb3B0aW9ucy5jbG9zZSkpO1xuICAgIGlmIChvcHRpb25zLnZlcmJvc2UpIHtcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdwcm9ncmVzcycsICcgJyArIGNvbXBsZXRlICsgJyBvZiAnICsgdG90YWwpKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHRlc3RzIGFyZSBjb21wbGV0ZSwgb3V0cHV0IHNvbWUgc3RhdHNcbiAgLy8gYW5kIHRoZSBmYWlsdXJlcyBpZiBhbnlcbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIGN1cnNvci5zaG93KCk7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcbicpO1xuICAgIHNlbGYuZXBpbG9ndWUoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKFByb2dyZXNzLCBCYXNlKTtcblxuUHJvZ3Jlc3MuZGVzY3JpcHRpb24gPSAnYSBwcm9ncmVzcyBiYXInO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIFNwZWNcbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1JVTl9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9SVU5fQkVHSU47XG52YXIgRVZFTlRfUlVOX0VORCA9IGNvbnN0YW50cy5FVkVOVF9SVU5fRU5EO1xudmFyIEVWRU5UX1NVSVRFX0JFR0lOID0gY29uc3RhbnRzLkVWRU5UX1NVSVRFX0JFR0lOO1xudmFyIEVWRU5UX1NVSVRFX0VORCA9IGNvbnN0YW50cy5FVkVOVF9TVUlURV9FTkQ7XG52YXIgRVZFTlRfVEVTVF9GQUlMID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfRkFJTDtcbnZhciBFVkVOVF9URVNUX1BBU1MgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9QQVNTO1xudmFyIEVWRU5UX1RFU1RfUEVORElORyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkc7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xudmFyIGNvbG9yID0gQmFzZS5jb2xvcjtcblxuLyoqXG4gKiBFeHBvc2UgYFNwZWNgLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFNwZWM7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgU3BlY2AgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gU3BlYyhydW5uZXIsIG9wdGlvbnMpIHtcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lciwgb3B0aW9ucyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgaW5kZW50cyA9IDA7XG4gIHZhciBuID0gMDtcblxuICBmdW5jdGlvbiBpbmRlbnQoKSB7XG4gICAgcmV0dXJuIEFycmF5KGluZGVudHMpLmpvaW4oJyAgJyk7XG4gIH1cblxuICBydW5uZXIub24oRVZFTlRfUlVOX0JFR0lOLCBmdW5jdGlvbiAoKSB7XG4gICAgQmFzZS5jb25zb2xlTG9nKCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9TVUlURV9CRUdJTiwgZnVuY3Rpb24gKHN1aXRlKSB7XG4gICAgKytpbmRlbnRzO1xuICAgIEJhc2UuY29uc29sZUxvZyhjb2xvcignc3VpdGUnLCAnJXMlcycpLCBpbmRlbnQoKSwgc3VpdGUudGl0bGUpO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfU1VJVEVfRU5ELCBmdW5jdGlvbiAoKSB7XG4gICAgLS1pbmRlbnRzO1xuICAgIGlmIChpbmRlbnRzID09PSAxKSB7XG4gICAgICBCYXNlLmNvbnNvbGVMb2coKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BFTkRJTkcsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgdmFyIGZtdCA9IGluZGVudCgpICsgY29sb3IoJ3BlbmRpbmcnLCAnICAtICVzJyk7XG4gICAgQmFzZS5jb25zb2xlTG9nKGZtdCwgdGVzdC50aXRsZSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BBU1MsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgdmFyIGZtdDtcbiAgICBpZiAodGVzdC5zcGVlZCA9PT0gJ2Zhc3QnKSB7XG4gICAgICBmbXQgPVxuICAgICAgICBpbmRlbnQoKSArXG4gICAgICAgIGNvbG9yKCdjaGVja21hcmsnLCAnICAnICsgQmFzZS5zeW1ib2xzLm9rKSArXG4gICAgICAgIGNvbG9yKCdwYXNzJywgJyAlcycpO1xuICAgICAgQmFzZS5jb25zb2xlTG9nKGZtdCwgdGVzdC50aXRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZtdCA9XG4gICAgICAgIGluZGVudCgpICtcbiAgICAgICAgY29sb3IoJ2NoZWNrbWFyaycsICcgICcgKyBCYXNlLnN5bWJvbHMub2spICtcbiAgICAgICAgY29sb3IoJ3Bhc3MnLCAnICVzJykgK1xuICAgICAgICBjb2xvcih0ZXN0LnNwZWVkLCAnICglZG1zKScpO1xuICAgICAgQmFzZS5jb25zb2xlTG9nKGZtdCwgdGVzdC50aXRsZSwgdGVzdC5kdXJhdGlvbik7XG4gICAgfVxuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9GQUlMLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIEJhc2UuY29uc29sZUxvZyhpbmRlbnQoKSArIGNvbG9yKCdmYWlsJywgJyAgJWQpICVzJyksICsrbiwgdGVzdC50aXRsZSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbmNlKEVWRU5UX1JVTl9FTkQsIHNlbGYuZXBpbG9ndWUuYmluZChzZWxmKSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKFNwZWMsIEJhc2UpO1xuXG5TcGVjLmRlc2NyaXB0aW9uID0gJ2hpZXJhcmNoaWNhbCAmIHZlcmJvc2UgW2RlZmF1bHRdJztcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBUQVBcbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9ydW5uZXInKS5jb25zdGFudHM7XG52YXIgRVZFTlRfVEVTVF9QQVNTID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEFTUztcbnZhciBFVkVOVF9URVNUX0ZBSUwgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9GQUlMO1xudmFyIEVWRU5UX1JVTl9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9SVU5fQkVHSU47XG52YXIgRVZFTlRfUlVOX0VORCA9IGNvbnN0YW50cy5FVkVOVF9SVU5fRU5EO1xudmFyIEVWRU5UX1RFU1RfUEVORElORyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkc7XG52YXIgRVZFTlRfVEVTVF9FTkQgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9FTkQ7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xudmFyIHNwcmludGYgPSB1dGlsLmZvcm1hdDtcblxuLyoqXG4gKiBFeHBvc2UgYFRBUGAuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gVEFQO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYFRBUGAgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gVEFQKHJ1bm5lciwgb3B0aW9ucykge1xuICBCYXNlLmNhbGwodGhpcywgcnVubmVyLCBvcHRpb25zKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBuID0gMTtcblxuICB2YXIgdGFwVmVyc2lvbiA9ICcxMic7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zLnRhcFZlcnNpb24pIHtcbiAgICAgIHRhcFZlcnNpb24gPSBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy50YXBWZXJzaW9uLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fcHJvZHVjZXIgPSBjcmVhdGVQcm9kdWNlcih0YXBWZXJzaW9uKTtcblxuICBydW5uZXIub25jZShFVkVOVF9SVU5fQkVHSU4sIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9wcm9kdWNlci53cml0ZVZlcnNpb24oKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfRU5ELCBmdW5jdGlvbiAoKSB7XG4gICAgKytuO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9QRU5ESU5HLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIHNlbGYuX3Byb2R1Y2VyLndyaXRlUGVuZGluZyhuLCB0ZXN0KTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEFTUywgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICBzZWxmLl9wcm9kdWNlci53cml0ZVBhc3MobiwgdGVzdCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX0ZBSUwsIGZ1bmN0aW9uICh0ZXN0LCBlcnIpIHtcbiAgICBzZWxmLl9wcm9kdWNlci53cml0ZUZhaWwobiwgdGVzdCwgZXJyKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX3Byb2R1Y2VyLndyaXRlRXBpbG9ndWUocnVubmVyLnN0YXRzKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKFRBUCwgQmFzZSk7XG5cbi8qKlxuICogUmV0dXJucyBhIFRBUC1zYWZlIHRpdGxlIG9mIGB0ZXN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtUZXN0fSB0ZXN0IC0gVGVzdCBpbnN0YW5jZS5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGl0bGUgd2l0aCBhbnkgaGFzaCBjaGFyYWN0ZXIgcmVtb3ZlZFxuICovXG5mdW5jdGlvbiB0aXRsZSh0ZXN0KSB7XG4gIHJldHVybiB0ZXN0LmZ1bGxUaXRsZSgpLnJlcGxhY2UoLyMvZywgJycpO1xufVxuXG4vKipcbiAqIFdyaXRlcyBuZXdsaW5lLXRlcm1pbmF0ZWQgZm9ybWF0dGVkIHN0cmluZyB0byByZXBvcnRlciBvdXRwdXQgc3RyZWFtLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IC0gYHByaW50ZmAtbGlrZSBmb3JtYXQgc3RyaW5nXG4gKiBAcGFyYW0gey4uLip9IFt2YXJBcmdzXSAtIEZvcm1hdCBzdHJpbmcgYXJndW1lbnRzXG4gKi9cbmZ1bmN0aW9uIHByaW50bG4oZm9ybWF0LCB2YXJBcmdzKSB7XG4gIHZhciB2YXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcbiAgdmFyZ3NbMF0gKz0gJ1xcbic7XG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKHNwcmludGYuYXBwbHkobnVsbCwgdmFyZ3MpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgYHRhcFZlcnNpb25gLWFwcHJvcHJpYXRlIFRBUCBwcm9kdWNlciBpbnN0YW5jZSwgaWYgcG9zc2libGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YXBWZXJzaW9uIC0gVmVyc2lvbiBvZiBUQVAgc3BlY2lmaWNhdGlvbiB0byBwcm9kdWNlLlxuICogQHJldHVybnMge1RBUFByb2R1Y2VyfSBzcGVjaWZpY2F0aW9uLWFwcHJvcHJpYXRlIGluc3RhbmNlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgc3BlY2lmaWNhdGlvbiB2ZXJzaW9uIGhhcyBubyBhc3NvY2lhdGVkIHByb2R1Y2VyLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQcm9kdWNlcih0YXBWZXJzaW9uKSB7XG4gIHZhciBwcm9kdWNlcnMgPSB7XG4gICAgMTI6IG5ldyBUQVAxMlByb2R1Y2VyKCksXG4gICAgMTM6IG5ldyBUQVAxM1Byb2R1Y2VyKClcbiAgfTtcbiAgdmFyIHByb2R1Y2VyID0gcHJvZHVjZXJzW3RhcFZlcnNpb25dO1xuXG4gIGlmICghcHJvZHVjZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnaW52YWxpZCBvciB1bnN1cHBvcnRlZCBUQVAgdmVyc2lvbjogJyArIEpTT04uc3RyaW5naWZ5KHRhcFZlcnNpb24pXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBwcm9kdWNlcjtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeVxuICogQ29uc3RydWN0cyBhIG5ldyBUQVBQcm9kdWNlci5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIDxlbT5Pbmx5PC9lbT4gdG8gYmUgdXNlZCBhcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVEFQUHJvZHVjZXIoKSB7fVxuXG4vKipcbiAqIFdyaXRlcyB0aGUgVEFQIHZlcnNpb24gdG8gcmVwb3J0ZXIgb3V0cHV0IHN0cmVhbS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuVEFQUHJvZHVjZXIucHJvdG90eXBlLndyaXRlVmVyc2lvbiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vKipcbiAqIFdyaXRlcyB0aGUgcGxhbiB0byByZXBvcnRlciBvdXRwdXQgc3RyZWFtLlxuICpcbiAqIEBhYnN0cmFjdFxuICogQHBhcmFtIHtudW1iZXJ9IG50ZXN0cyAtIE51bWJlciBvZiB0ZXN0cyB0aGF0IGFyZSBwbGFubmVkIHRvIHJ1bi5cbiAqL1xuVEFQUHJvZHVjZXIucHJvdG90eXBlLndyaXRlUGxhbiA9IGZ1bmN0aW9uIChudGVzdHMpIHtcbiAgcHJpbnRsbignJWQuLiVkJywgMSwgbnRlc3RzKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIHRoYXQgdGVzdCBwYXNzZWQgdG8gcmVwb3J0ZXIgb3V0cHV0IHN0cmVhbS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gSW5kZXggb2YgdGVzdCB0aGF0IHBhc3NlZC5cbiAqIEBwYXJhbSB7VGVzdH0gdGVzdCAtIEluc3RhbmNlIGNvbnRhaW5pbmcgdGVzdCBpbmZvcm1hdGlvbi5cbiAqL1xuVEFQUHJvZHVjZXIucHJvdG90eXBlLndyaXRlUGFzcyA9IGZ1bmN0aW9uIChuLCB0ZXN0KSB7XG4gIHByaW50bG4oJ29rICVkICVzJywgbiwgdGl0bGUodGVzdCkpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgdGhhdCB0ZXN0IHdhcyBza2lwcGVkIHRvIHJlcG9ydGVyIG91dHB1dCBzdHJlYW0uXG4gKlxuICogQGFic3RyYWN0XG4gKiBAcGFyYW0ge251bWJlcn0gbiAtIEluZGV4IG9mIHRlc3QgdGhhdCB3YXMgc2tpcHBlZC5cbiAqIEBwYXJhbSB7VGVzdH0gdGVzdCAtIEluc3RhbmNlIGNvbnRhaW5pbmcgdGVzdCBpbmZvcm1hdGlvbi5cbiAqL1xuVEFQUHJvZHVjZXIucHJvdG90eXBlLndyaXRlUGVuZGluZyA9IGZ1bmN0aW9uIChuLCB0ZXN0KSB7XG4gIHByaW50bG4oJ29rICVkICVzICMgU0tJUCAtJywgbiwgdGl0bGUodGVzdCkpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgdGhhdCB0ZXN0IGZhaWxlZCB0byByZXBvcnRlciBvdXRwdXQgc3RyZWFtLlxuICpcbiAqIEBhYnN0cmFjdFxuICogQHBhcmFtIHtudW1iZXJ9IG4gLSBJbmRleCBvZiB0ZXN0IHRoYXQgZmFpbGVkLlxuICogQHBhcmFtIHtUZXN0fSB0ZXN0IC0gSW5zdGFuY2UgY29udGFpbmluZyB0ZXN0IGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gUmVhc29uIHRoZSB0ZXN0IGZhaWxlZC5cbiAqL1xuVEFQUHJvZHVjZXIucHJvdG90eXBlLndyaXRlRmFpbCA9IGZ1bmN0aW9uIChuLCB0ZXN0LCBlcnIpIHtcbiAgcHJpbnRsbignbm90IG9rICVkICVzJywgbiwgdGl0bGUodGVzdCkpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgdGhlIHN1bW1hcnkgZXBpbG9ndWUgdG8gcmVwb3J0ZXIgb3V0cHV0IHN0cmVhbS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0cyAtIE9iamVjdCBjb250YWluaW5nIHJ1biBzdGF0aXN0aWNzLlxuICovXG5UQVBQcm9kdWNlci5wcm90b3R5cGUud3JpdGVFcGlsb2d1ZSA9IGZ1bmN0aW9uIChzdGF0cykge1xuICAvLyA6VEJEOiBXaHkgaXMgdGhpcyBub3QgY291bnRpbmcgcGVuZGluZyB0ZXN0cz9cbiAgcHJpbnRsbignIyB0ZXN0cyAnICsgKHN0YXRzLnBhc3NlcyArIHN0YXRzLmZhaWx1cmVzKSk7XG4gIHByaW50bG4oJyMgcGFzcyAnICsgc3RhdHMucGFzc2VzKTtcbiAgLy8gOlRCRDogV2h5IGFyZSB3ZSBub3Qgc2hvd2luZyBwZW5kaW5nIHJlc3VsdHM/XG4gIHByaW50bG4oJyMgZmFpbCAnICsgc3RhdHMuZmFpbHVyZXMpO1xuICB0aGlzLndyaXRlUGxhbihzdGF0cy5wYXNzZXMgKyBzdGF0cy5mYWlsdXJlcyArIHN0YXRzLnBlbmRpbmcpO1xufTtcblxuLyoqXG4gKiBAc3VtbWFyeVxuICogQ29uc3RydWN0cyBhIG5ldyBUQVAxMlByb2R1Y2VyLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUHJvZHVjZXMgb3V0cHV0IGNvbmZvcm1pbmcgdG8gdGhlIFRBUDEyIHNwZWNpZmljYXRpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgVEFQUHJvZHVjZXJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdGVzdGFueXRoaW5nLm9yZy90YXAtc3BlY2lmaWNhdGlvbi5odG1sfFNwZWNpZmljYXRpb259XG4gKi9cbmZ1bmN0aW9uIFRBUDEyUHJvZHVjZXIoKSB7XG4gIC8qKlxuICAgKiBXcml0ZXMgdGhhdCB0ZXN0IGZhaWxlZCB0byByZXBvcnRlciBvdXRwdXQgc3RyZWFtLCB3aXRoIGVycm9yIGZvcm1hdHRpbmcuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgdGhpcy53cml0ZUZhaWwgPSBmdW5jdGlvbiAobiwgdGVzdCwgZXJyKSB7XG4gICAgVEFQUHJvZHVjZXIucHJvdG90eXBlLndyaXRlRmFpbC5jYWxsKHRoaXMsIG4sIHRlc3QsIGVycik7XG4gICAgaWYgKGVyci5tZXNzYWdlKSB7XG4gICAgICBwcmludGxuKGVyci5tZXNzYWdlLnJlcGxhY2UoL14vZ20sICcgICcpKTtcbiAgICB9XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgcHJpbnRsbihlcnIuc3RhY2sucmVwbGFjZSgvXi9nbSwgJyAgJykpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBJbmhlcml0IGZyb20gYFRBUFByb2R1Y2VyLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKFRBUDEyUHJvZHVjZXIsIFRBUFByb2R1Y2VyKTtcblxuLyoqXG4gKiBAc3VtbWFyeVxuICogQ29uc3RydWN0cyBhIG5ldyBUQVAxM1Byb2R1Y2VyLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUHJvZHVjZXMgb3V0cHV0IGNvbmZvcm1pbmcgdG8gdGhlIFRBUDEzIHNwZWNpZmljYXRpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgVEFQUHJvZHVjZXJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdGVzdGFueXRoaW5nLm9yZy90YXAtdmVyc2lvbi0xMy1zcGVjaWZpY2F0aW9uLmh0bWx8U3BlY2lmaWNhdGlvbn1cbiAqL1xuZnVuY3Rpb24gVEFQMTNQcm9kdWNlcigpIHtcbiAgLyoqXG4gICAqIFdyaXRlcyB0aGUgVEFQIHZlcnNpb24gdG8gcmVwb3J0ZXIgb3V0cHV0IHN0cmVhbS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICB0aGlzLndyaXRlVmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcmludGxuKCdUQVAgdmVyc2lvbiAxMycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXcml0ZXMgdGhhdCB0ZXN0IGZhaWxlZCB0byByZXBvcnRlciBvdXRwdXQgc3RyZWFtLCB3aXRoIGVycm9yIGZvcm1hdHRpbmcuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgdGhpcy53cml0ZUZhaWwgPSBmdW5jdGlvbiAobiwgdGVzdCwgZXJyKSB7XG4gICAgVEFQUHJvZHVjZXIucHJvdG90eXBlLndyaXRlRmFpbC5jYWxsKHRoaXMsIG4sIHRlc3QsIGVycik7XG4gICAgdmFyIGVtaXRZYW1sQmxvY2sgPSBlcnIubWVzc2FnZSAhPSBudWxsIHx8IGVyci5zdGFjayAhPSBudWxsO1xuICAgIGlmIChlbWl0WWFtbEJsb2NrKSB7XG4gICAgICBwcmludGxuKGluZGVudCgxKSArICctLS0nKTtcbiAgICAgIGlmIChlcnIubWVzc2FnZSkge1xuICAgICAgICBwcmludGxuKGluZGVudCgyKSArICdtZXNzYWdlOiB8LScpO1xuICAgICAgICBwcmludGxuKGVyci5tZXNzYWdlLnJlcGxhY2UoL14vZ20sIGluZGVudCgzKSkpO1xuICAgICAgfVxuICAgICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgICBwcmludGxuKGluZGVudCgyKSArICdzdGFjazogfC0nKTtcbiAgICAgICAgcHJpbnRsbihlcnIuc3RhY2sucmVwbGFjZSgvXi9nbSwgaW5kZW50KDMpKSk7XG4gICAgICB9XG4gICAgICBwcmludGxuKGluZGVudCgxKSArICcuLi4nKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5kZW50KGxldmVsKSB7XG4gICAgcmV0dXJuIEFycmF5KGxldmVsICsgMSkuam9pbignICAnKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXQgZnJvbSBgVEFQUHJvZHVjZXIucHJvdG90eXBlYC5cbiAqL1xuaW5oZXJpdHMoVEFQMTNQcm9kdWNlciwgVEFQUHJvZHVjZXIpO1xuXG5UQVAuZGVzY3JpcHRpb24gPSAnVEFQLWNvbXBhdGlibGUgb3V0cHV0JztcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBYVW5pdFxuICovXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG52YXIgY3JlYXRlVW5zdXBwb3J0ZWRFcnJvciA9IGVycm9ycy5jcmVhdGVVbnN1cHBvcnRlZEVycm9yO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL3J1bm5lcicpLmNvbnN0YW50cztcbnZhciBFVkVOVF9URVNUX1BBU1MgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9QQVNTO1xudmFyIEVWRU5UX1RFU1RfRkFJTCA9IGNvbnN0YW50cy5FVkVOVF9URVNUX0ZBSUw7XG52YXIgRVZFTlRfUlVOX0VORCA9IGNvbnN0YW50cy5FVkVOVF9SVU5fRU5EO1xudmFyIEVWRU5UX1RFU1RfUEVORElORyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkc7XG52YXIgU1RBVEVfRkFJTEVEID0gcmVxdWlyZSgnLi4vcnVubmFibGUnKS5jb25zdGFudHMuU1RBVEVfRkFJTEVEO1xudmFyIGluaGVyaXRzID0gdXRpbHMuaW5oZXJpdHM7XG52YXIgZXNjYXBlID0gdXRpbHMuZXNjYXBlO1xuXG4vKipcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXG4gKi9cbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XG5cbi8qKlxuICogRXhwb3NlIGBYVW5pdGAuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gWFVuaXQ7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgWFVuaXRgIHJlcG9ydGVyIGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXIgLSBJbnN0YW5jZSB0cmlnZ2VycyByZXBvcnRlciBhY3Rpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHJ1bm5lciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFhVbml0KHJ1bm5lciwgb3B0aW9ucykge1xuICBCYXNlLmNhbGwodGhpcywgcnVubmVyLCBvcHRpb25zKTtcblxuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICB2YXIgdGVzdHMgPSBbXTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIHRoZSBuYW1lIG9mIHRoZSB0ZXN0IHN1aXRlLCBhcyBpdCB3aWxsIGFwcGVhciBpbiB0aGUgcmVzdWx0aW5nIFhNTCBmaWxlXG4gIHZhciBzdWl0ZU5hbWU7XG5cbiAgLy8gdGhlIGRlZmF1bHQgbmFtZSBvZiB0aGUgdGVzdCBzdWl0ZSBpZiBub25lIGlzIHByb3ZpZGVkXG4gIHZhciBERUZBVUxUX1NVSVRFX05BTUUgPSAnTW9jaGEgVGVzdHMnO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zLm91dHB1dCkge1xuICAgICAgaWYgKCFmcy5jcmVhdGVXcml0ZVN0cmVhbSkge1xuICAgICAgICB0aHJvdyBjcmVhdGVVbnN1cHBvcnRlZEVycm9yKCdmaWxlIG91dHB1dCBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXInKTtcbiAgICAgIH1cblxuICAgICAgZnMubWtkaXJTeW5jKHBhdGguZGlybmFtZShvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy5vdXRwdXQpLCB7XG4gICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBzZWxmLmZpbGVTdHJlYW0gPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy5vdXRwdXQpO1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgc3VpdGUgbmFtZSBmcm9tIHRoZSByZXBvcnRlciBvcHRpb25zIChpZiBwcm92aWRlZClcbiAgICBzdWl0ZU5hbWUgPSBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy5zdWl0ZU5hbWU7XG4gIH1cblxuICAvLyBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgc3VpdGUgbmFtZVxuICBzdWl0ZU5hbWUgPSBzdWl0ZU5hbWUgfHwgREVGQVVMVF9TVUlURV9OQU1FO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BFTkRJTkcsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgdGVzdHMucHVzaCh0ZXN0KTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEFTUywgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICB0ZXN0cy5wdXNoKHRlc3QpO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9GQUlMLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIHRlc3RzLnB1c2godGVzdCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbmNlKEVWRU5UX1JVTl9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLndyaXRlKFxuICAgICAgdGFnKFxuICAgICAgICAndGVzdHN1aXRlJyxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IHN1aXRlTmFtZSxcbiAgICAgICAgICB0ZXN0czogc3RhdHMudGVzdHMsXG4gICAgICAgICAgZmFpbHVyZXM6IDAsXG4gICAgICAgICAgZXJyb3JzOiBzdGF0cy5mYWlsdXJlcyxcbiAgICAgICAgICBza2lwcGVkOiBzdGF0cy50ZXN0cyAtIHN0YXRzLmZhaWx1cmVzIC0gc3RhdHMucGFzc2VzLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b1VUQ1N0cmluZygpLFxuICAgICAgICAgIHRpbWU6IHN0YXRzLmR1cmF0aW9uIC8gMTAwMCB8fCAwXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgICApXG4gICAgKTtcblxuICAgIHRlc3RzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgIHNlbGYudGVzdCh0KTtcbiAgICB9KTtcblxuICAgIHNlbGYud3JpdGUoJzwvdGVzdHN1aXRlPicpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cbiAqL1xuaW5oZXJpdHMoWFVuaXQsIEJhc2UpO1xuXG4vKipcbiAqIE92ZXJyaWRlIGRvbmUgdG8gY2xvc2UgdGhlIHN0cmVhbSAoaWYgaXQncyBhIGZpbGUpLlxuICpcbiAqIEBwYXJhbSBmYWlsdXJlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuWFVuaXQucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoZmFpbHVyZXMsIGZuKSB7XG4gIGlmICh0aGlzLmZpbGVTdHJlYW0pIHtcbiAgICB0aGlzLmZpbGVTdHJlYW0uZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZuKGZhaWx1cmVzKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBmbihmYWlsdXJlcyk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGUgb3V0IHRoZSBnaXZlbiBsaW5lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lXG4gKi9cblhVbml0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gIGlmICh0aGlzLmZpbGVTdHJlYW0pIHtcbiAgICB0aGlzLmZpbGVTdHJlYW0ud3JpdGUobGluZSArICdcXG4nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy5zdGRvdXQpIHtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShsaW5lICsgJ1xcbicpO1xuICB9IGVsc2Uge1xuICAgIEJhc2UuY29uc29sZUxvZyhsaW5lKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPdXRwdXQgdGFnIGZvciB0aGUgZ2l2ZW4gYHRlc3QuYFxuICpcbiAqIEBwYXJhbSB7VGVzdH0gdGVzdFxuICovXG5YVW5pdC5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uICh0ZXN0KSB7XG4gIEJhc2UudXNlQ29sb3JzID0gZmFsc2U7XG5cbiAgdmFyIGF0dHJzID0ge1xuICAgIGNsYXNzbmFtZTogdGVzdC5wYXJlbnQuZnVsbFRpdGxlKCksXG4gICAgbmFtZTogdGVzdC50aXRsZSxcbiAgICB0aW1lOiB0ZXN0LmR1cmF0aW9uIC8gMTAwMCB8fCAwXG4gIH07XG5cbiAgaWYgKHRlc3Quc3RhdGUgPT09IFNUQVRFX0ZBSUxFRCkge1xuICAgIHZhciBlcnIgPSB0ZXN0LmVycjtcbiAgICB2YXIgZGlmZiA9XG4gICAgICAhQmFzZS5oaWRlRGlmZiAmJiBCYXNlLnNob3dEaWZmKGVycilcbiAgICAgICAgPyAnXFxuJyArIEJhc2UuZ2VuZXJhdGVEaWZmKGVyci5hY3R1YWwsIGVyci5leHBlY3RlZClcbiAgICAgICAgOiAnJztcbiAgICB0aGlzLndyaXRlKFxuICAgICAgdGFnKFxuICAgICAgICAndGVzdGNhc2UnLFxuICAgICAgICBhdHRycyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRhZyhcbiAgICAgICAgICAnZmFpbHVyZScsXG4gICAgICAgICAge30sXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgZXNjYXBlKGVyci5tZXNzYWdlKSArIGVzY2FwZShkaWZmKSArICdcXG4nICsgZXNjYXBlKGVyci5zdGFjaylcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH0gZWxzZSBpZiAodGVzdC5pc1BlbmRpbmcoKSkge1xuICAgIHRoaXMud3JpdGUodGFnKCd0ZXN0Y2FzZScsIGF0dHJzLCBmYWxzZSwgdGFnKCdza2lwcGVkJywge30sIHRydWUpKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53cml0ZSh0YWcoJ3Rlc3RjYXNlJywgYXR0cnMsIHRydWUpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBIVE1MIHRhZyBoZWxwZXIuXG4gKlxuICogQHBhcmFtIG5hbWVcbiAqIEBwYXJhbSBhdHRyc1xuICogQHBhcmFtIGNsb3NlXG4gKiBAcGFyYW0gY29udGVudFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0YWcobmFtZSwgYXR0cnMsIGNsb3NlLCBjb250ZW50KSB7XG4gIHZhciBlbmQgPSBjbG9zZSA/ICcvPicgOiAnPic7XG4gIHZhciBwYWlycyA9IFtdO1xuICB2YXIgdGFnO1xuXG4gIGZvciAodmFyIGtleSBpbiBhdHRycykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cnMsIGtleSkpIHtcbiAgICAgIHBhaXJzLnB1c2goa2V5ICsgJz1cIicgKyBlc2NhcGUoYXR0cnNba2V5XSkgKyAnXCInKTtcbiAgICB9XG4gIH1cblxuICB0YWcgPSAnPCcgKyBuYW1lICsgKHBhaXJzLmxlbmd0aCA/ICcgJyArIHBhaXJzLmpvaW4oJyAnKSA6ICcnKSArIGVuZDtcbiAgaWYgKGNvbnRlbnQpIHtcbiAgICB0YWcgKz0gY29udGVudCArICc8LycgKyBuYW1lICsgZW5kO1xuICB9XG4gIHJldHVybiB0YWc7XG59XG5cblhVbml0LmRlc2NyaXB0aW9uID0gJ1hVbml0LWNvbXBhdGlibGUgWE1MIG91dHB1dCc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgUGVuZGluZyA9IHJlcXVpcmUoJy4vcGVuZGluZycpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6cnVubmFibGUnKTtcbnZhciBtaWxsaXNlY29uZHMgPSByZXF1aXJlKCdtcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3Qge1xuICBjcmVhdGVJbnZhbGlkRXhjZXB0aW9uRXJyb3IsXG4gIGNyZWF0ZU11bHRpcGxlRG9uZUVycm9yLFxuICBjcmVhdGVUaW1lb3V0RXJyb3Jcbn0gPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG4vKipcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xudmFyIHNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcbnZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBSdW5uYWJsZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSdW5uYWJsZWAgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgY2FsbGJhY2sgYGZuYC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIGV4dGVybmFsOkV2ZW50RW1pdHRlclxuICogQHB1YmxpY1xuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBSdW5uYWJsZSh0aXRsZSwgZm4pIHtcbiAgdGhpcy50aXRsZSA9IHRpdGxlO1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuYm9keSA9IChmbiB8fCAnJykudG9TdHJpbmcoKTtcbiAgdGhpcy5hc3luYyA9IGZuICYmIGZuLmxlbmd0aDtcbiAgdGhpcy5zeW5jID0gIXRoaXMuYXN5bmM7XG4gIHRoaXMuX3RpbWVvdXQgPSAyMDAwO1xuICB0aGlzLl9zbG93ID0gNzU7XG4gIHRoaXMuX3JldHJpZXMgPSAtMTtcbiAgdXRpbHMuYXNzaWduTmV3TW9jaGFJRCh0aGlzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZCcsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdXRpbHMuZ2V0TW9jaGFJRCh0aGlzKTtcbiAgICB9XG4gIH0pO1xuICB0aGlzLnJlc2V0KCk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBFdmVudEVtaXR0ZXIucHJvdG90eXBlYC5cbiAqL1xudXRpbHMuaW5oZXJpdHMoUnVubmFibGUsIEV2ZW50RW1pdHRlcik7XG5cbi8qKlxuICogUmVzZXRzIHRoZSBzdGF0ZSBpbml0aWFsbHkgb3IgZm9yIGEgbmV4dCBydW4uXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy50aW1lZE91dCA9IGZhbHNlO1xuICB0aGlzLl9jdXJyZW50UmV0cnkgPSAwO1xuICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgZGVsZXRlIHRoaXMuc3RhdGU7XG4gIGRlbGV0ZSB0aGlzLmVycjtcbn07XG5cbi8qKlxuICogR2V0IGN1cnJlbnQgdGltZW91dCB2YWx1ZSBpbiBtc2Vjcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge251bWJlcn0gY3VycmVudCB0aW1lb3V0IHRocmVzaG9sZCB2YWx1ZVxuICovXG4vKipcbiAqIEBzdW1tYXJ5XG4gKiBTZXQgdGltZW91dCB0aHJlc2hvbGQgdmFsdWUgKG1zZWNzKS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgc3RyaW5nIGFyZ3VtZW50IGNhbiB1c2Ugc2hvcnRoYW5kIChlLmcuLCBcIjJzXCIpIGFuZCB3aWxsIGJlIGNvbnZlcnRlZC5cbiAqIFRoZSB2YWx1ZSB3aWxsIGJlIGNsYW1wZWQgdG8gcmFuZ2UgWzxjb2RlPjA8L2NvZGU+LCA8Y29kZT4yXjxzdXA+MzE8L3N1cD4tMTwvY29kZT5dLlxuICogSWYgY2xhbXBlZCB2YWx1ZSBtYXRjaGVzIGVpdGhlciByYW5nZSBlbmRwb2ludCwgdGltZW91dHMgd2lsbCBiZSBkaXNhYmxlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd09yV29ya2VyR2xvYmFsU2NvcGUvc2V0VGltZW91dCNNYXhpbXVtX2RlbGF5X3ZhbHVlfVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtcyAtIFRpbWVvdXQgdGhyZXNob2xkIHZhbHVlLlxuICogQHJldHVybnMge1J1bm5hYmxlfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lb3V0O1xuICB9XG4gIGlmICh0eXBlb2YgbXMgPT09ICdzdHJpbmcnKSB7XG4gICAgbXMgPSBtaWxsaXNlY29uZHMobXMpO1xuICB9XG5cbiAgLy8gQ2xhbXAgdG8gcmFuZ2VcbiAgdmFyIElOVF9NQVggPSBNYXRoLnBvdygyLCAzMSkgLSAxO1xuICB2YXIgcmFuZ2UgPSBbMCwgSU5UX01BWF07XG4gIG1zID0gdXRpbHMuY2xhbXAobXMsIHJhbmdlKTtcblxuICAvLyBzZWUgIzE2NTIgZm9yIHJlYXNvbmluZ1xuICBpZiAobXMgPT09IHJhbmdlWzBdIHx8IG1zID09PSByYW5nZVsxXSkge1xuICAgIHRoaXMuX3RpbWVvdXQgPSAwO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBtcztcbiAgfVxuICBkZWJ1ZygndGltZW91dCAlZCcsIHRoaXMuX3RpbWVvdXQpO1xuXG4gIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgdGhpcy5yZXNldFRpbWVvdXQoKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IG9yIGdldCBzbG93IGBtc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbXNcbiAqIEByZXR1cm4ge1J1bm5hYmxlfG51bWJlcn0gbXMgb3IgUnVubmFibGUgaW5zdGFuY2UuXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5zbG93ID0gZnVuY3Rpb24gKG1zKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCB8fCB0eXBlb2YgbXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nsb3c7XG4gIH1cbiAgaWYgKHR5cGVvZiBtcyA9PT0gJ3N0cmluZycpIHtcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XG4gIH1cbiAgZGVidWcoJ3Nsb3cgJWQnLCBtcyk7XG4gIHRoaXMuX3Nsb3cgPSBtcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEhhbHQgYW5kIG1hcmsgYXMgcGVuZGluZy5cbiAqXG4gKiBAbWVtYmVyb2YgTW9jaGEuUnVubmFibGVcbiAqIEBwdWJsaWNcbiAqL1xuUnVubmFibGUucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucGVuZGluZyA9IHRydWU7XG4gIHRocm93IG5ldyBQZW5kaW5nKCdzeW5jIHNraXA7IGFib3J0aW5nIGV4ZWN1dGlvbicpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIHJ1bm5hYmxlIG9yIGl0cyBwYXJlbnQgc3VpdGUgaXMgbWFya2VkIGFzIHBlbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuUnVubmFibGUucHJvdG90eXBlLmlzUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGVuZGluZyB8fCAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaXNQZW5kaW5nKCkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoaXMgUnVubmFibGUgaGFzIGZhaWxlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5SdW5uYWJsZS5wcm90b3R5cGUuaXNGYWlsZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5pc1BlbmRpbmcoKSAmJiB0aGlzLnN0YXRlID09PSBjb25zdGFudHMuU1RBVEVfRkFJTEVEO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoaXMgUnVubmFibGUgaGFzIHBhc3NlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5SdW5uYWJsZS5wcm90b3R5cGUuaXNQYXNzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5pc1BlbmRpbmcoKSAmJiB0aGlzLnN0YXRlID09PSBjb25zdGFudHMuU1RBVEVfUEFTU0VEO1xufTtcblxuLyoqXG4gKiBTZXQgb3IgZ2V0IG51bWJlciBvZiByZXRyaWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5yZXRyaWVzID0gZnVuY3Rpb24gKG4pIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JldHJpZXM7XG4gIH1cbiAgdGhpcy5fcmV0cmllcyA9IG47XG59O1xuXG4vKipcbiAqIFNldCBvciBnZXQgY3VycmVudCByZXRyeVxuICpcbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5jdXJyZW50UmV0cnkgPSBmdW5jdGlvbiAobikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFJldHJ5O1xuICB9XG4gIHRoaXMuX2N1cnJlbnRSZXRyeSA9IG47XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgZnVsbCB0aXRsZSBnZW5lcmF0ZWQgYnkgcmVjdXJzaXZlbHkgY29uY2F0ZW5hdGluZyB0aGUgcGFyZW50J3NcbiAqIGZ1bGwgdGl0bGUuXG4gKlxuICogQG1lbWJlcm9mIE1vY2hhLlJ1bm5hYmxlXG4gKiBAcHVibGljXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5mdWxsVGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnRpdGxlUGF0aCgpLmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSB0aXRsZSBwYXRoIGdlbmVyYXRlZCBieSBjb25jYXRlbmF0aW5nIHRoZSBwYXJlbnQncyB0aXRsZSBwYXRoIHdpdGggdGhlIHRpdGxlLlxuICpcbiAqIEBtZW1iZXJvZiBNb2NoYS5SdW5uYWJsZVxuICogQHB1YmxpY1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5SdW5uYWJsZS5wcm90b3R5cGUudGl0bGVQYXRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnQudGl0bGVQYXRoKCkuY29uY2F0KFt0aGlzLnRpdGxlXSk7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSB0aW1lb3V0LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIHRpbWVvdXQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuUnVubmFibGUucHJvdG90eXBlLnJlc2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbXMgPSB0aGlzLnRpbWVvdXQoKTtcblxuICBpZiAobXMgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLnRpbWVvdXQoKSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLmNhbGxiYWNrKHNlbGYuX3RpbWVvdXRFcnJvcihtcykpO1xuICAgIHNlbGYudGltZWRPdXQgPSB0cnVlO1xuICB9LCBtcyk7XG59O1xuXG4vKipcbiAqIFNldCBvciBnZXQgYSBsaXN0IG9mIHdoaXRlbGlzdGVkIGdsb2JhbHMgZm9yIHRoaXMgdGVzdCBydW4uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nW119IGdsb2JhbHNcbiAqL1xuUnVubmFibGUucHJvdG90eXBlLmdsb2JhbHMgPSBmdW5jdGlvbiAoZ2xvYmFscykge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWxsb3dlZEdsb2JhbHM7XG4gIH1cbiAgdGhpcy5fYWxsb3dlZEdsb2JhbHMgPSBnbG9iYWxzO1xufTtcblxuLyoqXG4gKiBSdW4gdGhlIHRlc3QgYW5kIGludm9rZSBgZm4oZXJyKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gIHZhciBmaW5pc2hlZDtcbiAgdmFyIGVycm9yV2FzSGFuZGxlZCA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLmlzUGVuZGluZygpKSByZXR1cm4gZm4oKTtcblxuICAvLyBTb21ldGltZXMgdGhlIGN0eCBleGlzdHMsIGJ1dCBpdCBpcyBub3QgcnVubmFibGVcbiAgaWYgKGN0eCAmJiBjdHgucnVubmFibGUpIHtcbiAgICBjdHgucnVubmFibGUodGhpcyk7XG4gIH1cblxuICAvLyBjYWxsZWQgbXVsdGlwbGUgdGltZXNcbiAgZnVuY3Rpb24gbXVsdGlwbGUoZXJyKSB7XG4gICAgaWYgKGVycm9yV2FzSGFuZGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlcnJvcldhc0hhbmRsZWQgPSB0cnVlO1xuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBjcmVhdGVNdWx0aXBsZURvbmVFcnJvcihzZWxmLCBlcnIpKTtcbiAgfVxuXG4gIC8vIGZpbmlzaGVkXG4gIGZ1bmN0aW9uIGRvbmUoZXJyKSB7XG4gICAgdmFyIG1zID0gc2VsZi50aW1lb3V0KCk7XG4gICAgaWYgKHNlbGYudGltZWRPdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIHJldHVybiBtdWx0aXBsZShlcnIpO1xuICAgIH1cblxuICAgIHNlbGYuY2xlYXJUaW1lb3V0KCk7XG4gICAgc2VsZi5kdXJhdGlvbiA9IG5ldyBEYXRlKCkgLSBzdGFydDtcbiAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgaWYgKCFlcnIgJiYgc2VsZi5kdXJhdGlvbiA+IG1zICYmIG1zID4gMCkge1xuICAgICAgZXJyID0gc2VsZi5fdGltZW91dEVycm9yKG1zKTtcbiAgICB9XG4gICAgZm4oZXJyKTtcbiAgfVxuXG4gIC8vIGZvciAucmVzZXRUaW1lb3V0KCkgYW5kIFJ1bm5lciN1bmNhdWdodCgpXG4gIHRoaXMuY2FsbGJhY2sgPSBkb25lO1xuXG4gIGlmICh0aGlzLmZuICYmIHR5cGVvZiB0aGlzLmZuLmNhbGwgIT09ICdmdW5jdGlvbicpIHtcbiAgICBkb25lKFxuICAgICAgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0EgcnVubmFibGUgbXVzdCBiZSBwYXNzZWQgYSBmdW5jdGlvbiBhcyBpdHMgc2Vjb25kIGFyZ3VtZW50LidcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGV4cGxpY2l0IGFzeW5jIHdpdGggYGRvbmVgIGFyZ3VtZW50XG4gIGlmICh0aGlzLmFzeW5jKSB7XG4gICAgdGhpcy5yZXNldFRpbWVvdXQoKTtcblxuICAgIC8vIGFsbG93cyBza2lwKCkgdG8gYmUgdXNlZCBpbiBhbiBleHBsaWNpdCBhc3luYyBjb250ZXh0XG4gICAgdGhpcy5za2lwID0gZnVuY3Rpb24gYXN5bmNTa2lwKCkge1xuICAgICAgdGhpcy5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgIGRvbmUoKTtcbiAgICAgIC8vIGhhbHQgZXhlY3V0aW9uLCB0aGUgdW5jYXVnaHQgaGFuZGxlciB3aWxsIGlnbm9yZSB0aGUgZmFpbHVyZS5cbiAgICAgIHRocm93IG5ldyBQZW5kaW5nKCdhc3luYyBza2lwOyBhYm9ydGluZyBleGVjdXRpb24nKTtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGNhbGxGbkFzeW5jKHRoaXMuZm4pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gaGFuZGxlcyBhc3luYyBydW5uYWJsZXMgd2hpY2ggYWN0dWFsbHkgcnVuIHN5bmNocm9ub3VzbHlcbiAgICAgIGVycm9yV2FzSGFuZGxlZCA9IHRydWU7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgUGVuZGluZykge1xuICAgICAgICByZXR1cm47IC8vIGRvbmUoKSBpcyBhbHJlYWR5IGNhbGxlZCBpbiB0aGlzLnNraXAoKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmFsbG93VW5jYXVnaHQpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgZG9uZShSdW5uYWJsZS50b1ZhbHVlT3JFcnJvcihlcnIpKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc3luYyBvciBwcm9taXNlLXJldHVybmluZ1xuICB0cnkge1xuICAgIGNhbGxGbih0aGlzLmZuKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JXYXNIYW5kbGVkID0gdHJ1ZTtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgUGVuZGluZykge1xuICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWxsb3dVbmNhdWdodCkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICBkb25lKFJ1bm5hYmxlLnRvVmFsdWVPckVycm9yKGVycikpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEZuKGZuKSB7XG4gICAgdmFyIHJlc3VsdCA9IGZuLmNhbGwoY3R4KTtcbiAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2VsZi5yZXNldFRpbWVvdXQoKTtcbiAgICAgIHJlc3VsdC50aGVuKFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIC8vIFJldHVybiBudWxsIHNvIGxpYnJhcmllcyBsaWtlIGJsdWViaXJkIGRvIG5vdCB3YXJuIGFib3V0XG4gICAgICAgICAgLy8gc3Vic2VxdWVudGx5IGNvbnN0cnVjdGVkIFByb21pc2VzLlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgZG9uZShyZWFzb24gfHwgbmV3IEVycm9yKCdQcm9taXNlIHJlamVjdGVkIHdpdGggbm8gb3IgZmFsc3kgcmVhc29uJykpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2VsZi5hc3luY09ubHkpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgJy0tYXN5bmMtb25seSBvcHRpb24gaW4gdXNlIHdpdGhvdXQgZGVjbGFyaW5nIGBkb25lKClgIG9yIHJldHVybmluZyBhIHByb21pc2UnXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEZuQXN5bmMoZm4pIHtcbiAgICB2YXIgcmVzdWx0ID0gZm4uY2FsbChjdHgsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciB8fCB0b1N0cmluZy5jYWxsKGVycikgPT09ICdbb2JqZWN0IEVycm9yXScpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgIHJldHVybiBkb25lKFxuICAgICAgICAgICAgbmV3IEVycm9yKCdkb25lKCkgaW52b2tlZCB3aXRoIG5vbi1FcnJvcjogJyArIEpTT04uc3RyaW5naWZ5KGVycikpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ2RvbmUoKSBpbnZva2VkIHdpdGggbm9uLUVycm9yOiAnICsgZXJyKSk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICYmIHV0aWxzLmlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiBkb25lKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdSZXNvbHV0aW9uIG1ldGhvZCBpcyBvdmVyc3BlY2lmaWVkLiBTcGVjaWZ5IGEgY2FsbGJhY2sgKm9yKiByZXR1cm4gYSBQcm9taXNlOyBub3QgYm90aC4nXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBkb25lKCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogSW5zdGFudGlhdGVzIGEgXCJ0aW1lb3V0XCIgZXJyb3JcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbXMgLSBUaW1lb3V0IChpbiBtaWxsaXNlY29uZHMpXG4gKiBAcmV0dXJucyB7RXJyb3J9IGEgXCJ0aW1lb3V0XCIgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5fdGltZW91dEVycm9yID0gZnVuY3Rpb24gKG1zKSB7XG4gIGxldCBtc2cgPSBgVGltZW91dCBvZiAke21zfW1zIGV4Y2VlZGVkLiBGb3IgYXN5bmMgdGVzdHMgYW5kIGhvb2tzLCBlbnN1cmUgXCJkb25lKClcIiBpcyBjYWxsZWQ7IGlmIHJldHVybmluZyBhIFByb21pc2UsIGVuc3VyZSBpdCByZXNvbHZlcy5gO1xuICBpZiAodGhpcy5maWxlKSB7XG4gICAgbXNnICs9ICcgKCcgKyB0aGlzLmZpbGUgKyAnKSc7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVRpbWVvdXRFcnJvcihtc2csIG1zLCB0aGlzLmZpbGUpO1xufTtcblxudmFyIGNvbnN0YW50cyA9IHV0aWxzLmRlZmluZUNvbnN0YW50cyhcbiAgLyoqXG4gICAqIHtAbGluayBSdW5uYWJsZX0tcmVsYXRlZCBjb25zdGFudHMuXG4gICAqIEBwdWJsaWNcbiAgICogQG1lbWJlcm9mIFJ1bm5hYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAc3RhdGljXG4gICAqIEBhbGlhcyBjb25zdGFudHNcbiAgICogQGVudW0ge3N0cmluZ31cbiAgICovXG4gIHtcbiAgICAvKipcbiAgICAgKiBWYWx1ZSBvZiBgc3RhdGVgIHByb3Agd2hlbiBhIGBSdW5uYWJsZWAgaGFzIGZhaWxlZFxuICAgICAqL1xuICAgIFNUQVRFX0ZBSUxFRDogJ2ZhaWxlZCcsXG4gICAgLyoqXG4gICAgICogVmFsdWUgb2YgYHN0YXRlYCBwcm9wIHdoZW4gYSBgUnVubmFibGVgIGhhcyBwYXNzZWRcbiAgICAgKi9cbiAgICBTVEFURV9QQVNTRUQ6ICdwYXNzZWQnLFxuICAgIC8qKlxuICAgICAqIFZhbHVlIG9mIGBzdGF0ZWAgcHJvcCB3aGVuIGEgYFJ1bm5hYmxlYCBoYXMgYmVlbiBza2lwcGVkIGJ5IHVzZXJcbiAgICAgKi9cbiAgICBTVEFURV9QRU5ESU5HOiAncGVuZGluZydcbiAgfVxuKTtcblxuLyoqXG4gKiBHaXZlbiBgdmFsdWVgLCByZXR1cm4gaWRlbnRpdHkgaWYgdHJ1dGh5LCBvdGhlcndpc2UgY3JlYXRlIGFuIFwiaW52YWxpZCBleGNlcHRpb25cIiBlcnJvciBhbmQgcmV0dXJuIHRoYXQuXG4gKiBAcGFyYW0geyp9IFt2YWx1ZV0gLSBWYWx1ZSB0byByZXR1cm4sIGlmIHByZXNlbnRcbiAqIEByZXR1cm5zIHsqfEVycm9yfSBgdmFsdWVgLCBvdGhlcndpc2UgYW4gYEVycm9yYFxuICogQHByaXZhdGVcbiAqL1xuUnVubmFibGUudG9WYWx1ZU9yRXJyb3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSB8fFxuICAgIGNyZWF0ZUludmFsaWRFeGNlcHRpb25FcnJvcihcbiAgICAgICdSdW5uYWJsZSBmYWlsZWQgd2l0aCBmYWxzeSBvciB1bmRlZmluZWQgZXhjZXB0aW9uLiBQbGVhc2UgdGhyb3cgYW4gRXJyb3IgaW5zdGVhZC4nLFxuICAgICAgdmFsdWVcbiAgICApXG4gICk7XG59O1xuXG5SdW5uYWJsZS5jb25zdGFudHMgPSBjb25zdGFudHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgUGVuZGluZyA9IHJlcXVpcmUoJy4vcGVuZGluZycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6cnVubmVyJyk7XG52YXIgUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XG52YXIgU3VpdGUgPSByZXF1aXJlKCcuL3N1aXRlJyk7XG52YXIgSE9PS19UWVBFX0JFRk9SRV9FQUNIID0gU3VpdGUuY29uc3RhbnRzLkhPT0tfVFlQRV9CRUZPUkVfRUFDSDtcbnZhciBIT09LX1RZUEVfQUZURVJfRUFDSCA9IFN1aXRlLmNvbnN0YW50cy5IT09LX1RZUEVfQUZURVJfRUFDSDtcbnZhciBIT09LX1RZUEVfQUZURVJfQUxMID0gU3VpdGUuY29uc3RhbnRzLkhPT0tfVFlQRV9BRlRFUl9BTEw7XG52YXIgSE9PS19UWVBFX0JFRk9SRV9BTEwgPSBTdWl0ZS5jb25zdGFudHMuSE9PS19UWVBFX0JFRk9SRV9BTEw7XG52YXIgRVZFTlRfUk9PVF9TVUlURV9SVU4gPSBTdWl0ZS5jb25zdGFudHMuRVZFTlRfUk9PVF9TVUlURV9SVU47XG52YXIgU1RBVEVfRkFJTEVEID0gUnVubmFibGUuY29uc3RhbnRzLlNUQVRFX0ZBSUxFRDtcbnZhciBTVEFURV9QQVNTRUQgPSBSdW5uYWJsZS5jb25zdGFudHMuU1RBVEVfUEFTU0VEO1xudmFyIFNUQVRFX1BFTkRJTkcgPSBSdW5uYWJsZS5jb25zdGFudHMuU1RBVEVfUEVORElORztcbnZhciBzdGFja0ZpbHRlciA9IHV0aWxzLnN0YWNrVHJhY2VGaWx0ZXIoKTtcbnZhciBzdHJpbmdpZnkgPSB1dGlscy5zdHJpbmdpZnk7XG5cbmNvbnN0IHtcbiAgY3JlYXRlSW52YWxpZEV4Y2VwdGlvbkVycm9yLFxuICBjcmVhdGVVbnN1cHBvcnRlZEVycm9yLFxuICBjcmVhdGVGYXRhbEVycm9yLFxuICBpc01vY2hhRXJyb3IsXG4gIGNvbnN0YW50czogZXJyb3JDb25zdGFudHNcbn0gPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG4vKipcbiAqIE5vbi1lbnVtZXJhYmxlIGdsb2JhbHMuXG4gKiBAcHJpdmF0ZVxuICogQHJlYWRvbmx5XG4gKi9cbnZhciBnbG9iYWxzID0gW1xuICAnc2V0VGltZW91dCcsXG4gICdjbGVhclRpbWVvdXQnLFxuICAnc2V0SW50ZXJ2YWwnLFxuICAnY2xlYXJJbnRlcnZhbCcsXG4gICdYTUxIdHRwUmVxdWVzdCcsXG4gICdEYXRlJyxcbiAgJ3NldEltbWVkaWF0ZScsXG4gICdjbGVhckltbWVkaWF0ZSdcbl07XG5cbnZhciBjb25zdGFudHMgPSB1dGlscy5kZWZpbmVDb25zdGFudHMoXG4gIC8qKlxuICAgKiB7QGxpbmsgUnVubmVyfS1yZWxhdGVkIGNvbnN0YW50cy5cbiAgICogQHB1YmxpY1xuICAgKiBAbWVtYmVyb2YgUnVubmVyXG4gICAqIEByZWFkb25seVxuICAgKiBAYWxpYXMgY29uc3RhbnRzXG4gICAqIEBzdGF0aWNcbiAgICogQGVudW0ge3N0cmluZ31cbiAgICovXG4gIHtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4ge0BsaW5rIEhvb2t9IGV4ZWN1dGlvbiBiZWdpbnNcbiAgICAgKi9cbiAgICBFVkVOVF9IT09LX0JFR0lOOiAnaG9vaycsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHtAbGluayBIb29rfSBleGVjdXRpb24gZW5kc1xuICAgICAqL1xuICAgIEVWRU5UX0hPT0tfRU5EOiAnaG9vayBlbmQnLFxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBSb290IHtAbGluayBTdWl0ZX0gZXhlY3V0aW9uIGJlZ2lucyAoYWxsIGZpbGVzIGhhdmUgYmVlbiBwYXJzZWQgYW5kIGhvb2tzL3Rlc3RzIGFyZSByZWFkeSBmb3IgZXhlY3V0aW9uKVxuICAgICAqL1xuICAgIEVWRU5UX1JVTl9CRUdJTjogJ3N0YXJ0JyxcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gUm9vdCB7QGxpbmsgU3VpdGV9IGV4ZWN1dGlvbiBoYXMgYmVlbiBkZWxheWVkIHZpYSBgZGVsYXlgIG9wdGlvblxuICAgICAqL1xuICAgIEVWRU5UX0RFTEFZX0JFR0lOOiAnd2FpdGluZycsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIGRlbGF5ZWQgUm9vdCB7QGxpbmsgU3VpdGV9IGV4ZWN1dGlvbiBpcyB0cmlnZ2VyZWQgYnkgdXNlciB2aWEgYGdsb2JhbC5ydW4oKWBcbiAgICAgKi9cbiAgICBFVkVOVF9ERUxBWV9FTkQ6ICdyZWFkeScsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIFJvb3Qge0BsaW5rIFN1aXRlfSBleGVjdXRpb24gZW5kc1xuICAgICAqL1xuICAgIEVWRU5UX1JVTl9FTkQ6ICdlbmQnLFxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB7QGxpbmsgU3VpdGV9IGV4ZWN1dGlvbiBiZWdpbnNcbiAgICAgKi9cbiAgICBFVkVOVF9TVUlURV9CRUdJTjogJ3N1aXRlJyxcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4ge0BsaW5rIFN1aXRlfSBleGVjdXRpb24gZW5kc1xuICAgICAqL1xuICAgIEVWRU5UX1NVSVRFX0VORDogJ3N1aXRlIGVuZCcsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHtAbGluayBUZXN0fSBleGVjdXRpb24gYmVnaW5zXG4gICAgICovXG4gICAgRVZFTlRfVEVTVF9CRUdJTjogJ3Rlc3QnLFxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB7QGxpbmsgVGVzdH0gZXhlY3V0aW9uIGVuZHNcbiAgICAgKi9cbiAgICBFVkVOVF9URVNUX0VORDogJ3Rlc3QgZW5kJyxcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4ge0BsaW5rIFRlc3R9IGV4ZWN1dGlvbiBmYWlsc1xuICAgICAqL1xuICAgIEVWRU5UX1RFU1RfRkFJTDogJ2ZhaWwnLFxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB7QGxpbmsgVGVzdH0gZXhlY3V0aW9uIHN1Y2NlZWRzXG4gICAgICovXG4gICAgRVZFTlRfVEVTVF9QQVNTOiAncGFzcycsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHtAbGluayBUZXN0fSBiZWNvbWVzIHBlbmRpbmdcbiAgICAgKi9cbiAgICBFVkVOVF9URVNUX1BFTkRJTkc6ICdwZW5kaW5nJyxcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4ge0BsaW5rIFRlc3R9IGV4ZWN1dGlvbiBoYXMgZmFpbGVkLCBidXQgd2lsbCByZXRyeVxuICAgICAqL1xuICAgIEVWRU5UX1RFU1RfUkVUUlk6ICdyZXRyeScsXG4gICAgLyoqXG4gICAgICogSW5pdGlhbCBzdGF0ZSBvZiBSdW5uZXJcbiAgICAgKi9cbiAgICBTVEFURV9JRExFOiAnaWRsZScsXG4gICAgLyoqXG4gICAgICogU3RhdGUgc2V0IHRvIHRoaXMgdmFsdWUgd2hlbiB0aGUgUnVubmVyIGhhcyBzdGFydGVkIHJ1bm5pbmdcbiAgICAgKi9cbiAgICBTVEFURV9SVU5OSU5HOiAncnVubmluZycsXG4gICAgLyoqXG4gICAgICogU3RhdGUgc2V0IHRvIHRoaXMgdmFsdWUgd2hlbiB0aGUgUnVubmVyIGhhcyBzdG9wcGVkXG4gICAgICovXG4gICAgU1RBVEVfU1RPUFBFRDogJ3N0b3BwZWQnXG4gIH1cbik7XG5cbmNsYXNzIFJ1bm5lciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGEgYFJ1bm5lcmAgYXQgdGhlIFJvb3Qge0BsaW5rIFN1aXRlfSwgd2hpY2ggcmVwcmVzZW50cyBhIGhpZXJhcmNoeSBvZiB7QGxpbmsgU3VpdGV8U3VpdGVzfSBhbmQge0BsaW5rIFRlc3R8VGVzdHN9LlxuICAgKlxuICAgKiBAZXh0ZW5kcyBleHRlcm5hbDpFdmVudEVtaXR0ZXJcbiAgICogQHB1YmxpY1xuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgLSBSb290IHN1aXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBTZXR0aW5ncyBvYmplY3RcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5jbGVhblJlZmVyZW5jZXNBZnRlclJ1bl0gLSBXaGV0aGVyIHRvIGNsZWFuIHJlZmVyZW5jZXMgdG8gdGVzdCBmbnMgYW5kIGhvb2tzIHdoZW4gYSBzdWl0ZSBpcyBkb25lLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmRlbGF5XSAtIFdoZXRoZXIgdG8gZGVsYXkgZXhlY3V0aW9uIG9mIHJvb3Qgc3VpdGUgdW50aWwgcmVhZHkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZHJ5UnVuXSAtIFdoZXRoZXIgdG8gcmVwb3J0IHRlc3RzIHdpdGhvdXQgcnVubmluZyB0aGVtLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmZhaWxaZXJvXSAtIFdoZXRoZXIgdG8gZmFpbCB0ZXN0IHJ1biBpZiB6ZXJvIHRlc3RzIGVuY291bnRlcmVkLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3VpdGUsIG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fZ2xvYmFscyA9IFtdO1xuICAgIHRoaXMuX2Fib3J0ID0gZmFsc2U7XG4gICAgdGhpcy5zdWl0ZSA9IHN1aXRlO1xuICAgIHRoaXMuX29wdHMgPSBvcHRzO1xuICAgIHRoaXMuc3RhdGUgPSBjb25zdGFudHMuU1RBVEVfSURMRTtcbiAgICB0aGlzLnRvdGFsID0gc3VpdGUudG90YWwoKTtcbiAgICB0aGlzLmZhaWx1cmVzID0gMDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPEV2ZW50RW1pdHRlcixNYXA8c3RyaW5nLFNldDxFdmVudExpc3RlbmVyPj4+fVxuICAgICAqL1xuICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMub24oY29uc3RhbnRzLkVWRU5UX1RFU1RfRU5ELCBmdW5jdGlvbiAodGVzdCkge1xuICAgICAgaWYgKHRlc3QudHlwZSA9PT0gJ3Rlc3QnICYmIHRlc3QucmV0cmllZFRlc3QoKSAmJiB0ZXN0LnBhcmVudCkge1xuICAgICAgICB2YXIgaWR4ID1cbiAgICAgICAgICB0ZXN0LnBhcmVudC50ZXN0cyAmJiB0ZXN0LnBhcmVudC50ZXN0cy5pbmRleE9mKHRlc3QucmV0cmllZFRlc3QoKSk7XG4gICAgICAgIGlmIChpZHggPiAtMSkgdGVzdC5wYXJlbnQudGVzdHNbaWR4XSA9IHRlc3Q7XG4gICAgICB9XG4gICAgICBzZWxmLmNoZWNrR2xvYmFscyh0ZXN0KTtcbiAgICB9KTtcbiAgICB0aGlzLm9uKGNvbnN0YW50cy5FVkVOVF9IT09LX0VORCwgZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgIHNlbGYuY2hlY2tHbG9iYWxzKGhvb2spO1xuICAgIH0pO1xuICAgIHRoaXMuX2RlZmF1bHRHcmVwID0gLy4qLztcbiAgICB0aGlzLmdyZXAodGhpcy5fZGVmYXVsdEdyZXApO1xuICAgIHRoaXMuZ2xvYmFscyh0aGlzLmdsb2JhbFByb3BzKCkpO1xuXG4gICAgdGhpcy51bmNhdWdodCA9IHRoaXMuX3VuY2F1Z2h0LmJpbmQodGhpcyk7XG4gICAgdGhpcy51bmhhbmRsZWQgPSAocmVhc29uLCBwcm9taXNlKSA9PiB7XG4gICAgICBpZiAoaXNNb2NoYUVycm9yKHJlYXNvbikpIHtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgJ3RyYXBwZWQgdW5oYW5kbGVkIHJlamVjdGlvbiBjb21pbmcgb3V0IG9mIE1vY2hhOyBmb3J3YXJkaW5nIHRvIHVuY2F1Z2h0IGhhbmRsZXI6JyxcbiAgICAgICAgICByZWFzb25cbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy51bmNhdWdodChyZWFzb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgJ3RyYXBwZWQgdW5oYW5kbGVkIHJlamVjdGlvbiBmcm9tIChwcm9iYWJseSkgdXNlciBjb2RlOyByZS1lbWl0dGluZyBvbiBwcm9jZXNzJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgIHByb2Nlc3MsXG4gICAgICAgICAgJ3VuaGFuZGxlZFJlamVjdGlvbicsXG4gICAgICAgICAgdGhpcy51bmhhbmRsZWRcbiAgICAgICAgKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHJlYXNvbiwgcHJvbWlzZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcihwcm9jZXNzLCAndW5oYW5kbGVkUmVqZWN0aW9uJywgdGhpcy51bmhhbmRsZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFdyYXBwZXIgZm9yIHNldEltbWVkaWF0ZSwgcHJvY2Vzcy5uZXh0VGljaywgb3IgYnJvd3NlciBwb2x5ZmlsbC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHByaXZhdGVcbiAqL1xuUnVubmVyLmltbWVkaWF0ZWx5ID0gZ2xvYmFsLnNldEltbWVkaWF0ZSB8fCBwcm9jZXNzLm5leHRUaWNrO1xuXG4vKipcbiAqIFJlcGxhY2VtZW50IGZvciBgdGFyZ2V0Lm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpYCB0aGF0IGRvZXMgYm9va2tlZXBpbmcgdG8gcmVtb3ZlIHRoZW0gd2hlbiB0aGlzIHJ1bm5lciBpbnN0YW5jZSBpcyBkaXNwb3NlZC5cbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSB0YXJnZXQgLSBUaGUgYEV2ZW50RW1pdHRlcmBcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBUaGUgZXZlbnQgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGZuIC0gTGlzdGVuZXIgZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5lci5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gIGRlYnVnKFxuICAgICdfYWRkRXZlbnRMaXN0ZW5lcigpOiBhZGRpbmcgZm9yIGV2ZW50ICVzOyAlZCBjdXJyZW50IGxpc3RlbmVycycsXG4gICAgZXZlbnROYW1lLFxuICAgIHRhcmdldC5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSlcbiAgKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKFxuICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzLmhhcyh0YXJnZXQpICYmXG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMuZ2V0KHRhcmdldCkuaGFzKGV2ZW50TmFtZSkgJiZcbiAgICB0aGlzLl9ldmVudExpc3RlbmVycy5nZXQodGFyZ2V0KS5nZXQoZXZlbnROYW1lKS5oYXMobGlzdGVuZXIpXG4gICkge1xuICAgIGRlYnVnKFxuICAgICAgJ3dhcm5pbmc6IHRyaWVkIHRvIGF0dGFjaCBkdXBsaWNhdGUgZXZlbnQgbGlzdGVuZXIgZm9yICVzJyxcbiAgICAgIGV2ZW50TmFtZVxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRhcmdldC5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgY29uc3QgdGFyZ2V0TGlzdGVuZXJzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnMuaGFzKHRhcmdldClcbiAgICA/IHRoaXMuX2V2ZW50TGlzdGVuZXJzLmdldCh0YXJnZXQpXG4gICAgOiBuZXcgTWFwKCk7XG4gIGNvbnN0IHRhcmdldEV2ZW50TGlzdGVuZXJzID0gdGFyZ2V0TGlzdGVuZXJzLmhhcyhldmVudE5hbWUpXG4gICAgPyB0YXJnZXRMaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSlcbiAgICA6IG5ldyBTZXQoKTtcbiAgdGFyZ2V0RXZlbnRMaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgdGFyZ2V0TGlzdGVuZXJzLnNldChldmVudE5hbWUsIHRhcmdldEV2ZW50TGlzdGVuZXJzKTtcbiAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMuc2V0KHRhcmdldCwgdGFyZ2V0TGlzdGVuZXJzKTtcbn07XG5cbi8qKlxuICogUmVwbGFjZW1lbnQgZm9yIGB0YXJnZXQucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcilgIHRoYXQgYWxzbyB1cGRhdGVzIHRoZSBib29ra2VlcGluZy5cbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSB0YXJnZXQgLSBUaGUgYEV2ZW50RW1pdHRlcmBcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBUaGUgZXZlbnQgbmFtZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBMaXN0ZW5lciBmdW5jdGlvblxuICogQHByaXZhdGVcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5fcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgdGFyZ2V0LnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuXG4gIGlmICh0aGlzLl9ldmVudExpc3RlbmVycy5oYXModGFyZ2V0KSkge1xuICAgIGNvbnN0IHRhcmdldExpc3RlbmVycyA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzLmdldCh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXRMaXN0ZW5lcnMuaGFzKGV2ZW50TmFtZSkpIHtcbiAgICAgIGNvbnN0IHRhcmdldEV2ZW50TGlzdGVuZXJzID0gdGFyZ2V0TGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgdGFyZ2V0RXZlbnRMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIGlmICghdGFyZ2V0RXZlbnRMaXN0ZW5lcnMuc2l6ZSkge1xuICAgICAgICB0YXJnZXRMaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGFyZ2V0TGlzdGVuZXJzLnNpemUpIHtcbiAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzLmRlbGV0ZSh0YXJnZXQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygndHJ5aW5nIHRvIHJlbW92ZSBsaXN0ZW5lciBmb3IgdW50cmFja2VkIG9iamVjdCAlcycsIHRhcmdldCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgZXZlbnQgaGFuZGxlcnMgc2V0IGR1cmluZyBhIHJ1biBvbiB0aGlzIGluc3RhbmNlLlxuICogUmVtYXJrOiB0aGlzIGRvZXMgX25vdF8gY2xlYW4vZGlzcG9zZSB0aGUgdGVzdHMgb3Igc3VpdGVzIHRoZW1zZWx2ZXMuXG4gKi9cblJ1bm5lci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaCgodGFyZ2V0TGlzdGVuZXJzLCB0YXJnZXQpID0+IHtcbiAgICB0YXJnZXRMaXN0ZW5lcnMuZm9yRWFjaCgodGFyZ2V0RXZlbnRMaXN0ZW5lcnMsIGV2ZW50TmFtZSkgPT4ge1xuICAgICAgdGFyZ2V0RXZlbnRMaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICAgIHRhcmdldC5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMuY2xlYXIoKTtcbn07XG5cbi8qKlxuICogUnVuIHRlc3RzIHdpdGggZnVsbCB0aXRsZXMgbWF0Y2hpbmcgYHJlYC4gVXBkYXRlcyBydW5uZXIudG90YWxcbiAqIHdpdGggbnVtYmVyIG9mIHRlc3RzIG1hdGNoZWQuXG4gKlxuICogQHB1YmxpY1xuICogQG1lbWJlcm9mIFJ1bm5lclxuICogQHBhcmFtIHtSZWdFeHB9IHJlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGludmVydFxuICogQHJldHVybiB7UnVubmVyfSBSdW5uZXIgaW5zdGFuY2UuXG4gKi9cblJ1bm5lci5wcm90b3R5cGUuZ3JlcCA9IGZ1bmN0aW9uIChyZSwgaW52ZXJ0KSB7XG4gIGRlYnVnKCdncmVwKCk6IHNldHRpbmcgdG8gJXMnLCByZSk7XG4gIHRoaXMuX2dyZXAgPSByZTtcbiAgdGhpcy5faW52ZXJ0ID0gaW52ZXJ0O1xuICB0aGlzLnRvdGFsID0gdGhpcy5ncmVwVG90YWwodGhpcy5zdWl0ZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGVzdHMgbWF0Y2hpbmcgdGhlIGdyZXAgc2VhcmNoIGZvciB0aGVcbiAqIGdpdmVuIHN1aXRlLlxuICpcbiAqIEBtZW1iZXJvZiBSdW5uZXJcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblJ1bm5lci5wcm90b3R5cGUuZ3JlcFRvdGFsID0gZnVuY3Rpb24gKHN1aXRlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRvdGFsID0gMDtcblxuICBzdWl0ZS5lYWNoVGVzdChmdW5jdGlvbiAodGVzdCkge1xuICAgIHZhciBtYXRjaCA9IHNlbGYuX2dyZXAudGVzdCh0ZXN0LmZ1bGxUaXRsZSgpKTtcbiAgICBpZiAoc2VsZi5faW52ZXJ0KSB7XG4gICAgICBtYXRjaCA9ICFtYXRjaDtcbiAgICB9XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB0b3RhbCsrO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRvdGFsO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBsaXN0IG9mIGdsb2JhbCBwcm9wZXJ0aWVzLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5nbG9iYWxQcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByb3BzID0gT2JqZWN0LmtleXMoZ2xvYmFsKTtcblxuICAvLyBub24tZW51bWVyYWJsZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbG9iYWxzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKH5wcm9wcy5pbmRleE9mKGdsb2JhbHNbaV0pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcHJvcHMucHVzaChnbG9iYWxzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBwcm9wcztcbn07XG5cbi8qKlxuICogQWxsb3cgdGhlIGdpdmVuIGBhcnJgIG9mIGdsb2JhbHMuXG4gKlxuICogQHB1YmxpY1xuICogQG1lbWJlcm9mIFJ1bm5lclxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcmV0dXJuIHtSdW5uZXJ9IFJ1bm5lciBpbnN0YW5jZS5cbiAqL1xuUnVubmVyLnByb3RvdHlwZS5nbG9iYWxzID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2xvYmFscztcbiAgfVxuICBkZWJ1ZygnZ2xvYmFscygpOiBzZXR0aW5nIHRvICVPJywgYXJyKTtcbiAgdGhpcy5fZ2xvYmFscyA9IHRoaXMuX2dsb2JhbHMuY29uY2F0KGFycik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGVjayBmb3IgZ2xvYmFsIHZhcmlhYmxlIGxlYWtzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5lci5wcm90b3R5cGUuY2hlY2tHbG9iYWxzID0gZnVuY3Rpb24gKHRlc3QpIHtcbiAgaWYgKCF0aGlzLmNoZWNrTGVha3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9rID0gdGhpcy5fZ2xvYmFscztcblxuICB2YXIgZ2xvYmFscyA9IHRoaXMuZ2xvYmFsUHJvcHMoKTtcbiAgdmFyIGxlYWtzO1xuXG4gIGlmICh0ZXN0KSB7XG4gICAgb2sgPSBvay5jb25jYXQodGVzdC5fYWxsb3dlZEdsb2JhbHMgfHwgW10pO1xuICB9XG5cbiAgaWYgKHRoaXMucHJldkdsb2JhbHNMZW5ndGggPT09IGdsb2JhbHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucHJldkdsb2JhbHNMZW5ndGggPSBnbG9iYWxzLmxlbmd0aDtcblxuICBsZWFrcyA9IGZpbHRlckxlYWtzKG9rLCBnbG9iYWxzKTtcbiAgdGhpcy5fZ2xvYmFscyA9IHRoaXMuX2dsb2JhbHMuY29uY2F0KGxlYWtzKTtcblxuICBpZiAobGVha3MubGVuZ3RoKSB7XG4gICAgdmFyIG1zZyA9IGBnbG9iYWwgbGVhayhzKSBkZXRlY3RlZDogJHtsZWFrcy5tYXAoZSA9PiBgJyR7ZX0nYCkuam9pbignLCAnKX1gO1xuICAgIHRoaXMuZmFpbCh0ZXN0LCBuZXcgRXJyb3IobXNnKSk7XG4gIH1cbn07XG5cbi8qKlxuICogRmFpbCB0aGUgZ2l2ZW4gYHRlc3RgLlxuICpcbiAqIElmIGB0ZXN0YCBpcyBhIGhvb2ssIGZhaWx1cmVzIHdvcmsgaW4gdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxuICogLSBJZiBiYWlsLCBydW4gY29ycmVzcG9uZGluZyBgYWZ0ZXIgZWFjaGAgYW5kIGBhZnRlcmAgaG9va3MsXG4gKiAgIHRoZW4gZXhpdFxuICogLSBGYWlsZWQgYGJlZm9yZWAgaG9vayBza2lwcyBhbGwgdGVzdHMgaW4gYSBzdWl0ZSBhbmQgc3Vic3VpdGVzLFxuICogICBidXQganVtcHMgdG8gY29ycmVzcG9uZGluZyBgYWZ0ZXJgIGhvb2tcbiAqIC0gRmFpbGVkIGBiZWZvcmUgZWFjaGAgaG9vayBza2lwcyByZW1haW5pbmcgdGVzdHMgaW4gYVxuICogICBzdWl0ZSBhbmQganVtcHMgdG8gY29ycmVzcG9uZGluZyBgYWZ0ZXIgZWFjaGAgaG9vayxcbiAqICAgd2hpY2ggaXMgcnVuIG9ubHkgb25jZVxuICogLSBGYWlsZWQgYGFmdGVyYCBob29rIGRvZXMgbm90IGFsdGVyIGV4ZWN1dGlvbiBvcmRlclxuICogLSBGYWlsZWQgYGFmdGVyIGVhY2hgIGhvb2sgc2tpcHMgcmVtYWluaW5nIHRlc3RzIGluIGFcbiAqICAgc3VpdGUgYW5kIHN1YnN1aXRlcywgYnV0IGV4ZWN1dGVzIG90aGVyIGBhZnRlciBlYWNoYFxuICogICBob29rc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1J1bm5hYmxlfSB0ZXN0XG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSAtIFdoZXRoZXIgdG8gZmFpbCBhIHBlbmRpbmcgdGVzdC5cbiAqL1xuUnVubmVyLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24gKHRlc3QsIGVyciwgZm9yY2UpIHtcbiAgZm9yY2UgPSBmb3JjZSA9PT0gdHJ1ZTtcbiAgaWYgKHRlc3QuaXNQZW5kaW5nKCkgJiYgIWZvcmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0aGlzLnN0YXRlID09PSBjb25zdGFudHMuU1RBVEVfU1RPUFBFRCkge1xuICAgIGlmIChlcnIuY29kZSA9PT0gZXJyb3JDb25zdGFudHMuTVVMVElQTEVfRE9ORSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICB0aHJvdyBjcmVhdGVGYXRhbEVycm9yKFxuICAgICAgJ1Rlc3QgZmFpbGVkIGFmdGVyIHJvb3Qgc3VpdGUgZXhlY3V0aW9uIGNvbXBsZXRlZCEnLFxuICAgICAgZXJyXG4gICAgKTtcbiAgfVxuXG4gICsrdGhpcy5mYWlsdXJlcztcbiAgZGVidWcoJ3RvdGFsIG51bWJlciBvZiBmYWlsdXJlczogJWQnLCB0aGlzLmZhaWx1cmVzKTtcbiAgdGVzdC5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcblxuICBpZiAoIWlzRXJyb3IoZXJyKSkge1xuICAgIGVyciA9IHRocm93bjJFcnJvcihlcnIpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBlcnIuc3RhY2sgPVxuICAgICAgdGhpcy5mdWxsU3RhY2tUcmFjZSB8fCAhZXJyLnN0YWNrID8gZXJyLnN0YWNrIDogc3RhY2tGaWx0ZXIoZXJyLnN0YWNrKTtcbiAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgLy8gc29tZSBlbnZpcm9ubWVudHMgZG8gbm90IHRha2Uga2luZGx5IHRvIG1vbmtleWluZyB3aXRoIHRoZSBzdGFja1xuICB9XG5cbiAgdGhpcy5lbWl0KGNvbnN0YW50cy5FVkVOVF9URVNUX0ZBSUwsIHRlc3QsIGVycik7XG59O1xuXG4vKipcbiAqIFJ1biBob29rIGBuYW1lYCBjYWxsYmFja3MgYW5kIHRoZW4gaW52b2tlIGBmbigpYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblxuUnVubmVyLnByb3RvdHlwZS5ob29rID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gIGlmICh0aGlzLl9vcHRzLmRyeVJ1bikgcmV0dXJuIGZuKCk7XG5cbiAgdmFyIHN1aXRlID0gdGhpcy5zdWl0ZTtcbiAgdmFyIGhvb2tzID0gc3VpdGUuZ2V0SG9va3MobmFtZSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBuZXh0KGkpIHtcbiAgICB2YXIgaG9vayA9IGhvb2tzW2ldO1xuICAgIGlmICghaG9vaykge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIHNlbGYuY3VycmVudFJ1bm5hYmxlID0gaG9vaztcblxuICAgIGlmIChuYW1lID09PSBIT09LX1RZUEVfQkVGT1JFX0FMTCkge1xuICAgICAgaG9vay5jdHguY3VycmVudFRlc3QgPSBob29rLnBhcmVudC50ZXN0c1swXTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IEhPT0tfVFlQRV9BRlRFUl9BTEwpIHtcbiAgICAgIGhvb2suY3R4LmN1cnJlbnRUZXN0ID0gaG9vay5wYXJlbnQudGVzdHNbaG9vay5wYXJlbnQudGVzdHMubGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2suY3R4LmN1cnJlbnRUZXN0ID0gc2VsZi50ZXN0O1xuICAgIH1cblxuICAgIHNldEhvb2tUaXRsZShob29rKTtcblxuICAgIGhvb2suYWxsb3dVbmNhdWdodCA9IHNlbGYuYWxsb3dVbmNhdWdodDtcblxuICAgIHNlbGYuZW1pdChjb25zdGFudHMuRVZFTlRfSE9PS19CRUdJTiwgaG9vayk7XG5cbiAgICBpZiAoIWhvb2subGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCkge1xuICAgICAgc2VsZi5fYWRkRXZlbnRMaXN0ZW5lcihob29rLCAnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHNlbGYuZmFpbChob29rLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaG9vay5ydW4oZnVuY3Rpb24gY2JIb29rUnVuKGVycikge1xuICAgICAgdmFyIHRlc3RFcnJvciA9IGhvb2suZXJyb3IoKTtcbiAgICAgIGlmICh0ZXN0RXJyb3IpIHtcbiAgICAgICAgc2VsZi5mYWlsKHNlbGYudGVzdCwgdGVzdEVycm9yKTtcbiAgICAgIH1cbiAgICAgIC8vIGNvbmRpdGlvbmFsIHNraXBcbiAgICAgIGlmIChob29rLnBlbmRpbmcpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IEhPT0tfVFlQRV9BRlRFUl9FQUNIKSB7XG4gICAgICAgICAgLy8gVE9ETyBkZWZpbmUgYW5kIGltcGxlbWVudCB1c2UgY2FzZVxuICAgICAgICAgIGlmIChzZWxmLnRlc3QpIHtcbiAgICAgICAgICAgIHNlbGYudGVzdC5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gSE9PS19UWVBFX0JFRk9SRV9FQUNIKSB7XG4gICAgICAgICAgaWYgKHNlbGYudGVzdCkge1xuICAgICAgICAgICAgc2VsZi50ZXN0LnBlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmVtaXQoY29uc3RhbnRzLkVWRU5UX0hPT0tfRU5ELCBob29rKTtcbiAgICAgICAgICBob29rLnBlbmRpbmcgPSBmYWxzZTsgLy8gYWN0aXZhdGVzIGhvb2sgZm9yIG5leHQgdGVzdFxuICAgICAgICAgIHJldHVybiBmbihuZXcgRXJyb3IoJ2Fib3J0IGhvb2tEb3duJykpO1xuICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IEhPT0tfVFlQRV9CRUZPUkVfQUxMKSB7XG4gICAgICAgICAgc3VpdGUudGVzdHMuZm9yRWFjaChmdW5jdGlvbiAodGVzdCkge1xuICAgICAgICAgICAgdGVzdC5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdWl0ZS5zdWl0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc3VpdGUpIHtcbiAgICAgICAgICAgIHN1aXRlLnBlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGhvb2tzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaG9vay5wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGVyckZvcmJpZCA9IGNyZWF0ZVVuc3VwcG9ydGVkRXJyb3IoJ2B0aGlzLnNraXBgIGZvcmJpZGRlbicpO1xuICAgICAgICAgIHNlbGYuZmFpbChob29rLCBlcnJGb3JiaWQpO1xuICAgICAgICAgIHJldHVybiBmbihlcnJGb3JiaWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgICBzZWxmLmZhaWwoaG9vaywgZXJyKTtcbiAgICAgICAgLy8gc3RvcCBleGVjdXRpbmcgaG9va3MsIG5vdGlmeSBjYWxsZWUgb2YgaG9vayBlcnJcbiAgICAgICAgcmV0dXJuIGZuKGVycik7XG4gICAgICB9XG4gICAgICBzZWxmLmVtaXQoY29uc3RhbnRzLkVWRU5UX0hPT0tfRU5ELCBob29rKTtcbiAgICAgIGRlbGV0ZSBob29rLmN0eC5jdXJyZW50VGVzdDtcbiAgICAgIHNldEhvb2tUaXRsZShob29rKTtcbiAgICAgIG5leHQoKytpKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHNldEhvb2tUaXRsZShob29rKSB7XG4gICAgICBob29rLm9yaWdpbmFsVGl0bGUgPSBob29rLm9yaWdpbmFsVGl0bGUgfHwgaG9vay50aXRsZTtcbiAgICAgIGlmIChob29rLmN0eCAmJiBob29rLmN0eC5jdXJyZW50VGVzdCkge1xuICAgICAgICBob29rLnRpdGxlID0gYCR7aG9vay5vcmlnaW5hbFRpdGxlfSBmb3IgXCIke2hvb2suY3R4LmN1cnJlbnRUZXN0LnRpdGxlfVwiYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwYXJlbnRUaXRsZTtcbiAgICAgICAgaWYgKGhvb2sucGFyZW50LnRpdGxlKSB7XG4gICAgICAgICAgcGFyZW50VGl0bGUgPSBob29rLnBhcmVudC50aXRsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnRUaXRsZSA9IGhvb2sucGFyZW50LnJvb3QgPyAne3Jvb3R9JyA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIGhvb2sudGl0bGUgPSBgJHtob29rLm9yaWdpbmFsVGl0bGV9IGluIFwiJHtwYXJlbnRUaXRsZX1cImA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgUnVubmVyLmltbWVkaWF0ZWx5KGZ1bmN0aW9uICgpIHtcbiAgICBuZXh0KDApO1xuICB9KTtcbn07XG5cbi8qKlxuICogUnVuIGhvb2sgYG5hbWVgIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHN1aXRlc2BcbiAqIGluIG9yZGVyLCBhbmQgY2FsbGJhY2sgYGZuKGVyciwgZXJyU3VpdGUpYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7QXJyYXl9IHN1aXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuUnVubmVyLnByb3RvdHlwZS5ob29rcyA9IGZ1bmN0aW9uIChuYW1lLCBzdWl0ZXMsIGZuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG9yaWcgPSB0aGlzLnN1aXRlO1xuXG4gIGZ1bmN0aW9uIG5leHQoc3VpdGUpIHtcbiAgICBzZWxmLnN1aXRlID0gc3VpdGU7XG5cbiAgICBpZiAoIXN1aXRlKSB7XG4gICAgICBzZWxmLnN1aXRlID0gb3JpZztcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH1cblxuICAgIHNlbGYuaG9vayhuYW1lLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHZhciBlcnJTdWl0ZSA9IHNlbGYuc3VpdGU7XG4gICAgICAgIHNlbGYuc3VpdGUgPSBvcmlnO1xuICAgICAgICByZXR1cm4gZm4oZXJyLCBlcnJTdWl0ZSk7XG4gICAgICB9XG5cbiAgICAgIG5leHQoc3VpdGVzLnBvcCgpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG5leHQoc3VpdGVzLnBvcCgpKTtcbn07XG5cbi8qKlxuICogUnVuICdhZnRlckVhY2gnIGhvb2tzIGZyb20gYm90dG9tIHVwLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHByaXZhdGVcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5ob29rVXAgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgdmFyIHN1aXRlcyA9IFt0aGlzLnN1aXRlXS5jb25jYXQodGhpcy5wYXJlbnRzKCkpLnJldmVyc2UoKTtcbiAgdGhpcy5ob29rcyhuYW1lLCBzdWl0ZXMsIGZuKTtcbn07XG5cbi8qKlxuICogUnVuICdiZWZvcmVFYWNoJyBob29rcyBmcm9tIHRvcCBsZXZlbCBkb3duLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHByaXZhdGVcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5ob29rRG93biA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICB2YXIgc3VpdGVzID0gW3RoaXMuc3VpdGVdLmNvbmNhdCh0aGlzLnBhcmVudHMoKSk7XG4gIHRoaXMuaG9va3MobmFtZSwgc3VpdGVzLCBmbik7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBvZiBwYXJlbnQgU3VpdGVzIGZyb21cbiAqIGNsb3Nlc3QgdG8gZnVydGhlc3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5SdW5uZXIucHJvdG90eXBlLnBhcmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdWl0ZSA9IHRoaXMuc3VpdGU7XG4gIHZhciBzdWl0ZXMgPSBbXTtcbiAgd2hpbGUgKHN1aXRlLnBhcmVudCkge1xuICAgIHN1aXRlID0gc3VpdGUucGFyZW50O1xuICAgIHN1aXRlcy5wdXNoKHN1aXRlKTtcbiAgfVxuICByZXR1cm4gc3VpdGVzO1xufTtcblxuLyoqXG4gKiBSdW4gdGhlIGN1cnJlbnQgdGVzdCBhbmQgY2FsbGJhY2sgYGZuKGVycilgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcHJpdmF0ZVxuICovXG5SdW5uZXIucHJvdG90eXBlLnJ1blRlc3QgPSBmdW5jdGlvbiAoZm4pIHtcbiAgaWYgKHRoaXMuX29wdHMuZHJ5UnVuKSByZXR1cm4gUnVubmVyLmltbWVkaWF0ZWx5KGZuKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0ZXN0ID0gdGhpcy50ZXN0O1xuXG4gIGlmICghdGVzdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLmFzeW5jT25seSkge1xuICAgIHRlc3QuYXN5bmNPbmx5ID0gdHJ1ZTtcbiAgfVxuICB0aGlzLl9hZGRFdmVudExpc3RlbmVyKHRlc3QsICdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLmZhaWwodGVzdCwgZXJyKTtcbiAgfSk7XG4gIGlmICh0aGlzLmFsbG93VW5jYXVnaHQpIHtcbiAgICB0ZXN0LmFsbG93VW5jYXVnaHQgPSB0cnVlO1xuICAgIHJldHVybiB0ZXN0LnJ1bihmbik7XG4gIH1cbiAgdHJ5IHtcbiAgICB0ZXN0LnJ1bihmbik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGZuKGVycik7XG4gIH1cbn07XG5cbi8qKlxuICogUnVuIHRlc3RzIGluIHRoZSBnaXZlbiBgc3VpdGVgIGFuZCBpbnZva2UgdGhlIGNhbGxiYWNrIGBmbigpYCB3aGVuIGNvbXBsZXRlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuUnVubmVyLnByb3RvdHlwZS5ydW5UZXN0cyA9IGZ1bmN0aW9uIChzdWl0ZSwgZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdGVzdHMgPSBzdWl0ZS50ZXN0cy5zbGljZSgpO1xuICB2YXIgdGVzdDtcblxuICBmdW5jdGlvbiBob29rRXJyKF8sIGVyclN1aXRlLCBhZnRlcikge1xuICAgIC8vIGJlZm9yZS9hZnRlciBFYWNoIGhvb2sgZm9yIGVyclN1aXRlIGZhaWxlZDpcbiAgICB2YXIgb3JpZyA9IHNlbGYuc3VpdGU7XG5cbiAgICAvLyBmb3IgZmFpbGVkICdhZnRlciBlYWNoJyBob29rIHN0YXJ0IGZyb20gZXJyU3VpdGUgcGFyZW50LFxuICAgIC8vIG90aGVyd2lzZSBzdGFydCBmcm9tIGVyclN1aXRlIGl0c2VsZlxuICAgIHNlbGYuc3VpdGUgPSBhZnRlciA/IGVyclN1aXRlLnBhcmVudCA6IGVyclN1aXRlO1xuXG4gICAgaWYgKHNlbGYuc3VpdGUpIHtcbiAgICAgIHNlbGYuaG9va1VwKEhPT0tfVFlQRV9BRlRFUl9FQUNILCBmdW5jdGlvbiAoZXJyMiwgZXJyU3VpdGUyKSB7XG4gICAgICAgIHNlbGYuc3VpdGUgPSBvcmlnO1xuICAgICAgICAvLyBzb21lIGhvb2tzIG1heSBmYWlsIGV2ZW4gbm93XG4gICAgICAgIGlmIChlcnIyKSB7XG4gICAgICAgICAgcmV0dXJuIGhvb2tFcnIoZXJyMiwgZXJyU3VpdGUyLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXBvcnQgZXJyb3Igc3VpdGVcbiAgICAgICAgZm4oZXJyU3VpdGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgY2FsbGluZyBvdGhlciAnYWZ0ZXIgZWFjaCcgaG9va3NcbiAgICAgIHNlbGYuc3VpdGUgPSBvcmlnO1xuICAgICAgZm4oZXJyU3VpdGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQoZXJyLCBlcnJTdWl0ZSkge1xuICAgIC8vIGlmIHdlIGJhaWwgYWZ0ZXIgZmlyc3QgZXJyXG4gICAgaWYgKHNlbGYuZmFpbHVyZXMgJiYgc3VpdGUuX2JhaWwpIHtcbiAgICAgIHRlc3RzID0gW107XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuX2Fib3J0KSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gaG9va0VycihlcnIsIGVyclN1aXRlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBuZXh0IHRlc3RcbiAgICB0ZXN0ID0gdGVzdHMuc2hpZnQoKTtcblxuICAgIC8vIGFsbCBkb25lXG4gICAgaWYgKCF0ZXN0KSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG5cbiAgICAvLyBncmVwXG4gICAgdmFyIG1hdGNoID0gc2VsZi5fZ3JlcC50ZXN0KHRlc3QuZnVsbFRpdGxlKCkpO1xuICAgIGlmIChzZWxmLl9pbnZlcnQpIHtcbiAgICAgIG1hdGNoID0gIW1hdGNoO1xuICAgIH1cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAvLyBSdW4gaW1tZWRpYXRlbHkgb25seSBpZiB3ZSBoYXZlIGRlZmluZWQgYSBncmVwLiBXaGVuIHdlXG4gICAgICAvLyBkZWZpbmUgYSBncmVwIOKAlCBJdCBjYW4gY2F1c2UgbWF4aW11bSBjYWxsc3RhY2sgZXJyb3IgaWZcbiAgICAgIC8vIHRoZSBncmVwIGlzIGRvaW5nIGEgbGFyZ2UgcmVjdXJzaXZlIGxvb3AgYnkgbmVnbGVjdGluZ1xuICAgICAgLy8gYWxsIHRlc3RzLiBUaGUgcnVuIGltbWVkaWF0ZWx5IGZ1bmN0aW9uIGFsc28gY29tZXMgd2l0aFxuICAgICAgLy8gYSBwZXJmb3JtYW5jZSBjb3N0LiBTbyB3ZSBkb24ndCB3YW50IHRvIHJ1biBpbW1lZGlhdGVseVxuICAgICAgLy8gaWYgd2UgcnVuIHRoZSB3aG9sZSB0ZXN0IHN1aXRlLCBiZWNhdXNlIHJ1bm5pbmcgdGhlIHdob2xlXG4gICAgICAvLyB0ZXN0IHN1aXRlIGRvbid0IGRvIGFueSBpbW1lZGlhdGUgcmVjdXJzaXZlIGxvb3BzLiBUaHVzLFxuICAgICAgLy8gYWxsb3dpbmcgYSBKUyBydW50aW1lIHRvIGJyZWF0aGUuXG4gICAgICBpZiAoc2VsZi5fZ3JlcCAhPT0gc2VsZi5fZGVmYXVsdEdyZXApIHtcbiAgICAgICAgUnVubmVyLmltbWVkaWF0ZWx5KG5leHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHN0YXRpYyBza2lwLCBubyBob29rcyBhcmUgZXhlY3V0ZWRcbiAgICBpZiAodGVzdC5pc1BlbmRpbmcoKSkge1xuICAgICAgaWYgKHNlbGYuZm9yYmlkUGVuZGluZykge1xuICAgICAgICBzZWxmLmZhaWwodGVzdCwgbmV3IEVycm9yKCdQZW5kaW5nIHRlc3QgZm9yYmlkZGVuJyksIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVzdC5zdGF0ZSA9IFNUQVRFX1BFTkRJTkc7XG4gICAgICAgIHNlbGYuZW1pdChjb25zdGFudHMuRVZFTlRfVEVTVF9QRU5ESU5HLCB0ZXN0KTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW1pdChjb25zdGFudHMuRVZFTlRfVEVTVF9FTkQsIHRlc3QpO1xuICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9XG5cbiAgICAvLyBleGVjdXRlIHRlc3QgYW5kIGhvb2socylcbiAgICBzZWxmLmVtaXQoY29uc3RhbnRzLkVWRU5UX1RFU1RfQkVHSU4sIChzZWxmLnRlc3QgPSB0ZXN0KSk7XG4gICAgc2VsZi5ob29rRG93bihIT09LX1RZUEVfQkVGT1JFX0VBQ0gsIGZ1bmN0aW9uIChlcnIsIGVyclN1aXRlKSB7XG4gICAgICAvLyBjb25kaXRpb25hbCBza2lwIHdpdGhpbiBiZWZvcmVFYWNoXG4gICAgICBpZiAodGVzdC5pc1BlbmRpbmcoKSkge1xuICAgICAgICBpZiAoc2VsZi5mb3JiaWRQZW5kaW5nKSB7XG4gICAgICAgICAgc2VsZi5mYWlsKHRlc3QsIG5ldyBFcnJvcignUGVuZGluZyB0ZXN0IGZvcmJpZGRlbicpLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXN0LnN0YXRlID0gU1RBVEVfUEVORElORztcbiAgICAgICAgICBzZWxmLmVtaXQoY29uc3RhbnRzLkVWRU5UX1RFU1RfUEVORElORywgdGVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5lbWl0KGNvbnN0YW50cy5FVkVOVF9URVNUX0VORCwgdGVzdCk7XG4gICAgICAgIC8vIHNraXAgaW5uZXIgYWZ0ZXJFYWNoIGhvb2tzIGJlbG93IGVyclN1aXRlIGxldmVsXG4gICAgICAgIHZhciBvcmlnU3VpdGUgPSBzZWxmLnN1aXRlO1xuICAgICAgICBzZWxmLnN1aXRlID0gZXJyU3VpdGUgfHwgc2VsZi5zdWl0ZTtcbiAgICAgICAgcmV0dXJuIHNlbGYuaG9va1VwKEhPT0tfVFlQRV9BRlRFUl9FQUNILCBmdW5jdGlvbiAoZSwgZVN1aXRlKSB7XG4gICAgICAgICAgc2VsZi5zdWl0ZSA9IG9yaWdTdWl0ZTtcbiAgICAgICAgICBuZXh0KGUsIGVTdWl0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gaG9va0VycihlcnIsIGVyclN1aXRlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBzZWxmLmN1cnJlbnRSdW5uYWJsZSA9IHNlbGYudGVzdDtcbiAgICAgIHNlbGYucnVuVGVzdChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRlc3QgPSBzZWxmLnRlc3Q7XG4gICAgICAgIC8vIGNvbmRpdGlvbmFsIHNraXAgd2l0aGluIGl0XG4gICAgICAgIGlmICh0ZXN0LnBlbmRpbmcpIHtcbiAgICAgICAgICBpZiAoc2VsZi5mb3JiaWRQZW5kaW5nKSB7XG4gICAgICAgICAgICBzZWxmLmZhaWwodGVzdCwgbmV3IEVycm9yKCdQZW5kaW5nIHRlc3QgZm9yYmlkZGVuJyksIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXN0LnN0YXRlID0gU1RBVEVfUEVORElORztcbiAgICAgICAgICAgIHNlbGYuZW1pdChjb25zdGFudHMuRVZFTlRfVEVTVF9QRU5ESU5HLCB0ZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5lbWl0KGNvbnN0YW50cy5FVkVOVF9URVNUX0VORCwgdGVzdCk7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuaG9va1VwKEhPT0tfVFlQRV9BRlRFUl9FQUNILCBuZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgICB2YXIgcmV0cnkgPSB0ZXN0LmN1cnJlbnRSZXRyeSgpO1xuICAgICAgICAgIGlmIChyZXRyeSA8IHRlc3QucmV0cmllcygpKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmVkVGVzdCA9IHRlc3QuY2xvbmUoKTtcbiAgICAgICAgICAgIGNsb25lZFRlc3QuY3VycmVudFJldHJ5KHJldHJ5ICsgMSk7XG4gICAgICAgICAgICB0ZXN0cy51bnNoaWZ0KGNsb25lZFRlc3QpO1xuXG4gICAgICAgICAgICBzZWxmLmVtaXQoY29uc3RhbnRzLkVWRU5UX1RFU1RfUkVUUlksIHRlc3QsIGVycik7XG5cbiAgICAgICAgICAgIC8vIEVhcmx5IHJldHVybiArIGhvb2sgdHJpZ2dlciBzbyB0aGF0IGl0IGRvZXNuJ3RcbiAgICAgICAgICAgIC8vIGluY3JlbWVudCB0aGUgY291bnQgd3JvbmdcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmhvb2tVcChIT09LX1RZUEVfQUZURVJfRUFDSCwgbmV4dCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZmFpbCh0ZXN0LCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmVtaXQoY29uc3RhbnRzLkVWRU5UX1RFU1RfRU5ELCB0ZXN0KTtcbiAgICAgICAgICByZXR1cm4gc2VsZi5ob29rVXAoSE9PS19UWVBFX0FGVEVSX0VBQ0gsIG5leHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVzdC5zdGF0ZSA9IFNUQVRFX1BBU1NFRDtcbiAgICAgICAgc2VsZi5lbWl0KGNvbnN0YW50cy5FVkVOVF9URVNUX1BBU1MsIHRlc3QpO1xuICAgICAgICBzZWxmLmVtaXQoY29uc3RhbnRzLkVWRU5UX1RFU1RfRU5ELCB0ZXN0KTtcbiAgICAgICAgc2VsZi5ob29rVXAoSE9PS19UWVBFX0FGVEVSX0VBQ0gsIG5leHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICB0aGlzLm5leHQgPSBuZXh0O1xuICB0aGlzLmhvb2tFcnIgPSBob29rRXJyO1xuICBuZXh0KCk7XG59O1xuXG4vKipcbiAqIFJ1biB0aGUgZ2l2ZW4gYHN1aXRlYCBhbmQgaW52b2tlIHRoZSBjYWxsYmFjayBgZm4oKWAgd2hlbiBjb21wbGV0ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblJ1bm5lci5wcm90b3R5cGUucnVuU3VpdGUgPSBmdW5jdGlvbiAoc3VpdGUsIGZuKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdG90YWwgPSB0aGlzLmdyZXBUb3RhbChzdWl0ZSk7XG5cbiAgZGVidWcoJ3J1blN1aXRlKCk6IHJ1bm5pbmcgJXMnLCBzdWl0ZS5mdWxsVGl0bGUoKSk7XG5cbiAgaWYgKCF0b3RhbCB8fCAoc2VsZi5mYWlsdXJlcyAmJiBzdWl0ZS5fYmFpbCkpIHtcbiAgICBkZWJ1ZygncnVuU3VpdGUoKTogYmFpbGluZycpO1xuICAgIHJldHVybiBmbigpO1xuICB9XG5cbiAgdGhpcy5lbWl0KGNvbnN0YW50cy5FVkVOVF9TVUlURV9CRUdJTiwgKHRoaXMuc3VpdGUgPSBzdWl0ZSkpO1xuXG4gIGZ1bmN0aW9uIG5leHQoZXJyU3VpdGUpIHtcbiAgICBpZiAoZXJyU3VpdGUpIHtcbiAgICAgIC8vIGN1cnJlbnQgc3VpdGUgZmFpbGVkIG9uIGEgaG9vayBmcm9tIGVyclN1aXRlXG4gICAgICBpZiAoZXJyU3VpdGUgPT09IHN1aXRlKSB7XG4gICAgICAgIC8vIGlmIGVyclN1aXRlIGlzIGN1cnJlbnQgc3VpdGVcbiAgICAgICAgLy8gY29udGludWUgdG8gdGhlIG5leHQgc2libGluZyBzdWl0ZVxuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuICAgICAgLy8gZXJyU3VpdGUgaXMgYW1vbmcgdGhlIHBhcmVudHMgb2YgY3VycmVudCBzdWl0ZVxuICAgICAgLy8gc3RvcCBleGVjdXRpb24gb2YgZXJyU3VpdGUgYW5kIGFsbCBzdWItc3VpdGVzXG4gICAgICByZXR1cm4gZG9uZShlcnJTdWl0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuX2Fib3J0KSB7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cblxuICAgIHZhciBjdXJyID0gc3VpdGUuc3VpdGVzW2krK107XG4gICAgaWYgKCFjdXJyKSB7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEF2b2lkIGdyZXAgbmVnbGVjdGluZyBsYXJnZSBudW1iZXIgb2YgdGVzdHMgY2F1c2luZyBhXG4gICAgLy8gaHVnZSByZWN1cnNpdmUgbG9vcCBhbmQgdGh1cyBhIG1heGltdW0gY2FsbCBzdGFjayBlcnJvci5cbiAgICAvLyBTZWUgY29tbWVudCBpbiBgdGhpcy5ydW5UZXN0cygpYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICBpZiAoc2VsZi5fZ3JlcCAhPT0gc2VsZi5fZGVmYXVsdEdyZXApIHtcbiAgICAgIFJ1bm5lci5pbW1lZGlhdGVseShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucnVuU3VpdGUoY3VyciwgbmV4dCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5ydW5TdWl0ZShjdXJyLCBuZXh0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkb25lKGVyclN1aXRlKSB7XG4gICAgc2VsZi5zdWl0ZSA9IHN1aXRlO1xuICAgIHNlbGYubmV4dFN1aXRlID0gbmV4dDtcblxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gdGVzdFxuICAgIGRlbGV0ZSBzZWxmLnRlc3Q7XG5cbiAgICBzZWxmLmhvb2soSE9PS19UWVBFX0FGVEVSX0FMTCwgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5lbWl0KGNvbnN0YW50cy5FVkVOVF9TVUlURV9FTkQsIHN1aXRlKTtcbiAgICAgIGZuKGVyclN1aXRlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMubmV4dFN1aXRlID0gbmV4dDtcblxuICB0aGlzLmhvb2soSE9PS19UWVBFX0JFRk9SRV9BTEwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cbiAgICBzZWxmLnJ1blRlc3RzKHN1aXRlLCBuZXh0KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSB1bmNhdWdodCBleGNlcHRpb25zIHdpdGhpbiBydW5uZXIuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBib3VuZCB0byB0aGUgaW5zdGFuY2UgYXMgYFJ1bm5lciN1bmNhdWdodGAgYXQgaW5zdGFudGlhdGlvblxuICogdGltZS4gSXQncyBpbnRlbmRlZCB0byBiZSBsaXN0ZW5pbmcgb24gdGhlIGBQcm9jZXNzLnVuY2F1Z2h0RXhjZXB0aW9uYCBldmVudC5cbiAqIEluIG9yZGVyIHRvIG5vdCBsZWFrIEVFIGxpc3RlbmVycywgd2UgbmVlZCB0byBlbnN1cmUgbm8gbW9yZSB0aGFuIGEgc2luZ2xlXG4gKiBgdW5jYXVnaHRFeGNlcHRpb25gIGxpc3RlbmVyIGV4aXN0cyBwZXIgYFJ1bm5lcmAuICBUaGUgb25seSB3YXkgdG8gZG9cbiAqIHRoaXMtLWJlY2F1c2UgdGhpcyBmdW5jdGlvbiBuZWVkcyB0aGUgY29udGV4dCAoYW5kIHdlIGRvbid0IGhhdmUgbGFtYmRhcyktLWlzXG4gKiB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYC4gV2UgbmVlZCBzdHJpY3QgZXF1YWxpdHkgdG8gdW5yZWdpc3RlciBhbmRcbiAqIF9vbmx5XyB1bnJlZ2lzdGVyIHRoZSBfb25lXyBsaXN0ZW5lciB3ZSBzZXQgZnJvbSB0aGVcbiAqIGBQcm9jZXNzLnVuY2F1Z2h0RXhjZXB0aW9uYCBldmVudDsgd291bGQgYmUgcG9vciBmb3JtIHRvIGp1c3QgcmVtb3ZlXG4gKiBldmVyeXRoaW5nLiBTZWUge0BsaW5rIFJ1bm5lciNydW59IGZvciB3aGVyZSB0aGUgZXZlbnQgbGlzdGVuZXIgaXMgcmVnaXN0ZXJlZFxuICogYW5kIHVucmVnaXN0ZXJlZC5cbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIFNvbWUgdW5jYXVnaHQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5lci5wcm90b3R5cGUuX3VuY2F1Z2h0ID0gZnVuY3Rpb24gKGVycikge1xuICAvLyB0aGlzIGlzIGRlZmVuc2l2ZSB0byBwcmV2ZW50IGZ1dHVyZSBkZXZlbG9wZXJzIGZyb20gbWlzLWNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgLy8gaXQncyBtb3JlIGxpa2VseSB0aGF0IGl0J2QgYmUgY2FsbGVkIHdpdGggdGhlIGluY29ycmVjdCBjb250ZXh0LS1zYXksIHRoZSBnbG9iYWxcbiAgLy8gYHByb2Nlc3NgIG9iamVjdC0tdGhhbiBpdCB3b3VsZCB0byBiZSBjYWxsZWQgd2l0aCBhIGNvbnRleHQgdGhhdCBpcyBub3QgYSBcInN1YmNsYXNzXCJcbiAgLy8gb2YgYFJ1bm5lcmAuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSdW5uZXIpKSB7XG4gICAgdGhyb3cgY3JlYXRlRmF0YWxFcnJvcihcbiAgICAgICdSdW5uZXIjdW5jYXVnaHQoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGNvbnRleHQnLFxuICAgICAgdGhpc1xuICAgICk7XG4gIH1cbiAgaWYgKGVyciBpbnN0YW5jZW9mIFBlbmRpbmcpIHtcbiAgICBkZWJ1ZygndW5jYXVnaHQoKTogY2F1Z2h0IGEgUGVuZGluZycpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBicm93c2VyIGRvZXMgbm90IGV4aXQgc2NyaXB0IHdoZW4gdGhyb3dpbmcgaW4gZ2xvYmFsLm9uZXJyb3IoKVxuICBpZiAodGhpcy5hbGxvd1VuY2F1Z2h0ICYmICF1dGlscy5pc0Jyb3dzZXIoKSkge1xuICAgIGRlYnVnKCd1bmNhdWdodCgpOiBidWJibGluZyBleGNlcHRpb24gZHVlIHRvIC0tYWxsb3ctdW5jYXVnaHQnKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICBpZiAodGhpcy5zdGF0ZSA9PT0gY29uc3RhbnRzLlNUQVRFX1NUT1BQRUQpIHtcbiAgICBkZWJ1ZygndW5jYXVnaHQoKTogdGhyb3dpbmcgYWZ0ZXIgcnVuIGhhcyBjb21wbGV0ZWQhJyk7XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgaWYgKGVycikge1xuICAgIGRlYnVnKCd1bmNhdWdodCgpOiBnb3QgdHJ1dGh5IGV4Y2VwdGlvbiAlTycsIGVycik7XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ3VuY2F1Z2h0KCk6IHVuZGVmaW5lZC9mYWxzeSBleGNlcHRpb24nKTtcbiAgICBlcnIgPSBjcmVhdGVJbnZhbGlkRXhjZXB0aW9uRXJyb3IoXG4gICAgICAnQ2F1Z2h0IGZhbHN5L3VuZGVmaW5lZCBleGNlcHRpb24gd2hpY2ggd291bGQgb3RoZXJ3aXNlIGJlIHVuY2F1Z2h0LiBObyBzdGFjayB0cmFjZSBmb3VuZDsgdHJ5IGEgZGVidWdnZXInLFxuICAgICAgZXJyXG4gICAgKTtcbiAgfVxuXG4gIGlmICghaXNFcnJvcihlcnIpKSB7XG4gICAgZXJyID0gdGhyb3duMkVycm9yKGVycik7XG4gICAgZGVidWcoJ3VuY2F1Z2h0KCk6IGNvbnZlcnRlZCBcImVycm9yXCIgJW8gdG8gRXJyb3InLCBlcnIpO1xuICB9XG4gIGVyci51bmNhdWdodCA9IHRydWU7XG5cbiAgdmFyIHJ1bm5hYmxlID0gdGhpcy5jdXJyZW50UnVubmFibGU7XG5cbiAgaWYgKCFydW5uYWJsZSkge1xuICAgIHJ1bm5hYmxlID0gbmV3IFJ1bm5hYmxlKCdVbmNhdWdodCBlcnJvciBvdXRzaWRlIHRlc3Qgc3VpdGUnKTtcbiAgICBkZWJ1ZygndW5jYXVnaHQoKTogbm8gY3VycmVudCBSdW5uYWJsZTsgY3JlYXRlZCBhIHBob255IG9uZScpO1xuICAgIHJ1bm5hYmxlLnBhcmVudCA9IHRoaXMuc3VpdGU7XG5cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gY29uc3RhbnRzLlNUQVRFX1JVTk5JTkcpIHtcbiAgICAgIGRlYnVnKCd1bmNhdWdodCgpOiBmYWlsaW5nIGdyYWNlZnVsbHknKTtcbiAgICAgIHRoaXMuZmFpbChydW5uYWJsZSwgZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FuJ3QgcmVjb3ZlciBmcm9tIHRoaXMgZmFpbHVyZVxuICAgICAgZGVidWcoJ3VuY2F1Z2h0KCk6IHRlc3QgcnVuIGhhcyBub3QgeWV0IHN0YXJ0ZWQ7IHVucmVjb3ZlcmFibGUnKTtcbiAgICAgIHRoaXMuZW1pdChjb25zdGFudHMuRVZFTlRfUlVOX0JFR0lOKTtcbiAgICAgIHRoaXMuZmFpbChydW5uYWJsZSwgZXJyKTtcbiAgICAgIHRoaXMuZW1pdChjb25zdGFudHMuRVZFTlRfUlVOX0VORCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcnVubmFibGUuY2xlYXJUaW1lb3V0KCk7XG5cbiAgaWYgKHJ1bm5hYmxlLmlzRmFpbGVkKCkpIHtcbiAgICBkZWJ1ZygndW5jYXVnaHQoKTogUnVubmFibGUgaGFzIGFscmVhZHkgZmFpbGVkJyk7XG4gICAgLy8gSWdub3JlIGVycm9yIGlmIGFscmVhZHkgZmFpbGVkXG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHJ1bm5hYmxlLmlzUGVuZGluZygpKSB7XG4gICAgZGVidWcoJ3VuY2F1Z2h0KCk6IHBlbmRpbmcgUnVubmFibGUgd291bmQgdXAgZmFpbGluZyEnKTtcbiAgICAvLyByZXBvcnQgJ3BlbmRpbmcgdGVzdCcgcmV0cm9zcGVjdGl2ZWx5IGFzIGZhaWxlZFxuICAgIHRoaXMuZmFpbChydW5uYWJsZSwgZXJyLCB0cnVlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyB3ZSBjYW5ub3QgcmVjb3ZlciBncmFjZWZ1bGx5IGlmIGEgUnVubmFibGUgaGFzIGFscmVhZHkgcGFzc2VkXG4gIC8vIHRoZW4gZmFpbHMgYXN5bmNocm9ub3VzbHlcbiAgaWYgKHJ1bm5hYmxlLmlzUGFzc2VkKCkpIHtcbiAgICBkZWJ1ZygndW5jYXVnaHQoKTogUnVubmFibGUgaGFzIGFscmVhZHkgcGFzc2VkOyBiYWlsaW5nIGdyYWNlZnVsbHknKTtcbiAgICB0aGlzLmZhaWwocnVubmFibGUsIGVycik7XG4gICAgdGhpcy5hYm9ydCgpO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCd1bmNhdWdodCgpOiBmb3JjaW5nIFJ1bm5hYmxlIHRvIGNvbXBsZXRlIHdpdGggRXJyb3InKTtcbiAgICByZXR1cm4gcnVubmFibGUuY2FsbGJhY2soZXJyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSdW4gdGhlIHJvb3Qgc3VpdGUgYW5kIGludm9rZSBgZm4oZmFpbHVyZXMpYFxuICogb24gY29tcGxldGlvbi5cbiAqXG4gKiBAcHVibGljXG4gKiBAbWVtYmVyb2YgUnVubmVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIENhbGxiYWNrIHdoZW4gZmluaXNoZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBGb3Igc3ViY2xhc3Nlc1xuICogQHBhcmFtIHtzdHJpbmdbXX0gb3B0cy5maWxlcyAtIEZpbGVzIHRvIHJ1blxuICogQHBhcmFtIHtPcHRpb25zfSBvcHRzLm9wdGlvbnMgLSBjb21tYW5kLWxpbmUgb3B0aW9uc1xuICogQHJldHVybnMge1J1bm5lcn0gUnVubmVyIGluc3RhbmNlLlxuICovXG5SdW5uZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChmbiwgb3B0cyA9IHt9KSB7XG4gIHZhciByb290U3VpdGUgPSB0aGlzLnN1aXRlO1xuICB2YXIgb3B0aW9ucyA9IG9wdHMub3B0aW9ucyB8fCB7fTtcblxuICBkZWJ1ZygncnVuKCk6IGdvdCBvcHRpb25zOiAlTycsIG9wdGlvbnMpO1xuICBmbiA9IGZuIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGNvbnN0IGVuZCA9ICgpID0+IHtcbiAgICBpZiAoIXRoaXMudG90YWwgJiYgdGhpcy5fb3B0cy5mYWlsWmVybykgdGhpcy5mYWlsdXJlcyA9IDE7XG5cbiAgICBkZWJ1ZygncnVuKCk6IHJvb3Qgc3VpdGUgY29tcGxldGVkOyBlbWl0dGluZyAlcycsIGNvbnN0YW50cy5FVkVOVF9SVU5fRU5EKTtcbiAgICB0aGlzLmVtaXQoY29uc3RhbnRzLkVWRU5UX1JVTl9FTkQpO1xuICB9O1xuXG4gIGNvbnN0IGJlZ2luID0gKCkgPT4ge1xuICAgIGRlYnVnKCdydW4oKTogZW1pdHRpbmcgJXMnLCBjb25zdGFudHMuRVZFTlRfUlVOX0JFR0lOKTtcbiAgICB0aGlzLmVtaXQoY29uc3RhbnRzLkVWRU5UX1JVTl9CRUdJTik7XG4gICAgZGVidWcoJ3J1bigpOiBlbWl0dGVkICVzJywgY29uc3RhbnRzLkVWRU5UX1JVTl9CRUdJTik7XG5cbiAgICB0aGlzLnJ1blN1aXRlKHJvb3RTdWl0ZSwgZW5kKTtcbiAgfTtcblxuICBjb25zdCBwcmVwYXJlID0gKCkgPT4ge1xuICAgIGRlYnVnKCdydW4oKTogc3RhcnRpbmcnKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBgb25seWAgZmlsdGVyXG4gICAgaWYgKHJvb3RTdWl0ZS5oYXNPbmx5KCkpIHtcbiAgICAgIHJvb3RTdWl0ZS5maWx0ZXJPbmx5KCk7XG4gICAgICBkZWJ1ZygncnVuKCk6IGZpbHRlcmVkIGV4Y2x1c2l2ZSBSdW5uYWJsZXMnKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IGNvbnN0YW50cy5TVEFURV9SVU5OSU5HO1xuICAgIGlmICh0aGlzLl9vcHRzLmRlbGF5KSB7XG4gICAgICB0aGlzLmVtaXQoY29uc3RhbnRzLkVWRU5UX0RFTEFZX0VORCk7XG4gICAgICBkZWJ1ZygncnVuKCk6IFwiZGVsYXlcIiBlbmRlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBiZWdpbigpO1xuICB9O1xuXG4gIC8vIHJlZmVyZW5jZXMgY2xlYW51cCB0byBhdm9pZCBtZW1vcnkgbGVha3NcbiAgaWYgKHRoaXMuX29wdHMuY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW4pIHtcbiAgICB0aGlzLm9uKGNvbnN0YW50cy5FVkVOVF9TVUlURV9FTkQsIHN1aXRlID0+IHtcbiAgICAgIHN1aXRlLmNsZWFuUmVmZXJlbmNlcygpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gY2FsbGJhY2tcbiAgdGhpcy5vbihjb25zdGFudHMuRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3RhdGUgPSBjb25zdGFudHMuU1RBVEVfU1RPUFBFRDtcbiAgICBkZWJ1ZygncnVuKCk6IGVtaXR0ZWQgJXMnLCBjb25zdGFudHMuRVZFTlRfUlVOX0VORCk7XG4gICAgZm4odGhpcy5mYWlsdXJlcyk7XG4gIH0pO1xuXG4gIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXIocHJvY2VzcywgJ3VuY2F1Z2h0RXhjZXB0aW9uJywgdGhpcy51bmNhdWdodCk7XG4gIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXIocHJvY2VzcywgJ3VuaGFuZGxlZFJlamVjdGlvbicsIHRoaXMudW5oYW5kbGVkKTtcbiAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcihwcm9jZXNzLCAndW5jYXVnaHRFeGNlcHRpb24nLCB0aGlzLnVuY2F1Z2h0KTtcbiAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcihwcm9jZXNzLCAndW5oYW5kbGVkUmVqZWN0aW9uJywgdGhpcy51bmhhbmRsZWQpO1xuXG4gIGlmICh0aGlzLl9vcHRzLmRlbGF5KSB7XG4gICAgLy8gZm9yIHJlcG9ydGVycywgSSBndWVzcy5cbiAgICAvLyBtaWdodCBiZSBuaWNlIHRvIGRlYm91bmNlIHNvbWUgZG90cyB3aGlsZSB3ZSB3YWl0LlxuICAgIHRoaXMuZW1pdChjb25zdGFudHMuRVZFTlRfREVMQVlfQkVHSU4sIHJvb3RTdWl0ZSk7XG4gICAgcm9vdFN1aXRlLm9uY2UoRVZFTlRfUk9PVF9TVUlURV9SVU4sIHByZXBhcmUpO1xuICAgIGRlYnVnKCdydW4oKTogd2FpdGluZyBmb3IgZ3JlZW4gbGlnaHQgZHVlIHRvIC0tZGVsYXknKTtcbiAgfSBlbHNlIHtcbiAgICBSdW5uZXIuaW1tZWRpYXRlbHkocHJlcGFyZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVG9nZ2xlIHBhcnRpYWwgb2JqZWN0IGxpbmtpbmcgYmVoYXZpb3I7IHVzZWQgZm9yIGJ1aWxkaW5nIG9iamVjdCByZWZlcmVuY2VzIGZyb21cbiAqIHVuaXF1ZSBJRCdzLiBEb2VzIG5vdGhpbmcgaW4gc2VyaWFsIG1vZGUsIGJlY2F1c2UgdGhlIG9iamVjdCByZWZlcmVuY2VzIGFscmVhZHkgZXhpc3QuXG4gKiBTdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnQgdGhpcyAoZS5nLiwgYFBhcmFsbGVsQnVmZmVyZWRSdW5uZXJgKVxuICogQGFic3RyYWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZV0gLSBJZiBgdHJ1ZWAsIGVuYWJsZSBwYXJ0aWFsIG9iamVjdCBsaW5raW5nLCBvdGhlcndpc2UgZGlzYWJsZVxuICogQHJldHVybnMge1J1bm5lcn1cbiAqIEBjaGFpbmFibGVcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiAvLyB0aGlzIHJlcG9ydGVyIG5lZWRzIHByb3BlciBvYmplY3QgcmVmZXJlbmNlcyB3aGVuIHJ1biBpbiBwYXJhbGxlbCBtb2RlXG4gKiBjbGFzcyBNeVJlcG9ydGVyKCkge1xuICogICBjb25zdHJ1Y3RvcihydW5uZXIpIHtcbiAqICAgICB0aGlzLnJ1bm5lci5saW5rUGFydGlhbE9iamVjdHModHJ1ZSlcbiAqICAgICAgIC5vbihFVkVOVF9TVUlURV9CRUdJTiwgc3VpdGUgPT4ge1xuICAgICAgICAgICAvLyB0aGlzIFN1aXRlIG1heSBiZSB0aGUgc2FtZSBvYmplY3QuLi5cbiAqICAgICAgIH0pXG4gKiAgICAgICAub24oRVZFTlRfVEVTVF9CRUdJTiwgdGVzdCA9PiB7XG4gKiAgICAgICAgIC8vIC4uLmFzIHRoZSBgdGVzdC5wYXJlbnRgIHByb3BlcnR5XG4gKiAgICAgICB9KTtcbiAqICAgfVxuICogfVxuICovXG5SdW5uZXIucHJvdG90eXBlLmxpbmtQYXJ0aWFsT2JqZWN0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qXG4gKiBMaWtlIHtAbGluayBSdW5uZXIjcnVufSwgYnV0IGRvZXMgbm90IGFjY2VwdCBhIGNhbGxiYWNrIGFuZCByZXR1cm5zIGEgYFByb21pc2VgIGluc3RlYWQgb2YgYSBgUnVubmVyYC5cbiAqIFRoaXMgZnVuY3Rpb24gY2Fubm90IHJlamVjdDsgYW4gYHVuaGFuZGxlZFJlamVjdGlvbmAgZXZlbnQgd2lsbCBidWJibGUgdXAgdG8gdGhlIGBwcm9jZXNzYCBvYmplY3QgaW5zdGVhZC5cbiAqIEBwdWJsaWNcbiAqIEBtZW1iZXJvZiBSdW5uZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBPcHRpb25zIGZvciB7QGxpbmsgUnVubmVyI3J1bn1cbiAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59IEZhaWx1cmUgY291bnRcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5ydW5Bc3luYyA9IGFzeW5jIGZ1bmN0aW9uIHJ1bkFzeW5jKG9wdHMgPSB7fSkge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgdGhpcy5ydW4ocmVzb2x2ZSwgb3B0cyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDbGVhbmx5IGFib3J0IGV4ZWN1dGlvbi5cbiAqXG4gKiBAbWVtYmVyb2YgUnVubmVyXG4gKiBAcHVibGljXG4gKiBAcmV0dXJuIHtSdW5uZXJ9IFJ1bm5lciBpbnN0YW5jZS5cbiAqL1xuUnVubmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2Fib3J0KCk6IGFib3J0aW5nJyk7XG4gIHRoaXMuX2Fib3J0ID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgTW9jaGEgaXMgcnVubmluZyBpbiBwYXJhbGxlbCBtb2RlLiAgRm9yIHJlcG9ydGVycy5cbiAqXG4gKiBTdWJjbGFzc2VzIHNob3VsZCByZXR1cm4gYW4gYXBwcm9wcmlhdGUgdmFsdWUuXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyB7ZmFsc2V9XG4gKi9cblJ1bm5lci5wcm90b3R5cGUuaXNQYXJhbGxlbE1vZGUgPSBmdW5jdGlvbiBpc1BhcmFsbGVsTW9kZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDb25maWd1cmVzIGFuIGFsdGVybmF0ZSByZXBvcnRlciBmb3Igd29ya2VyIHByb2Nlc3NlcyB0byB1c2UuIFN1YmNsYXNzZXNcbiAqIHVzaW5nIHdvcmtlciBwcm9jZXNzZXMgc2hvdWxkIGltcGxlbWVudCB0aGlzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBBYnNvbHV0ZSBwYXRoIHRvIGFsdGVybmF0ZSByZXBvcnRlciBmb3Igd29ya2VyIHByb2Nlc3NlcyB0byB1c2VcbiAqIEByZXR1cm5zIHtSdW5uZXJ9XG4gKiBAdGhyb3dzIFdoZW4gaW4gc2VyaWFsIG1vZGVcbiAqIEBjaGFpbmFibGVcbiAqIEBhYnN0cmFjdFxuICovXG5SdW5uZXIucHJvdG90eXBlLndvcmtlclJlcG9ydGVyID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBjcmVhdGVVbnN1cHBvcnRlZEVycm9yKCd3b3JrZXJSZXBvcnRlcigpIG5vdCBzdXBwb3J0ZWQgaW4gc2VyaWFsIG1vZGUnKTtcbn07XG5cbi8qKlxuICogRmlsdGVyIGxlYWtzIHdpdGggdGhlIGdpdmVuIGdsb2JhbHMgZmxhZ2dlZCBhcyBgb2tgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBva1xuICogQHBhcmFtIHtBcnJheX0gZ2xvYmFsc1xuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGZpbHRlckxlYWtzKG9rLCBnbG9iYWxzKSB7XG4gIHJldHVybiBnbG9iYWxzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgLy8gRmlyZWZveCBhbmQgQ2hyb21lIGV4cG9zZXMgaWZyYW1lcyBhcyBpbmRleCBpbnNpZGUgdGhlIHdpbmRvdyBvYmplY3RcbiAgICBpZiAoL15cXGQrLy50ZXN0KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBpbiBmaXJlZm94XG4gICAgLy8gaWYgcnVubmVyIHJ1bnMgaW4gYW4gaWZyYW1lLCB0aGlzIGlmcmFtZSdzIHdpbmRvdy5nZXRJbnRlcmZhY2UgbWV0aG9kXG4gICAgLy8gbm90IGluaXQgYXQgZmlyc3QgaXQgaXMgYXNzaWduZWQgaW4gc29tZSBzZWNvbmRzXG4gICAgaWYgKGdsb2JhbC5uYXZpZ2F0b3IgJiYgL15nZXRJbnRlcmZhY2UvLnRlc3Qoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGFuIGlmcmFtZSBjb3VsZCBiZSBhcHByb2FjaGVkIGJ5IHdpbmRvd1tpZnJhbWVJbmRleF1cbiAgICAvLyBpbiBpZTYsNyw4IGFuZCBvcGVyYSwgaWZyYW1lSW5kZXggaXMgZW51bWVyYWJsZSwgdGhpcyBjb3VsZCBjYXVzZSBsZWFrXG4gICAgaWYgKGdsb2JhbC5uYXZpZ2F0b3IgJiYgL15cXGQrLy50ZXN0KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBPcGVyYSBhbmQgSUUgZXhwb3NlIGdsb2JhbCB2YXJpYWJsZXMgZm9yIEhUTUwgZWxlbWVudCBJRHMgKGlzc3VlICMyNDMpXG4gICAgaWYgKC9ebW9jaGEtLy50ZXN0KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlZCA9IG9rLmZpbHRlcihmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICh+b2suaW5kZXhPZignKicpKSB7XG4gICAgICAgIHJldHVybiBrZXkuaW5kZXhPZihvay5zcGxpdCgnKicpWzBdKSA9PT0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXkgPT09IG9rO1xuICAgIH0pO1xuICAgIHJldHVybiAhbWF0Y2hlZC5sZW5ndGggJiYgKCFnbG9iYWwubmF2aWdhdG9yIHx8IGtleSAhPT0gJ29uZXJyb3InKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYXJndW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgRXJyb3Igb2JqZWN0IG9yIGEgZHVjay10eXBlZCBlcXVpdmFsZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZXJyIC0gb2JqZWN0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gZXJyLm1lc3NhZ2UgLSBlcnJvciBtZXNzYWdlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFcnJvcihlcnIpIHtcbiAgcmV0dXJuIGVyciBpbnN0YW5jZW9mIEVycm9yIHx8IChlcnIgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJyk7XG59XG5cbi8qKlxuICpcbiAqIENvbnZlcnRzIHRocm93biBub24tZXh0ZW5zaWJsZSB0eXBlIGludG8gcHJvcGVyIEVycm9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHRocm93biAtIE5vbi1leHRlbnNpYmxlIHR5cGUgdGhyb3duIGJ5IGNvZGVcbiAqIEByZXR1cm4ge0Vycm9yfVxuICovXG5mdW5jdGlvbiB0aHJvd24yRXJyb3IoZXJyKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoXG4gICAgYHRoZSAke3V0aWxzLmNhbm9uaWNhbFR5cGUoZXJyKX0gJHtzdHJpbmdpZnkoXG4gICAgICBlcnJcbiAgICApfSB3YXMgdGhyb3duLCB0aHJvdyBhbiBFcnJvciA6KWBcbiAgKTtcbn1cblxuUnVubmVyLmNvbnN0YW50cyA9IGNvbnN0YW50cztcblxuLyoqXG4gKiBOb2RlLmpzJyBgRXZlbnRFbWl0dGVyYFxuICogQGV4dGVybmFsIEV2ZW50RW1pdHRlclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNldmVudHNfY2xhc3NfZXZlbnRlbWl0dGVyfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUnVubmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgYSB7QGxpbmsgU3RhdHNDb2xsZWN0b3J9IG9iamVjdC5cbiAqIEBtb2R1bGVcbiAqL1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9ydW5uZXInKS5jb25zdGFudHM7XG52YXIgRVZFTlRfVEVTVF9QQVNTID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEFTUztcbnZhciBFVkVOVF9URVNUX0ZBSUwgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9GQUlMO1xudmFyIEVWRU5UX1NVSVRFX0JFR0lOID0gY29uc3RhbnRzLkVWRU5UX1NVSVRFX0JFR0lOO1xudmFyIEVWRU5UX1JVTl9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9SVU5fQkVHSU47XG52YXIgRVZFTlRfVEVTVF9QRU5ESU5HID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEVORElORztcbnZhciBFVkVOVF9SVU5fRU5EID0gY29uc3RhbnRzLkVWRU5UX1JVTl9FTkQ7XG52YXIgRVZFTlRfVEVTVF9FTkQgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9FTkQ7XG5cbi8qKlxuICogVGVzdCBzdGF0aXN0aWNzIGNvbGxlY3Rvci5cbiAqXG4gKiBAcHVibGljXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdGF0c0NvbGxlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN1aXRlcyAtIGludGVnZXIgY291bnQgb2Ygc3VpdGVzIHJ1bi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0ZXN0cyAtIGludGVnZXIgY291bnQgb2YgdGVzdHMgcnVuLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBhc3NlcyAtIGludGVnZXIgY291bnQgb2YgcGFzc2luZyB0ZXN0cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwZW5kaW5nIC0gaW50ZWdlciBjb3VudCBvZiBwZW5kaW5nIHRlc3RzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZhaWx1cmVzIC0gaW50ZWdlciBjb3VudCBvZiBmYWlsZWQgdGVzdHMuXG4gKiBAcHJvcGVydHkge0RhdGV9IHN0YXJ0IC0gdGltZSB3aGVuIHRlc3RpbmcgYmVnYW4uXG4gKiBAcHJvcGVydHkge0RhdGV9IGVuZCAtIHRpbWUgd2hlbiB0ZXN0aW5nIGNvbmNsdWRlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvbiAtIG51bWJlciBvZiBtc2VjcyB0aGF0IHRlc3RpbmcgdG9vay5cbiAqL1xuXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xuXG4vKipcbiAqIFByb3ZpZGVzIHN0YXRzIHN1Y2ggYXMgdGVzdCBkdXJhdGlvbiwgbnVtYmVyIG9mIHRlc3RzIHBhc3NlZCAvIGZhaWxlZCBldGMuLCBieSBsaXN0ZW5pbmcgZm9yIGV2ZW50cyBlbWl0dGVkIGJ5IGBydW5uZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyIC0gUnVubmVyIGluc3RhbmNlXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGZhbHN5IGBydW5uZXJgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRzQ29sbGVjdG9yKHJ1bm5lcikge1xuICAvKipcbiAgICogQHR5cGUgU3RhdHNDb2xsZWN0b3JcbiAgICovXG4gIHZhciBzdGF0cyA9IHtcbiAgICBzdWl0ZXM6IDAsXG4gICAgdGVzdHM6IDAsXG4gICAgcGFzc2VzOiAwLFxuICAgIHBlbmRpbmc6IDAsXG4gICAgZmFpbHVyZXM6IDBcbiAgfTtcblxuICBpZiAoIXJ1bm5lcikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgcnVubmVyIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBydW5uZXIuc3RhdHMgPSBzdGF0cztcblxuICBydW5uZXIub25jZShFVkVOVF9SVU5fQkVHSU4sIGZ1bmN0aW9uICgpIHtcbiAgICBzdGF0cy5zdGFydCA9IG5ldyBEYXRlKCk7XG4gIH0pO1xuICBydW5uZXIub24oRVZFTlRfU1VJVEVfQkVHSU4sIGZ1bmN0aW9uIChzdWl0ZSkge1xuICAgIHN1aXRlLnJvb3QgfHwgc3RhdHMuc3VpdGVzKys7XG4gIH0pO1xuICBydW5uZXIub24oRVZFTlRfVEVTVF9QQVNTLCBmdW5jdGlvbiAoKSB7XG4gICAgc3RhdHMucGFzc2VzKys7XG4gIH0pO1xuICBydW5uZXIub24oRVZFTlRfVEVTVF9GQUlMLCBmdW5jdGlvbiAoKSB7XG4gICAgc3RhdHMuZmFpbHVyZXMrKztcbiAgfSk7XG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BFTkRJTkcsIGZ1bmN0aW9uICgpIHtcbiAgICBzdGF0cy5wZW5kaW5nKys7XG4gIH0pO1xuICBydW5uZXIub24oRVZFTlRfVEVTVF9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICBzdGF0cy50ZXN0cysrO1xuICB9KTtcbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIHN0YXRzLmVuZCA9IG5ldyBEYXRlKCk7XG4gICAgc3RhdHMuZHVyYXRpb24gPSBzdGF0cy5lbmQgLSBzdGF0cy5zdGFydDtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU3RhdHNDb2xsZWN0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHtFdmVudEVtaXR0ZXJ9ID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBIb29rID0gcmVxdWlyZSgnLi9ob29rJyk7XG52YXIge1xuICBhc3NpZ25OZXdNb2NoYUlELFxuICBjbGFtcCxcbiAgY29uc3RhbnRzOiB1dGlsc0NvbnN0YW50cyxcbiAgZGVmaW5lQ29uc3RhbnRzLFxuICBnZXRNb2NoYUlELFxuICBpbmhlcml0cyxcbiAgaXNTdHJpbmdcbn0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21vY2hhOnN1aXRlJyk7XG5jb25zdCBtaWxsaXNlY29uZHMgPSByZXF1aXJlKCdtcycpO1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxuY29uc3Qge01PQ0hBX0lEX1BST1BfTkFNRX0gPSB1dGlsc0NvbnN0YW50cztcblxuLyoqXG4gKiBFeHBvc2UgYFN1aXRlYC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBTdWl0ZTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYFN1aXRlYCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBwYXJlbnQgYFN1aXRlYC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge1N1aXRlfSBwYXJlbnQgLSBQYXJlbnQgc3VpdGUgKHJlcXVpcmVkISlcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZSAtIFRpdGxlXG4gKiBAcmV0dXJuIHtTdWl0ZX1cbiAqL1xuU3VpdGUuY3JlYXRlID0gZnVuY3Rpb24gKHBhcmVudCwgdGl0bGUpIHtcbiAgdmFyIHN1aXRlID0gbmV3IFN1aXRlKHRpdGxlLCBwYXJlbnQuY3R4KTtcbiAgc3VpdGUucGFyZW50ID0gcGFyZW50O1xuICB0aXRsZSA9IHN1aXRlLmZ1bGxUaXRsZSgpO1xuICBwYXJlbnQuYWRkU3VpdGUoc3VpdGUpO1xuICByZXR1cm4gc3VpdGU7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYFN1aXRlYCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgLCBgY3R4YCwgYW5kIGBpc1Jvb3RgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAc2VlIHtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2V2ZW50c19jbGFzc19ldmVudGVtaXR0ZXJ8RXZlbnRFbWl0dGVyfVxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlIC0gU3VpdGUgdGl0bGUuXG4gKiBAcGFyYW0ge0NvbnRleHR9IHBhcmVudENvbnRleHQgLSBQYXJlbnQgY29udGV4dCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzUm9vdD1mYWxzZV0gLSBXaGV0aGVyIHRoaXMgaXMgdGhlIHJvb3Qgc3VpdGUuXG4gKi9cbmZ1bmN0aW9uIFN1aXRlKHRpdGxlLCBwYXJlbnRDb250ZXh0LCBpc1Jvb3QpIHtcbiAgaWYgKCFpc1N0cmluZyh0aXRsZSkpIHtcbiAgICB0aHJvdyBlcnJvcnMuY3JlYXRlSW52YWxpZEFyZ3VtZW50VHlwZUVycm9yKFxuICAgICAgJ1N1aXRlIGFyZ3VtZW50IFwidGl0bGVcIiBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIFwiJyArXG4gICAgICAgIHR5cGVvZiB0aXRsZSArXG4gICAgICAgICdcIicsXG4gICAgICAndGl0bGUnLFxuICAgICAgJ3N0cmluZydcbiAgICApO1xuICB9XG4gIHRoaXMudGl0bGUgPSB0aXRsZTtcbiAgZnVuY3Rpb24gQ29udGV4dCgpIHt9XG4gIENvbnRleHQucHJvdG90eXBlID0gcGFyZW50Q29udGV4dDtcbiAgdGhpcy5jdHggPSBuZXcgQ29udGV4dCgpO1xuICB0aGlzLnN1aXRlcyA9IFtdO1xuICB0aGlzLnRlc3RzID0gW107XG4gIHRoaXMucm9vdCA9IGlzUm9vdCA9PT0gdHJ1ZTtcbiAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gIHRoaXMuX3JldHJpZXMgPSAtMTtcbiAgdGhpcy5fYmVmb3JlRWFjaCA9IFtdO1xuICB0aGlzLl9iZWZvcmVBbGwgPSBbXTtcbiAgdGhpcy5fYWZ0ZXJFYWNoID0gW107XG4gIHRoaXMuX2FmdGVyQWxsID0gW107XG4gIHRoaXMuX3RpbWVvdXQgPSAyMDAwO1xuICB0aGlzLl9zbG93ID0gNzU7XG4gIHRoaXMuX2JhaWwgPSBmYWxzZTtcbiAgdGhpcy5fb25seVRlc3RzID0gW107XG4gIHRoaXMuX29ubHlTdWl0ZXMgPSBbXTtcbiAgYXNzaWduTmV3TW9jaGFJRCh0aGlzKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBnZXRNb2NoYUlEKHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5yZXNldCgpO1xufVxuXG4vKipcbiAqIEluaGVyaXQgZnJvbSBgRXZlbnRFbWl0dGVyLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKFN1aXRlLCBFdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIFJlc2V0cyB0aGUgc3RhdGUgaW5pdGlhbGx5IG9yIGZvciBhIG5leHQgcnVuLlxuICovXG5TdWl0ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZGVsYXllZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkb1Jlc2V0KHRoaW5nVG9SZXNldCkge1xuICAgIHRoaW5nVG9SZXNldC5yZXNldCgpO1xuICB9XG4gIHRoaXMuc3VpdGVzLmZvckVhY2goZG9SZXNldCk7XG4gIHRoaXMudGVzdHMuZm9yRWFjaChkb1Jlc2V0KTtcbiAgdGhpcy5fYmVmb3JlRWFjaC5mb3JFYWNoKGRvUmVzZXQpO1xuICB0aGlzLl9hZnRlckVhY2guZm9yRWFjaChkb1Jlc2V0KTtcbiAgdGhpcy5fYmVmb3JlQWxsLmZvckVhY2goZG9SZXNldCk7XG4gIHRoaXMuX2FmdGVyQWxsLmZvckVhY2goZG9SZXNldCk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGNsb25lIG9mIHRoaXMgYFN1aXRlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7U3VpdGV9XG4gKi9cblN1aXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN1aXRlID0gbmV3IFN1aXRlKHRoaXMudGl0bGUpO1xuICBkZWJ1ZygnY2xvbmUnKTtcbiAgc3VpdGUuY3R4ID0gdGhpcy5jdHg7XG4gIHN1aXRlLnJvb3QgPSB0aGlzLnJvb3Q7XG4gIHN1aXRlLnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xuICBzdWl0ZS5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcbiAgc3VpdGUuc2xvdyh0aGlzLnNsb3coKSk7XG4gIHN1aXRlLmJhaWwodGhpcy5iYWlsKCkpO1xuICByZXR1cm4gc3VpdGU7XG59O1xuXG4vKipcbiAqIFNldCBvciBnZXQgdGltZW91dCBgbXNgIG9yIHNob3J0LWhhbmQgc3VjaCBhcyBcIjJzXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0b2RvIERvIG5vdCBhdHRlbXB0IHRvIHNldCB2YWx1ZSBpZiBgbXNgIGlzIHVuZGVmaW5lZFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtc1xuICogQHJldHVybiB7U3VpdGV8bnVtYmVyfSBmb3IgY2hhaW5pbmdcbiAqL1xuU3VpdGUucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBtcyA9PT0gJ3N0cmluZycpIHtcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XG4gIH1cblxuICAvLyBDbGFtcCB0byByYW5nZVxuICB2YXIgSU5UX01BWCA9IE1hdGgucG93KDIsIDMxKSAtIDE7XG4gIHZhciByYW5nZSA9IFswLCBJTlRfTUFYXTtcbiAgbXMgPSBjbGFtcChtcywgcmFuZ2UpO1xuXG4gIGRlYnVnKCd0aW1lb3V0ICVkJywgbXMpO1xuICB0aGlzLl90aW1lb3V0ID0gcGFyc2VJbnQobXMsIDEwKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBvciBnZXQgbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IGEgZmFpbGVkIHRlc3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gblxuICogQHJldHVybiB7U3VpdGV8bnVtYmVyfSBmb3IgY2hhaW5pbmdcbiAqL1xuU3VpdGUucHJvdG90eXBlLnJldHJpZXMgPSBmdW5jdGlvbiAobikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmV0cmllcztcbiAgfVxuICBkZWJ1ZygncmV0cmllcyAlZCcsIG4pO1xuICB0aGlzLl9yZXRyaWVzID0gcGFyc2VJbnQobiwgMTApIHx8IDA7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgb3IgZ2V0IHNsb3cgYG1zYCBvciBzaG9ydC1oYW5kIHN1Y2ggYXMgXCIyc1wiLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG1zXG4gKiBAcmV0dXJuIHtTdWl0ZXxudW1iZXJ9IGZvciBjaGFpbmluZ1xuICovXG5TdWl0ZS5wcm90b3R5cGUuc2xvdyA9IGZ1bmN0aW9uIChtcykge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2xvdztcbiAgfVxuICBpZiAodHlwZW9mIG1zID09PSAnc3RyaW5nJykge1xuICAgIG1zID0gbWlsbGlzZWNvbmRzKG1zKTtcbiAgfVxuICBkZWJ1Zygnc2xvdyAlZCcsIG1zKTtcbiAgdGhpcy5fc2xvdyA9IG1zO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IG9yIGdldCB3aGV0aGVyIHRvIGJhaWwgYWZ0ZXIgZmlyc3QgZXJyb3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYmFpbFxuICogQHJldHVybiB7U3VpdGV8bnVtYmVyfSBmb3IgY2hhaW5pbmdcbiAqL1xuU3VpdGUucHJvdG90eXBlLmJhaWwgPSBmdW5jdGlvbiAoYmFpbCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFpbDtcbiAgfVxuICBkZWJ1ZygnYmFpbCAlcycsIGJhaWwpO1xuICB0aGlzLl9iYWlsID0gYmFpbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgc3VpdGUgb3IgaXRzIHBhcmVudCBzdWl0ZSBpcyBtYXJrZWQgYXMgcGVuZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5TdWl0ZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wZW5kaW5nIHx8ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5pc1BlbmRpbmcoKSk7XG59O1xuXG4vKipcbiAqIEdlbmVyaWMgaG9vay1jcmVhdG9yLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZSAtIFRpdGxlIG9mIGhvb2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gSG9vayBjYWxsYmFja1xuICogQHJldHVybnMge0hvb2t9IEEgbmV3IGhvb2tcbiAqL1xuU3VpdGUucHJvdG90eXBlLl9jcmVhdGVIb29rID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICB2YXIgaG9vayA9IG5ldyBIb29rKHRpdGxlLCBmbik7XG4gIGhvb2sucGFyZW50ID0gdGhpcztcbiAgaG9vay50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcbiAgaG9vay5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcbiAgaG9vay5zbG93KHRoaXMuc2xvdygpKTtcbiAgaG9vay5jdHggPSB0aGlzLmN0eDtcbiAgaG9vay5maWxlID0gdGhpcy5maWxlO1xuICByZXR1cm4gaG9vaztcbn07XG5cbi8qKlxuICogUnVuIGBmbih0ZXN0WywgZG9uZV0pYCBiZWZvcmUgcnVubmluZyB0ZXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xuICovXG5TdWl0ZS5wcm90b3R5cGUuYmVmb3JlQWxsID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IHRpdGxlO1xuICAgIHRpdGxlID0gZm4ubmFtZTtcbiAgfVxuICB0aXRsZSA9ICdcImJlZm9yZSBhbGxcIiBob29rJyArICh0aXRsZSA/ICc6ICcgKyB0aXRsZSA6ICcnKTtcblxuICB2YXIgaG9vayA9IHRoaXMuX2NyZWF0ZUhvb2sodGl0bGUsIGZuKTtcbiAgdGhpcy5fYmVmb3JlQWxsLnB1c2goaG9vayk7XG4gIHRoaXMuZW1pdChjb25zdGFudHMuRVZFTlRfU1VJVEVfQUREX0hPT0tfQkVGT1JFX0FMTCwgaG9vayk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSdW4gYGZuKHRlc3RbLCBkb25lXSlgIGFmdGVyIHJ1bm5pbmcgdGVzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcbiAqL1xuU3VpdGUucHJvdG90eXBlLmFmdGVyQWxsID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IHRpdGxlO1xuICAgIHRpdGxlID0gZm4ubmFtZTtcbiAgfVxuICB0aXRsZSA9ICdcImFmdGVyIGFsbFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xuXG4gIHZhciBob29rID0gdGhpcy5fY3JlYXRlSG9vayh0aXRsZSwgZm4pO1xuICB0aGlzLl9hZnRlckFsbC5wdXNoKGhvb2spO1xuICB0aGlzLmVtaXQoY29uc3RhbnRzLkVWRU5UX1NVSVRFX0FERF9IT09LX0FGVEVSX0FMTCwgaG9vayk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSdW4gYGZuKHRlc3RbLCBkb25lXSlgIGJlZm9yZSBlYWNoIHRlc3QgY2FzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xuICovXG5TdWl0ZS5wcm90b3R5cGUuYmVmb3JlRWFjaCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcbiAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpZiAodHlwZW9mIHRpdGxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSB0aXRsZTtcbiAgICB0aXRsZSA9IGZuLm5hbWU7XG4gIH1cbiAgdGl0bGUgPSAnXCJiZWZvcmUgZWFjaFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xuXG4gIHZhciBob29rID0gdGhpcy5fY3JlYXRlSG9vayh0aXRsZSwgZm4pO1xuICB0aGlzLl9iZWZvcmVFYWNoLnB1c2goaG9vayk7XG4gIHRoaXMuZW1pdChjb25zdGFudHMuRVZFTlRfU1VJVEVfQUREX0hPT0tfQkVGT1JFX0VBQ0gsIGhvb2spO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUnVuIGBmbih0ZXN0WywgZG9uZV0pYCBhZnRlciBlYWNoIHRlc3QgY2FzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xuICovXG5TdWl0ZS5wcm90b3R5cGUuYWZ0ZXJFYWNoID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IHRpdGxlO1xuICAgIHRpdGxlID0gZm4ubmFtZTtcbiAgfVxuICB0aXRsZSA9ICdcImFmdGVyIGVhY2hcIiBob29rJyArICh0aXRsZSA/ICc6ICcgKyB0aXRsZSA6ICcnKTtcblxuICB2YXIgaG9vayA9IHRoaXMuX2NyZWF0ZUhvb2sodGl0bGUsIGZuKTtcbiAgdGhpcy5fYWZ0ZXJFYWNoLnB1c2goaG9vayk7XG4gIHRoaXMuZW1pdChjb25zdGFudHMuRVZFTlRfU1VJVEVfQUREX0hPT0tfQUZURVJfRUFDSCwgaG9vayk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYSB0ZXN0IGBzdWl0ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXG4gKi9cblN1aXRlLnByb3RvdHlwZS5hZGRTdWl0ZSA9IGZ1bmN0aW9uIChzdWl0ZSkge1xuICBzdWl0ZS5wYXJlbnQgPSB0aGlzO1xuICBzdWl0ZS5yb290ID0gZmFsc2U7XG4gIHN1aXRlLnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xuICBzdWl0ZS5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcbiAgc3VpdGUuc2xvdyh0aGlzLnNsb3coKSk7XG4gIHN1aXRlLmJhaWwodGhpcy5iYWlsKCkpO1xuICB0aGlzLnN1aXRlcy5wdXNoKHN1aXRlKTtcbiAgdGhpcy5lbWl0KGNvbnN0YW50cy5FVkVOVF9TVUlURV9BRERfU1VJVEUsIHN1aXRlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIGB0ZXN0YCB0byB0aGlzIHN1aXRlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1Rlc3R9IHRlc3RcbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcbiAqL1xuU3VpdGUucHJvdG90eXBlLmFkZFRlc3QgPSBmdW5jdGlvbiAodGVzdCkge1xuICB0ZXN0LnBhcmVudCA9IHRoaXM7XG4gIHRlc3QudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XG4gIHRlc3QucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XG4gIHRlc3Quc2xvdyh0aGlzLnNsb3coKSk7XG4gIHRlc3QuY3R4ID0gdGhpcy5jdHg7XG4gIHRoaXMudGVzdHMucHVzaCh0ZXN0KTtcbiAgdGhpcy5lbWl0KGNvbnN0YW50cy5FVkVOVF9TVUlURV9BRERfVEVTVCwgdGVzdCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGZ1bGwgdGl0bGUgZ2VuZXJhdGVkIGJ5IHJlY3Vyc2l2ZWx5IGNvbmNhdGVuYXRpbmcgdGhlIHBhcmVudCdzXG4gKiBmdWxsIHRpdGxlLlxuICpcbiAqIEBtZW1iZXJvZiBTdWl0ZVxuICogQHB1YmxpY1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5TdWl0ZS5wcm90b3R5cGUuZnVsbFRpdGxlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy50aXRsZVBhdGgoKS5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgdGl0bGUgcGF0aCBnZW5lcmF0ZWQgYnkgcmVjdXJzaXZlbHkgY29uY2F0ZW5hdGluZyB0aGUgcGFyZW50J3NcbiAqIHRpdGxlIHBhdGguXG4gKlxuICogQG1lbWJlcm9mIFN1aXRlXG4gKiBAcHVibGljXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblN1aXRlLnByb3RvdHlwZS50aXRsZVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLnBhcmVudC50aXRsZVBhdGgoKSk7XG4gIH1cbiAgaWYgKCF0aGlzLnJvb3QpIHtcbiAgICByZXN1bHQucHVzaCh0aGlzLnRpdGxlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHRvdGFsIG51bWJlciBvZiB0ZXN0cy5cbiAqXG4gKiBAbWVtYmVyb2YgU3VpdGVcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuU3VpdGUucHJvdG90eXBlLnRvdGFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKFxuICAgIHRoaXMuc3VpdGVzLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBzdWl0ZSkge1xuICAgICAgcmV0dXJuIHN1bSArIHN1aXRlLnRvdGFsKCk7XG4gICAgfSwgMCkgKyB0aGlzLnRlc3RzLmxlbmd0aFxuICApO1xufTtcblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGVhY2ggc3VpdGUgcmVjdXJzaXZlbHkgdG8gZmluZCBhbGwgdGVzdHMuIEFwcGxpZXMgYVxuICogZnVuY3Rpb24gaW4gdGhlIGZvcm1hdCBgZm4odGVzdClgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7U3VpdGV9XG4gKi9cblN1aXRlLnByb3RvdHlwZS5lYWNoVGVzdCA9IGZ1bmN0aW9uIChmbikge1xuICB0aGlzLnRlc3RzLmZvckVhY2goZm4pO1xuICB0aGlzLnN1aXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdWl0ZSkge1xuICAgIHN1aXRlLmVhY2hUZXN0KGZuKTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUaGlzIHdpbGwgcnVuIHRoZSByb290IHN1aXRlIGlmIHdlIGhhcHBlbiB0byBiZSBydW5uaW5nIGluIGRlbGF5ZWQgbW9kZS5cbiAqIEBwcml2YXRlXG4gKi9cblN1aXRlLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4oKSB7XG4gIGlmICh0aGlzLnJvb3QpIHtcbiAgICB0aGlzLmVtaXQoY29uc3RhbnRzLkVWRU5UX1JPT1RfU1VJVEVfUlVOKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzdWl0ZSBoYXMgYW4gYG9ubHlgIHRlc3Qgb3Igc3VpdGUgYXMgYSBkZXNjZW5kYW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuU3VpdGUucHJvdG90eXBlLmhhc09ubHkgPSBmdW5jdGlvbiBoYXNPbmx5KCkge1xuICByZXR1cm4gKFxuICAgIHRoaXMuX29ubHlUZXN0cy5sZW5ndGggPiAwIHx8XG4gICAgdGhpcy5fb25seVN1aXRlcy5sZW5ndGggPiAwIHx8XG4gICAgdGhpcy5zdWl0ZXMuc29tZShmdW5jdGlvbiAoc3VpdGUpIHtcbiAgICAgIHJldHVybiBzdWl0ZS5oYXNPbmx5KCk7XG4gICAgfSlcbiAgKTtcbn07XG5cbi8qKlxuICogRmlsdGVyIHN1aXRlcyBiYXNlZCBvbiBgaXNPbmx5YCBsb2dpYy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblN1aXRlLnByb3RvdHlwZS5maWx0ZXJPbmx5ID0gZnVuY3Rpb24gZmlsdGVyT25seSgpIHtcbiAgaWYgKHRoaXMuX29ubHlUZXN0cy5sZW5ndGgpIHtcbiAgICAvLyBJZiB0aGUgc3VpdGUgY29udGFpbnMgYG9ubHlgIHRlc3RzLCBydW4gdGhvc2UgYW5kIGlnbm9yZSBhbnkgbmVzdGVkIHN1aXRlcy5cbiAgICB0aGlzLnRlc3RzID0gdGhpcy5fb25seVRlc3RzO1xuICAgIHRoaXMuc3VpdGVzID0gW107XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlLCBkbyBub3QgcnVuIGFueSBvZiB0aGUgdGVzdHMgaW4gdGhpcyBzdWl0ZS5cbiAgICB0aGlzLnRlc3RzID0gW107XG4gICAgdGhpcy5fb25seVN1aXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChvbmx5U3VpdGUpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBvdGhlciBgb25seWAgdGVzdHMvc3VpdGVzIG5lc3RlZCBpbiB0aGUgY3VycmVudCBgb25seWAgc3VpdGUsIHRoZW4gZmlsdGVyIHRoYXQgYG9ubHlgIHN1aXRlLlxuICAgICAgLy8gT3RoZXJ3aXNlLCBhbGwgb2YgdGhlIHRlc3RzIG9uIHRoaXMgYG9ubHlgIHN1aXRlIHNob3VsZCBiZSBydW4sIHNvIGRvbid0IGZpbHRlciBpdC5cbiAgICAgIGlmIChvbmx5U3VpdGUuaGFzT25seSgpKSB7XG4gICAgICAgIG9ubHlTdWl0ZS5maWx0ZXJPbmx5KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gUnVuIHRoZSBgb25seWAgc3VpdGVzLCBhcyB3ZWxsIGFzIGFueSBvdGhlciBzdWl0ZXMgdGhhdCBoYXZlIGBvbmx5YCB0ZXN0cy9zdWl0ZXMgYXMgZGVzY2VuZGFudHMuXG4gICAgdmFyIG9ubHlTdWl0ZXMgPSB0aGlzLl9vbmx5U3VpdGVzO1xuICAgIHRoaXMuc3VpdGVzID0gdGhpcy5zdWl0ZXMuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZFN1aXRlKSB7XG4gICAgICByZXR1cm4gb25seVN1aXRlcy5pbmRleE9mKGNoaWxkU3VpdGUpICE9PSAtMSB8fCBjaGlsZFN1aXRlLmZpbHRlck9ubHkoKTtcbiAgICB9KTtcbiAgfVxuICAvLyBLZWVwIHRoZSBzdWl0ZSBvbmx5IGlmIHRoZXJlIGlzIHNvbWV0aGluZyB0byBydW5cbiAgcmV0dXJuIHRoaXMudGVzdHMubGVuZ3RoID4gMCB8fCB0aGlzLnN1aXRlcy5sZW5ndGggPiAwO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgc3VpdGUgdG8gdGhlIGxpc3Qgb2Ygc3Vic3VpdGVzIG1hcmtlZCBgb25seWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXG4gKi9cblN1aXRlLnByb3RvdHlwZS5hcHBlbmRPbmx5U3VpdGUgPSBmdW5jdGlvbiAoc3VpdGUpIHtcbiAgdGhpcy5fb25seVN1aXRlcy5wdXNoKHN1aXRlKTtcbn07XG5cbi8qKlxuICogTWFya3MgYSBzdWl0ZSB0byBiZSBgb25seWAuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuU3VpdGUucHJvdG90eXBlLm1hcmtPbmx5ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5hcHBlbmRPbmx5U3VpdGUodGhpcyk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSB0ZXN0IHRvIHRoZSBsaXN0IG9mIHRlc3RzIG1hcmtlZCBgb25seWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7VGVzdH0gdGVzdFxuICovXG5TdWl0ZS5wcm90b3R5cGUuYXBwZW5kT25seVRlc3QgPSBmdW5jdGlvbiAodGVzdCkge1xuICB0aGlzLl9vbmx5VGVzdHMucHVzaCh0ZXN0KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXJyYXkgb2YgaG9va3MgYnkgaG9vayBuYW1lOyBzZWUgYEhPT0tfVFlQRV8qYCBjb25zdGFudHMuXG4gKiBAcHJpdmF0ZVxuICovXG5TdWl0ZS5wcm90b3R5cGUuZ2V0SG9va3MgPSBmdW5jdGlvbiBnZXRIb29rcyhuYW1lKSB7XG4gIHJldHVybiB0aGlzWydfJyArIG5hbWVdO1xufTtcblxuLyoqXG4gKiBjbGVhbnMgYWxsIHJlZmVyZW5jZXMgZnJvbSB0aGlzIHN1aXRlIGFuZCBhbGwgY2hpbGQgc3VpdGVzLlxuICovXG5TdWl0ZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zdWl0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc3VpdGUpIHtcbiAgICBzdWl0ZS5kaXNwb3NlKCk7XG4gIH0pO1xuICB0aGlzLmNsZWFuUmVmZXJlbmNlcygpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgdGhlIHJlZmVyZW5jZXMgdG8gYWxsIHRoZSBkZWZlcnJlZCBmdW5jdGlvbnNcbiAqIChiZWZvcmUvYWZ0ZXIvYmVmb3JlRWFjaC9hZnRlckVhY2gpIGFuZCB0ZXN0cyBvZiBhIFN1aXRlLlxuICogVGhlc2UgbXVzdCBiZSBkZWxldGVkIG90aGVyd2lzZSBhIG1lbW9yeSBsZWFrIGNhbiBoYXBwZW4sXG4gKiBhcyB0aG9zZSBmdW5jdGlvbnMgbWF5IHJlZmVyZW5jZSB2YXJpYWJsZXMgZnJvbSBjbG9zdXJlcyxcbiAqIHRodXMgdGhvc2UgdmFyaWFibGVzIGNhbiBuZXZlciBiZSBnYXJiYWdlIGNvbGxlY3RlZCBhcyBsb25nXG4gKiBhcyB0aGUgZGVmZXJyZWQgZnVuY3Rpb25zIGV4aXN0LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblN1aXRlLnByb3RvdHlwZS5jbGVhblJlZmVyZW5jZXMgPSBmdW5jdGlvbiBjbGVhblJlZmVyZW5jZXMoKSB7XG4gIGZ1bmN0aW9uIGNsZWFuQXJyUmVmZXJlbmNlcyhhcnIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgZGVsZXRlIGFycltpXS5mbjtcbiAgICB9XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl9iZWZvcmVBbGwpKSB7XG4gICAgY2xlYW5BcnJSZWZlcmVuY2VzKHRoaXMuX2JlZm9yZUFsbCk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl9iZWZvcmVFYWNoKSkge1xuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyh0aGlzLl9iZWZvcmVFYWNoKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX2FmdGVyQWxsKSkge1xuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyh0aGlzLl9hZnRlckFsbCk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl9hZnRlckVhY2gpKSB7XG4gICAgY2xlYW5BcnJSZWZlcmVuY2VzKHRoaXMuX2FmdGVyRWFjaCk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWxldGUgdGhpcy50ZXN0c1tpXS5mbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBzdWl0YWJsZSBmb3IgSVBDLlxuICogRnVuY3Rpb25zIGFyZSByZXByZXNlbnRlZCBieSBrZXlzIGJlZ2lubmluZyB3aXRoIGAkJGAuXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuU3VpdGUucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBfYmFpbDogdGhpcy5fYmFpbCxcbiAgICAkJGZ1bGxUaXRsZTogdGhpcy5mdWxsVGl0bGUoKSxcbiAgICAkJGlzUGVuZGluZzogQm9vbGVhbih0aGlzLmlzUGVuZGluZygpKSxcbiAgICByb290OiB0aGlzLnJvb3QsXG4gICAgdGl0bGU6IHRoaXMudGl0bGUsXG4gICAgW01PQ0hBX0lEX1BST1BfTkFNRV06IHRoaXMuaWQsXG4gICAgcGFyZW50OiB0aGlzLnBhcmVudCA/IHtbTU9DSEFfSURfUFJPUF9OQU1FXTogdGhpcy5wYXJlbnQuaWR9IDogbnVsbFxuICB9O1xufTtcblxudmFyIGNvbnN0YW50cyA9IGRlZmluZUNvbnN0YW50cyhcbiAgLyoqXG4gICAqIHtAbGluayBTdWl0ZX0tcmVsYXRlZCBjb25zdGFudHMuXG4gICAqIEBwdWJsaWNcbiAgICogQG1lbWJlcm9mIFN1aXRlXG4gICAqIEBhbGlhcyBjb25zdGFudHNcbiAgICogQHJlYWRvbmx5XG4gICAqIEBzdGF0aWNcbiAgICogQGVudW0ge3N0cmluZ31cbiAgICovXG4gIHtcbiAgICAvKipcbiAgICAgKiBFdmVudCBlbWl0dGVkIGFmdGVyIGEgdGVzdCBmaWxlIGhhcyBiZWVuIGxvYWRlZC4gTm90IGVtaXR0ZWQgaW4gYnJvd3Nlci5cbiAgICAgKi9cbiAgICBFVkVOVF9GSUxFX1BPU1RfUkVRVUlSRTogJ3Bvc3QtcmVxdWlyZScsXG4gICAgLyoqXG4gICAgICogRXZlbnQgZW1pdHRlZCBiZWZvcmUgYSB0ZXN0IGZpbGUgaGFzIGJlZW4gbG9hZGVkLiBJbiBicm93c2VyLCB0aGlzIGlzIGVtaXR0ZWQgb25jZSBhbiBpbnRlcmZhY2UgaGFzIGJlZW4gc2VsZWN0ZWQuXG4gICAgICovXG4gICAgRVZFTlRfRklMRV9QUkVfUkVRVUlSRTogJ3ByZS1yZXF1aXJlJyxcbiAgICAvKipcbiAgICAgKiBFdmVudCBlbWl0dGVkIGltbWVkaWF0ZWx5IGFmdGVyIGEgdGVzdCBmaWxlIGhhcyBiZWVuIGxvYWRlZC4gTm90IGVtaXR0ZWQgaW4gYnJvd3Nlci5cbiAgICAgKi9cbiAgICBFVkVOVF9GSUxFX1JFUVVJUkU6ICdyZXF1aXJlJyxcbiAgICAvKipcbiAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gYGdsb2JhbC5ydW4oKWAgaXMgY2FsbGVkICh1c2Ugd2l0aCBgZGVsYXlgIG9wdGlvbikuXG4gICAgICovXG4gICAgRVZFTlRfUk9PVF9TVUlURV9SVU46ICdydW4nLFxuXG4gICAgLyoqXG4gICAgICogTmFtZXNwYWNlIGZvciBjb2xsZWN0aW9uIG9mIGEgYFN1aXRlYCdzIFwiYWZ0ZXIgYWxsXCIgaG9va3MuXG4gICAgICovXG4gICAgSE9PS19UWVBFX0FGVEVSX0FMTDogJ2FmdGVyQWxsJyxcbiAgICAvKipcbiAgICAgKiBOYW1lc3BhY2UgZm9yIGNvbGxlY3Rpb24gb2YgYSBgU3VpdGVgJ3MgXCJhZnRlciBlYWNoXCIgaG9va3MuXG4gICAgICovXG4gICAgSE9PS19UWVBFX0FGVEVSX0VBQ0g6ICdhZnRlckVhY2gnLFxuICAgIC8qKlxuICAgICAqIE5hbWVzcGFjZSBmb3IgY29sbGVjdGlvbiBvZiBhIGBTdWl0ZWAncyBcImJlZm9yZSBhbGxcIiBob29rcy5cbiAgICAgKi9cbiAgICBIT09LX1RZUEVfQkVGT1JFX0FMTDogJ2JlZm9yZUFsbCcsXG4gICAgLyoqXG4gICAgICogTmFtZXNwYWNlIGZvciBjb2xsZWN0aW9uIG9mIGEgYFN1aXRlYCdzIFwiYmVmb3JlIGVhY2hcIiBob29rcy5cbiAgICAgKi9cbiAgICBIT09LX1RZUEVfQkVGT1JFX0VBQ0g6ICdiZWZvcmVFYWNoJyxcblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgYWZ0ZXIgYSBjaGlsZCBgU3VpdGVgIGhhcyBiZWVuIGFkZGVkIHRvIGEgYFN1aXRlYC5cbiAgICAgKi9cbiAgICBFVkVOVF9TVUlURV9BRERfU1VJVEU6ICdzdWl0ZScsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCBhZnRlciBhbiBcImFmdGVyIGFsbFwiIGBIb29rYCBoYXMgYmVlbiBhZGRlZCB0byBhIGBTdWl0ZWAuXG4gICAgICovXG4gICAgRVZFTlRfU1VJVEVfQUREX0hPT0tfQUZURVJfQUxMOiAnYWZ0ZXJBbGwnLFxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgYWZ0ZXIgYW4gXCJhZnRlciBlYWNoXCIgYEhvb2tgIGhhcyBiZWVuIGFkZGVkIHRvIGEgYFN1aXRlYC5cbiAgICAgKi9cbiAgICBFVkVOVF9TVUlURV9BRERfSE9PS19BRlRFUl9FQUNIOiAnYWZ0ZXJFYWNoJyxcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIGFmdGVyIGFuIFwiYmVmb3JlIGFsbFwiIGBIb29rYCBoYXMgYmVlbiBhZGRlZCB0byBhIGBTdWl0ZWAuXG4gICAgICovXG4gICAgRVZFTlRfU1VJVEVfQUREX0hPT0tfQkVGT1JFX0FMTDogJ2JlZm9yZUFsbCcsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCBhZnRlciBhbiBcImJlZm9yZSBlYWNoXCIgYEhvb2tgIGhhcyBiZWVuIGFkZGVkIHRvIGEgYFN1aXRlYC5cbiAgICAgKi9cbiAgICBFVkVOVF9TVUlURV9BRERfSE9PS19CRUZPUkVfRUFDSDogJ2JlZm9yZUVhY2gnLFxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgYWZ0ZXIgYSBgVGVzdGAgaGFzIGJlZW4gYWRkZWQgdG8gYSBgU3VpdGVgLlxuICAgICAqL1xuICAgIEVWRU5UX1NVSVRFX0FERF9URVNUOiAndGVzdCdcbiAgfVxuKTtcblxuU3VpdGUuY29uc3RhbnRzID0gY29uc3RhbnRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFJ1bm5hYmxlID0gcmVxdWlyZSgnLi9ydW5uYWJsZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgY3JlYXRlSW52YWxpZEFyZ3VtZW50VHlwZUVycm9yID0gZXJyb3JzLmNyZWF0ZUludmFsaWRBcmd1bWVudFR5cGVFcnJvcjtcbnZhciBpc1N0cmluZyA9IHV0aWxzLmlzU3RyaW5nO1xuXG5jb25zdCB7TU9DSEFfSURfUFJPUF9OQU1FfSA9IHV0aWxzLmNvbnN0YW50cztcblxubW9kdWxlLmV4cG9ydHMgPSBUZXN0O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFRlc3RgIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmAuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBSdW5uYWJsZVxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlIC0gVGVzdCB0aXRsZSAocmVxdWlyZWQpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIC0gVGVzdCBjYWxsYmFjay4gIElmIG9taXR0ZWQsIHRoZSBUZXN0IGlzIGNvbnNpZGVyZWQgXCJwZW5kaW5nXCJcbiAqL1xuZnVuY3Rpb24gVGVzdCh0aXRsZSwgZm4pIHtcbiAgaWYgKCFpc1N0cmluZyh0aXRsZSkpIHtcbiAgICB0aHJvdyBjcmVhdGVJbnZhbGlkQXJndW1lbnRUeXBlRXJyb3IoXG4gICAgICAnVGVzdCBhcmd1bWVudCBcInRpdGxlXCIgc2hvdWxkIGJlIGEgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIFwiJyArXG4gICAgICAgIHR5cGVvZiB0aXRsZSArXG4gICAgICAgICdcIicsXG4gICAgICAndGl0bGUnLFxuICAgICAgJ3N0cmluZydcbiAgICApO1xuICB9XG4gIHRoaXMudHlwZSA9ICd0ZXN0JztcbiAgUnVubmFibGUuY2FsbCh0aGlzLCB0aXRsZSwgZm4pO1xuICB0aGlzLnJlc2V0KCk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBSdW5uYWJsZS5wcm90b3R5cGVgLlxuICovXG51dGlscy5pbmhlcml0cyhUZXN0LCBSdW5uYWJsZSk7XG5cbi8qKlxuICogUmVzZXRzIHRoZSBzdGF0ZSBpbml0aWFsbHkgb3IgZm9yIGEgbmV4dCBydW4uXG4gKi9cblRlc3QucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBSdW5uYWJsZS5wcm90b3R5cGUucmVzZXQuY2FsbCh0aGlzKTtcbiAgdGhpcy5wZW5kaW5nID0gIXRoaXMuZm47XG4gIGRlbGV0ZSB0aGlzLnN0YXRlO1xufTtcblxuLyoqXG4gKiBTZXQgb3IgZ2V0IHJldHJpZWQgdGVzdFxuICpcbiAqIEBwcml2YXRlXG4gKi9cblRlc3QucHJvdG90eXBlLnJldHJpZWRUZXN0ID0gZnVuY3Rpb24gKG4pIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JldHJpZWRUZXN0O1xuICB9XG4gIHRoaXMuX3JldHJpZWRUZXN0ID0gbjtcbn07XG5cbi8qKlxuICogQWRkIHRlc3QgdG8gdGhlIGxpc3Qgb2YgdGVzdHMgbWFya2VkIGBvbmx5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5UZXN0LnByb3RvdHlwZS5tYXJrT25seSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wYXJlbnQuYXBwZW5kT25seVRlc3QodGhpcyk7XG59O1xuXG5UZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSBuZXcgVGVzdCh0aGlzLnRpdGxlLCB0aGlzLmZuKTtcbiAgdGVzdC50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcbiAgdGVzdC5zbG93KHRoaXMuc2xvdygpKTtcbiAgdGVzdC5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcbiAgdGVzdC5jdXJyZW50UmV0cnkodGhpcy5jdXJyZW50UmV0cnkoKSk7XG4gIHRlc3QucmV0cmllZFRlc3QodGhpcy5yZXRyaWVkVGVzdCgpIHx8IHRoaXMpO1xuICB0ZXN0Lmdsb2JhbHModGhpcy5nbG9iYWxzKCkpO1xuICB0ZXN0LnBhcmVudCA9IHRoaXMucGFyZW50O1xuICB0ZXN0LmZpbGUgPSB0aGlzLmZpbGU7XG4gIHRlc3QuY3R4ID0gdGhpcy5jdHg7XG4gIHJldHVybiB0ZXN0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG1pbmltYWwgb2JqZWN0IHN1aXRhYmxlIGZvciB0cmFuc21pc3Npb24gb3ZlciBJUEMuXG4gKiBGdW5jdGlvbnMgYXJlIHJlcHJlc2VudGVkIGJ5IGtleXMgYmVnaW5uaW5nIHdpdGggYCQkYC5cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5UZXN0LnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gIHJldHVybiB7XG4gICAgJCRjdXJyZW50UmV0cnk6IHRoaXMuX2N1cnJlbnRSZXRyeSxcbiAgICAkJGZ1bGxUaXRsZTogdGhpcy5mdWxsVGl0bGUoKSxcbiAgICAkJGlzUGVuZGluZzogQm9vbGVhbih0aGlzLnBlbmRpbmcpLFxuICAgICQkcmV0cmllZFRlc3Q6IHRoaXMuX3JldHJpZWRUZXN0IHx8IG51bGwsXG4gICAgJCRzbG93OiB0aGlzLl9zbG93LFxuICAgICQkdGl0bGVQYXRoOiB0aGlzLnRpdGxlUGF0aCgpLFxuICAgIGJvZHk6IHRoaXMuYm9keSxcbiAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICBlcnI6IHRoaXMuZXJyLFxuICAgIHBhcmVudDoge1xuICAgICAgJCRmdWxsVGl0bGU6IHRoaXMucGFyZW50LmZ1bGxUaXRsZSgpLFxuICAgICAgW01PQ0hBX0lEX1BST1BfTkFNRV06IHRoaXMucGFyZW50LmlkXG4gICAgfSxcbiAgICBzcGVlZDogdGhpcy5zcGVlZCxcbiAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICB0aXRsZTogdGhpcy50aXRsZSxcbiAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgZmlsZTogdGhpcy5maWxlLFxuICAgIFtNT0NIQV9JRF9QUk9QX05BTUVdOiB0aGlzLmlkXG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCB0aHJvdWdob3V0IE1vY2hhJ3MgY29kZWJhc2UuXG4gKiBAbW9kdWxlIHV0aWxzXG4gKi9cblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IHtuYW5vaWR9ID0gcmVxdWlyZSgnbmFub2lkL25vbi1zZWN1cmUnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgaGUgPSByZXF1aXJlKCdoZScpO1xuXG5jb25zdCBNT0NIQV9JRF9QUk9QX05BTUUgPSAnX19tb2NoYV9pZF9fJztcblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciAtIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIC0gQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgZWl0aGVyIGNvbnN0cnVjdG9yIGlzIG51bGwsIG9yIGlmIHN1cGVyIGNvbnN0cnVjdG9yXG4gKiAgICAgbGFja3MgYSBwcm90b3R5cGUuXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSB1dGlsLmluaGVyaXRzO1xuXG4vKipcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5lc2NhcGUgPSBmdW5jdGlvbiAoaHRtbCkge1xuICByZXR1cm4gaGUuZW5jb2RlKFN0cmluZyhodG1sKSwge3VzZU5hbWVkUmVmZXJlbmNlczogZmFsc2V9KTtcbn07XG5cbi8qKlxuICogVGVzdCBpZiB0aGUgZ2l2ZW4gb2JqIGlzIHR5cGUgb2Ygc3RyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzU3RyaW5nID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZyc7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgYSBzbHVnIGZyb20gdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuc2x1ZyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgLnJlcGxhY2UoL1xccysvZywgJy0nKVxuICAgIC5yZXBsYWNlKC9bXi1cXHddL2csICcnKVxuICAgIC5yZXBsYWNlKC8tezIsfS9nLCAnLScpO1xufTtcblxuLyoqXG4gKiBTdHJpcCB0aGUgZnVuY3Rpb24gZGVmaW5pdGlvbiBmcm9tIGBzdHJgLCBhbmQgcmUtaW5kZW50IGZvciBwcmUgd2hpdGVzcGFjZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuY2xlYW4gPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHN0ciA9IHN0clxuICAgIC5yZXBsYWNlKC9cXHJcXG4/fFtcXG5cXHUyMDI4XFx1MjAyOV0vZywgJ1xcbicpXG4gICAgLnJlcGxhY2UoL15cXHVGRUZGLywgJycpXG4gICAgLy8gKHRyYWRpdGlvbmFsKS0+ICBzcGFjZS9uYW1lICAgICBwYXJhbWV0ZXJzICAgIGJvZHkgICAgIChsYW1iZGEpLT4gcGFyYW1ldGVycyAgICAgICBib2R5ICAgbXVsdGktc3RhdGVtZW50L3NpbmdsZSAgICAgICAgICBrZWVwIGJvZHkgY29udGVudFxuICAgIC5yZXBsYWNlKFxuICAgICAgL15mdW5jdGlvbig/Olxccyp8XFxzK1teKF0qKVxcKFteKV0qXFwpXFxzKlxceygoPzoufFxcbikqPylcXHMqXFx9JHxeXFwoW14pXSpcXClcXHMqPT5cXHMqKD86XFx7KCg/Oi58XFxuKSo/KVxccypcXH18KCg/Oi58XFxuKSopKSQvLFxuICAgICAgJyQxJDIkMydcbiAgICApO1xuXG4gIHZhciBzcGFjZXMgPSBzdHIubWF0Y2goL15cXG4/KCAqKS8pWzFdLmxlbmd0aDtcbiAgdmFyIHRhYnMgPSBzdHIubWF0Y2goL15cXG4/KFxcdCopLylbMV0ubGVuZ3RoO1xuICB2YXIgcmUgPSBuZXcgUmVnRXhwKFxuICAgICdeXFxuPycgKyAodGFicyA/ICdcXHQnIDogJyAnKSArICd7JyArICh0YWJzIHx8IHNwYWNlcykgKyAnfScsXG4gICAgJ2dtJ1xuICApO1xuXG4gIHN0ciA9IHN0ci5yZXBsYWNlKHJlLCAnJyk7XG5cbiAgcmV0dXJuIHN0ci50cmltKCk7XG59O1xuXG4vKipcbiAqIElmIGEgdmFsdWUgY291bGQgaGF2ZSBwcm9wZXJ0aWVzLCBhbmQgaGFzIG5vbmUsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLFxuICogd2hpY2ggcmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZW1wdHkgdmFsdWUuXG4gKlxuICogRnVuY3Rpb25zIHcvIG5vIHByb3BlcnRpZXMgcmV0dXJuIGAnW0Z1bmN0aW9uXSdgXG4gKiBBcnJheXMgdy8gbGVuZ3RoID09PSAwIHJldHVybiBgJ1tdJ2BcbiAqIE9iamVjdHMgdy8gbm8gcHJvcGVydGllcyByZXR1cm4gYCd7fSdgXG4gKiBBbGwgZWxzZTogcmV0dXJuIHJlc3VsdCBvZiBgdmFsdWUudG9TdHJpbmcoKWBcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlSGludCBUaGUgdHlwZSBvZiB0aGUgdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVtcHR5UmVwcmVzZW50YXRpb24odmFsdWUsIHR5cGVIaW50KSB7XG4gIHN3aXRjaCAodHlwZUhpbnQpIHtcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gJ1tGdW5jdGlvbl0nO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gJ3t9JztcbiAgICBjYXNlICdhcnJheSc6XG4gICAgICByZXR1cm4gJ1tdJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUYWtlcyBzb21lIHZhcmlhYmxlIGFuZCBhc2tzIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClgIHdoYXQgaXQgdGhpbmtzIGl0XG4gKiBpcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvdG9TdHJpbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb21wdXRlZCB0eXBlXG4gKiBAZXhhbXBsZVxuICogY2Fub25pY2FsVHlwZSh7fSkgLy8gJ29iamVjdCdcbiAqIGNhbm9uaWNhbFR5cGUoW10pIC8vICdhcnJheSdcbiAqIGNhbm9uaWNhbFR5cGUoMSkgLy8gJ251bWJlcidcbiAqIGNhbm9uaWNhbFR5cGUoZmFsc2UpIC8vICdib29sZWFuJ1xuICogY2Fub25pY2FsVHlwZShJbmZpbml0eSkgLy8gJ251bWJlcidcbiAqIGNhbm9uaWNhbFR5cGUobnVsbCkgLy8gJ251bGwnXG4gKiBjYW5vbmljYWxUeXBlKG5ldyBEYXRlKCkpIC8vICdkYXRlJ1xuICogY2Fub25pY2FsVHlwZSgvZm9vLykgLy8gJ3JlZ2V4cCdcbiAqIGNhbm9uaWNhbFR5cGUoJ3R5cGUnKSAvLyAnc3RyaW5nJ1xuICogY2Fub25pY2FsVHlwZShnbG9iYWwpIC8vICdnbG9iYWwnXG4gKiBjYW5vbmljYWxUeXBlKG5ldyBTdHJpbmcoJ2ZvbycpIC8vICdvYmplY3QnXG4gKiBjYW5vbmljYWxUeXBlKGFzeW5jIGZ1bmN0aW9uKCkge30pIC8vICdhc3luY2Z1bmN0aW9uJ1xuICogY2Fub25pY2FsVHlwZShhd2FpdCBpbXBvcnQobmFtZSkpIC8vICdtb2R1bGUnXG4gKi9cbnZhciBjYW5vbmljYWxUeXBlID0gKGV4cG9ydHMuY2Fub25pY2FsVHlwZSA9IGZ1bmN0aW9uIGNhbm9uaWNhbFR5cGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gJ2J1ZmZlcic7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAuY2FsbCh2YWx1ZSlcbiAgICAucmVwbGFjZSgvXlxcWy4rXFxzKC4rPyldJC8sICckMScpXG4gICAgLnRvTG93ZXJDYXNlKCk7XG59KTtcblxuLyoqXG4gKlxuICogUmV0dXJucyBhIGdlbmVyYWwgdHlwZSBvciBkYXRhIHN0cnVjdHVyZSBvZiBhIHZhcmlhYmxlXG4gKiBAcHJpdmF0ZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0RhdGFfc3RydWN0dXJlc1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IE9uZSBvZiB1bmRlZmluZWQsIGJvb2xlYW4sIG51bWJlciwgc3RyaW5nLCBiaWdpbnQsIHN5bWJvbCwgb2JqZWN0XG4gKiBAZXhhbXBsZVxuICogdHlwZSh7fSkgLy8gJ29iamVjdCdcbiAqIHR5cGUoW10pIC8vICdhcnJheSdcbiAqIHR5cGUoMSkgLy8gJ251bWJlcidcbiAqIHR5cGUoZmFsc2UpIC8vICdib29sZWFuJ1xuICogdHlwZShJbmZpbml0eSkgLy8gJ251bWJlcidcbiAqIHR5cGUobnVsbCkgLy8gJ251bGwnXG4gKiB0eXBlKG5ldyBEYXRlKCkpIC8vICdvYmplY3QnXG4gKiB0eXBlKC9mb28vKSAvLyAnb2JqZWN0J1xuICogdHlwZSgndHlwZScpIC8vICdzdHJpbmcnXG4gKiB0eXBlKGdsb2JhbCkgLy8gJ29iamVjdCdcbiAqIHR5cGUobmV3IFN0cmluZygnZm9vJykgLy8gJ3N0cmluZydcbiAqL1xuZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gdHlwZSh2YWx1ZSkge1xuICAvLyBOdWxsIGlzIHNwZWNpYWxcbiAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICBjb25zdCBwcmltaXRpdmVzID0gbmV3IFNldChbXG4gICAgJ3VuZGVmaW5lZCcsXG4gICAgJ2Jvb2xlYW4nLFxuICAgICdudW1iZXInLFxuICAgICdzdHJpbmcnLFxuICAgICdiaWdpbnQnLFxuICAgICdzeW1ib2wnXG4gIF0pO1xuICBjb25zdCBfdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKF90eXBlID09PSAnZnVuY3Rpb24nKSByZXR1cm4gX3R5cGU7XG4gIGlmIChwcmltaXRpdmVzLmhhcyhfdHlwZSkpIHJldHVybiBfdHlwZTtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSByZXR1cm4gJ3N0cmluZyc7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gJ2Vycm9yJztcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gJ2FycmF5JztcblxuICByZXR1cm4gX3R5cGU7XG59O1xuXG4vKipcbiAqIFN0cmluZ2lmeSBgdmFsdWVgLiBEaWZmZXJlbnQgYmVoYXZpb3IgZGVwZW5kaW5nIG9uIHR5cGUgb2YgdmFsdWU6XG4gKlxuICogLSBJZiBgdmFsdWVgIGlzIHVuZGVmaW5lZCBvciBudWxsLCByZXR1cm4gYCdbdW5kZWZpbmVkXSdgIG9yIGAnW251bGxdJ2AsIHJlc3BlY3RpdmVseS5cbiAqIC0gSWYgYHZhbHVlYCBpcyBub3QgYW4gb2JqZWN0LCBmdW5jdGlvbiBvciBhcnJheSwgcmV0dXJuIHJlc3VsdCBvZiBgdmFsdWUudG9TdHJpbmcoKWAgd3JhcHBlZCBpbiBkb3VibGUtcXVvdGVzLlxuICogLSBJZiBgdmFsdWVgIGlzIGFuICplbXB0eSogb2JqZWN0LCBmdW5jdGlvbiwgb3IgYXJyYXksIHJldHVybiByZXN1bHQgb2YgZnVuY3Rpb25cbiAqICAge0BsaW5rIGVtcHR5UmVwcmVzZW50YXRpb259LlxuICogLSBJZiBgdmFsdWVgIGhhcyBwcm9wZXJ0aWVzLCBjYWxsIHtAbGluayBleHBvcnRzLmNhbm9uaWNhbGl6ZX0gb24gaXQsIHRoZW4gcmV0dXJuIHJlc3VsdCBvZlxuICogICBKU09OLnN0cmluZ2lmeSgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAc2VlIGV4cG9ydHMudHlwZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgdHlwZUhpbnQgPSBjYW5vbmljYWxUeXBlKHZhbHVlKTtcblxuICBpZiAoIX5bJ29iamVjdCcsICdhcnJheScsICdmdW5jdGlvbiddLmluZGV4T2YodHlwZUhpbnQpKSB7XG4gICAgaWYgKHR5cGVIaW50ID09PSAnYnVmZmVyJykge1xuICAgICAgdmFyIGpzb24gPSBCdWZmZXIucHJvdG90eXBlLnRvSlNPTi5jYWxsKHZhbHVlKTtcbiAgICAgIC8vIEJhc2VkIG9uIHRoZSB0b0pTT04gcmVzdWx0XG4gICAgICByZXR1cm4ganNvblN0cmluZ2lmeShcbiAgICAgICAganNvbi5kYXRhICYmIGpzb24udHlwZSA/IGpzb24uZGF0YSA6IGpzb24sXG4gICAgICAgIDJcbiAgICAgICkucmVwbGFjZSgvLChcXG58JCkvZywgJyQxJyk7XG4gICAgfVxuXG4gICAgLy8gSUU3L0lFOCBoYXMgYSBiaXphcnJlIFN0cmluZyBjb25zdHJ1Y3RvcjsgbmVlZHMgdG8gYmUgY29lcmNlZFxuICAgIC8vIGludG8gYW4gYXJyYXkgYW5kIGJhY2sgdG8gb2JqLlxuICAgIGlmICh0eXBlSGludCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnJykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNoYXIsIGlkeCkge1xuICAgICAgICBhY2NbaWR4XSA9IGNoYXI7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgICB0eXBlSGludCA9ICdvYmplY3QnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ganNvblN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgcHJvcCBpbiB2YWx1ZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHByb3ApKSB7XG4gICAgICByZXR1cm4ganNvblN0cmluZ2lmeShcbiAgICAgICAgZXhwb3J0cy5jYW5vbmljYWxpemUodmFsdWUsIG51bGwsIHR5cGVIaW50KSxcbiAgICAgICAgMlxuICAgICAgKS5yZXBsYWNlKC8sKFxcbnwkKS9nLCAnJDEnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW1wdHlSZXByZXNlbnRhdGlvbih2YWx1ZSwgdHlwZUhpbnQpO1xufTtcblxuLyoqXG4gKiBsaWtlIEpTT04uc3RyaW5naWZ5IGJ1dCBtb3JlIHNlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gIG9iamVjdFxuICogQHBhcmFtIHtudW1iZXI9fSBzcGFjZXNcbiAqIEBwYXJhbSB7bnVtYmVyPX0gZGVwdGhcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBqc29uU3RyaW5naWZ5KG9iamVjdCwgc3BhY2VzLCBkZXB0aCkge1xuICBpZiAodHlwZW9mIHNwYWNlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBwcmltaXRpdmUgdHlwZXNcbiAgICByZXR1cm4gX3N0cmluZ2lmeShvYmplY3QpO1xuICB9XG5cbiAgZGVwdGggPSBkZXB0aCB8fCAxO1xuICB2YXIgc3BhY2UgPSBzcGFjZXMgKiBkZXB0aDtcbiAgdmFyIHN0ciA9IEFycmF5LmlzQXJyYXkob2JqZWN0KSA/ICdbJyA6ICd7JztcbiAgdmFyIGVuZCA9IEFycmF5LmlzQXJyYXkob2JqZWN0KSA/ICddJyA6ICd9JztcbiAgdmFyIGxlbmd0aCA9XG4gICAgdHlwZW9mIG9iamVjdC5sZW5ndGggPT09ICdudW1iZXInXG4gICAgICA/IG9iamVjdC5sZW5ndGhcbiAgICAgIDogT2JqZWN0LmtleXMob2JqZWN0KS5sZW5ndGg7XG4gIC8vIGAucmVwZWF0KClgIHBvbHlmaWxsXG4gIGZ1bmN0aW9uIHJlcGVhdChzLCBuKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheShuKS5qb2luKHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3N0cmluZ2lmeSh2YWwpIHtcbiAgICBzd2l0Y2ggKGNhbm9uaWNhbFR5cGUodmFsKSkge1xuICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICB2YWwgPSAnWycgKyB2YWwgKyAnXSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgdmFsID0ganNvblN0cmluZ2lmeSh2YWwsIHNwYWNlcywgZGVwdGggKyAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgdmFsID1cbiAgICAgICAgICB2YWwgPT09IDAgJiYgMSAvIHZhbCA9PT0gLUluZmluaXR5IC8vIGAtMGBcbiAgICAgICAgICAgID8gJy0wJ1xuICAgICAgICAgICAgOiB2YWwudG9TdHJpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICB2YWwgPSB2YWwudG9TdHJpbmcoKSArICduJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgdmFyIHNEYXRlID0gaXNOYU4odmFsLmdldFRpbWUoKSkgPyB2YWwudG9TdHJpbmcoKSA6IHZhbC50b0lTT1N0cmluZygpO1xuICAgICAgICB2YWwgPSAnW0RhdGU6ICcgKyBzRGF0ZSArICddJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdidWZmZXInOlxuICAgICAgICB2YXIganNvbiA9IHZhbC50b0pTT04oKTtcbiAgICAgICAgLy8gQmFzZWQgb24gdGhlIHRvSlNPTiByZXN1bHRcbiAgICAgICAganNvbiA9IGpzb24uZGF0YSAmJiBqc29uLnR5cGUgPyBqc29uLmRhdGEgOiBqc29uO1xuICAgICAgICB2YWwgPSAnW0J1ZmZlcjogJyArIGpzb25TdHJpbmdpZnkoanNvbiwgMiwgZGVwdGggKyAxKSArICddJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YWwgPVxuICAgICAgICAgIHZhbCA9PT0gJ1tGdW5jdGlvbl0nIHx8IHZhbCA9PT0gJ1tDaXJjdWxhcl0nXG4gICAgICAgICAgICA/IHZhbFxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh2YWwpOyAvLyBzdHJpbmdcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGZvciAodmFyIGkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBpKSkge1xuICAgICAgY29udGludWU7IC8vIG5vdCBteSBidXNpbmVzc1xuICAgIH1cbiAgICAtLWxlbmd0aDtcbiAgICBzdHIgKz1cbiAgICAgICdcXG4gJyArXG4gICAgICByZXBlYXQoJyAnLCBzcGFjZSkgK1xuICAgICAgKEFycmF5LmlzQXJyYXkob2JqZWN0KSA/ICcnIDogJ1wiJyArIGkgKyAnXCI6ICcpICsgLy8ga2V5XG4gICAgICBfc3RyaW5naWZ5KG9iamVjdFtpXSkgKyAvLyB2YWx1ZVxuICAgICAgKGxlbmd0aCA/ICcsJyA6ICcnKTsgLy8gY29tbWFcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgc3RyICtcbiAgICAvLyBbXSwge31cbiAgICAoc3RyLmxlbmd0aCAhPT0gMSA/ICdcXG4nICsgcmVwZWF0KCcgJywgLS1zcGFjZSkgKyBlbmQgOiBlbmQpXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgbmV3IFRoaW5nIHRoYXQgaGFzIHRoZSBrZXlzIGluIHNvcnRlZCBvcmRlci4gUmVjdXJzaXZlLlxuICpcbiAqIElmIHRoZSBUaGluZy4uLlxuICogLSBoYXMgYWxyZWFkeSBiZWVuIHNlZW4sIHJldHVybiBzdHJpbmcgYCdbQ2lyY3VsYXJdJ2BcbiAqIC0gaXMgYHVuZGVmaW5lZGAsIHJldHVybiBzdHJpbmcgYCdbdW5kZWZpbmVkXSdgXG4gKiAtIGlzIGBudWxsYCwgcmV0dXJuIHZhbHVlIGBudWxsYFxuICogLSBpcyBzb21lIG90aGVyIHByaW1pdGl2ZSwgcmV0dXJuIHRoZSB2YWx1ZVxuICogLSBpcyBub3QgYSBwcmltaXRpdmUgb3IgYW4gYEFycmF5YCwgYE9iamVjdGAsIG9yIGBGdW5jdGlvbmAsIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIFRoaW5nJ3MgYHRvU3RyaW5nKClgIG1ldGhvZFxuICogLSBpcyBhIG5vbi1lbXB0eSBgQXJyYXlgLCBgT2JqZWN0YCwgb3IgYEZ1bmN0aW9uYCwgcmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIGFnYWluLlxuICogLSBpcyBhbiBlbXB0eSBgQXJyYXlgLCBgT2JqZWN0YCwgb3IgYEZ1bmN0aW9uYCwgcmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZW1wdHlSZXByZXNlbnRhdGlvbigpYFxuICpcbiAqIEBwcml2YXRlXG4gKiBAc2VlIHtAbGluayBleHBvcnRzLnN0cmluZ2lmeX1cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhpbmcgdG8gaW5zcGVjdC4gIE1heSBvciBtYXkgbm90IGhhdmUgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFjaz1bXV0gU3RhY2sgb2Ygc2VlbiB2YWx1ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZUhpbnRdIFR5cGUgaGludFxuICogQHJldHVybiB7KE9iamVjdHxBcnJheXxGdW5jdGlvbnxzdHJpbmd8dW5kZWZpbmVkKX1cbiAqL1xuZXhwb3J0cy5jYW5vbmljYWxpemUgPSBmdW5jdGlvbiBjYW5vbmljYWxpemUodmFsdWUsIHN0YWNrLCB0eXBlSGludCkge1xuICB2YXIgY2Fub25pY2FsaXplZE9iajtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgdmFyIHByb3A7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgdHlwZUhpbnQgPSB0eXBlSGludCB8fCBjYW5vbmljYWxUeXBlKHZhbHVlKTtcbiAgZnVuY3Rpb24gd2l0aFN0YWNrKHZhbHVlLCBmbikge1xuICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgIGZuKCk7XG4gICAgc3RhY2sucG9wKCk7XG4gIH1cblxuICBzdGFjayA9IHN0YWNrIHx8IFtdO1xuXG4gIGlmIChzdGFjay5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlSGludCkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgY2FzZSAnYnVmZmVyJzpcbiAgICBjYXNlICdudWxsJzpcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIHdpdGhTdGFjayh2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYW5vbmljYWxpemVkT2JqID0gdmFsdWUubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cG9ydHMuY2Fub25pY2FsaXplKGl0ZW0sIHN0YWNrKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycywgbm8tdW5yZWFjaGFibGUtbG9vcCAqL1xuICAgICAgZm9yIChwcm9wIGluIHZhbHVlKSB7XG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB7fTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIGd1YXJkLWZvci1pbiAqL1xuICAgICAgaWYgKCFjYW5vbmljYWxpemVkT2JqKSB7XG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBlbXB0eVJlcHJlc2VudGF0aW9uKHZhbHVlLCB0eXBlSGludCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IGNhbm9uaWNhbGl6ZWRPYmogfHwge307XG4gICAgICB3aXRoU3RhY2sodmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgT2JqZWN0LmtleXModmFsdWUpXG4gICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGNhbm9uaWNhbGl6ZWRPYmpba2V5XSA9IGV4cG9ydHMuY2Fub25pY2FsaXplKHZhbHVlW2tleV0sIHN0YWNrKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdyZWdleHAnOlxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICBjYW5vbmljYWxpemVkT2JqID0gdmFsdWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IHZhbHVlICsgJyc7XG4gIH1cblxuICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcbn07XG5cbi8qKlxuICogQHN1bW1hcnlcbiAqIFRoaXMgRmlsdGVyIGJhc2VkIG9uIGBtb2NoYS1jbGVhbmAgbW9kdWxlLihzZWU6IGBnaXRodWIuY29tL3JzdGFjcnV6L21vY2hhLWNsZWFuYClcbiAqIEBkZXNjcmlwdGlvblxuICogV2hlbiBpbnZva2luZyB0aGlzIGZ1bmN0aW9uIHlvdSBnZXQgYSBmaWx0ZXIgZnVuY3Rpb24gdGhhdCBnZXQgdGhlIEVycm9yLnN0YWNrIGFzIGFuIGlucHV0LFxuICogYW5kIHJldHVybiBhIHByZXR0aWZ5IG91dHB1dC5cbiAqIChpLmU6IHN0cmlwIE1vY2hhIGFuZCBpbnRlcm5hbCBub2RlIGZ1bmN0aW9ucyBmcm9tIHN0YWNrIHRyYWNlKS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5zdGFja1RyYWNlRmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAvLyBUT0RPOiBSZXBsYWNlIHdpdGggYHByb2Nlc3MuYnJvd3NlcmBcbiAgdmFyIGlzID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IHtub2RlOiB0cnVlfSA6IHticm93c2VyOiB0cnVlfTtcbiAgdmFyIHNsYXNoID0gcGF0aC5zZXA7XG4gIHZhciBjd2Q7XG4gIGlmIChpcy5ub2RlKSB7XG4gICAgY3dkID0gZXhwb3J0cy5jd2QoKSArIHNsYXNoO1xuICB9IGVsc2Uge1xuICAgIGN3ZCA9IChcbiAgICAgIHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24gOiBsb2NhdGlvblxuICAgICkuaHJlZi5yZXBsYWNlKC9cXC9bXi9dKiQvLCAnLycpO1xuICAgIHNsYXNoID0gJy8nO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNNb2NoYUludGVybmFsKGxpbmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgfmxpbmUuaW5kZXhPZignbm9kZV9tb2R1bGVzJyArIHNsYXNoICsgJ21vY2hhJyArIHNsYXNoKSB8fFxuICAgICAgfmxpbmUuaW5kZXhPZihzbGFzaCArICdtb2NoYS5qcycpIHx8XG4gICAgICB+bGluZS5pbmRleE9mKHNsYXNoICsgJ21vY2hhLm1pbi5qcycpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZUludGVybmFsKGxpbmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgfmxpbmUuaW5kZXhPZignKHRpbWVycy5qczonKSB8fFxuICAgICAgfmxpbmUuaW5kZXhPZignKGV2ZW50cy5qczonKSB8fFxuICAgICAgfmxpbmUuaW5kZXhPZignKG5vZGUuanM6JykgfHxcbiAgICAgIH5saW5lLmluZGV4T2YoJyhtb2R1bGUuanM6JykgfHxcbiAgICAgIH5saW5lLmluZGV4T2YoJ0dlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLm5leHQgKG5hdGl2ZSknKSB8fFxuICAgICAgZmFsc2VcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGFjaykge1xuICAgIHN0YWNrID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuXG4gICAgc3RhY2sgPSBzdGFjay5yZWR1Y2UoZnVuY3Rpb24gKGxpc3QsIGxpbmUpIHtcbiAgICAgIGlmIChpc01vY2hhSW50ZXJuYWwobGluZSkpIHtcbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChpcy5ub2RlICYmIGlzTm9kZUludGVybmFsKGxpbmUpKSB7XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhbiB1cCBjd2QoYWJzb2x1dGUpXG4gICAgICBpZiAoLzpcXGQrOlxcZCtcXCk/JC8udGVzdChsaW5lKSkge1xuICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKCcoJyArIGN3ZCwgJygnKTtcbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGxpbmUpO1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHN0YWNrLmpvaW4oJ1xcbicpO1xuICB9O1xufTtcblxuLyoqXG4gKiBDcnVkZSwgYnV0IGVmZmVjdGl2ZS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCBgdmFsdWVgIGlzIGEgUHJvbWlzZVxuICovXG5leHBvcnRzLmlzUHJvbWlzZSA9IGZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nXG4gICk7XG59O1xuXG4vKipcbiAqIENsYW1wcyBhIG51bWVyaWMgdmFsdWUgdG8gYW4gaW5jbHVzaXZlIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFZhbHVlIHRvIGJlIGNsYW1wZWQuXG4gKiBAcGFyYW0ge251bWJlcltdfSByYW5nZSAtIFR3byBlbGVtZW50IGFycmF5IHNwZWNpZnlpbmcgW21pbiwgbWF4XSByYW5nZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IGNsYW1wZWQgdmFsdWVcbiAqL1xuZXhwb3J0cy5jbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCByYW5nZSkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIHJhbmdlWzBdKSwgcmFuZ2VbMV0pO1xufTtcblxuLyoqXG4gKiBJdCdzIGEgbm9vcC5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0cy5ub29wID0gZnVuY3Rpb24gKCkge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcC1saWtlIG9iamVjdC5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgXCJtYXBcIiBpcyBhbiBvYmplY3Qgd2l0aCBubyBwcm90b3R5cGUsIGZvciBvdXIgcHVycG9zZXMuIEluIHNvbWUgY2FzZXNcbiAqIHRoaXMgd291bGQgYmUgbW9yZSBhcHByb3ByaWF0ZSB0aGFuIGEgYE1hcGAsIGVzcGVjaWFsbHkgaWYgeW91ciBlbnZpcm9ubWVudFxuICogZG9lc24ndCBzdXBwb3J0IGl0LiBSZWNvbW1lbmRlZCBmb3IgdXNlIGluIE1vY2hhJ3MgcHVibGljIEFQSXMuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwI0N1c3RvbV9hbmRfTnVsbF9vYmplY3RzfE1ETjpNYXB9XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlI0N1c3RvbV9hbmRfTnVsbF9vYmplY3RzfE1ETjpPYmplY3QuY3JlYXRlIC0gQ3VzdG9tIG9iamVjdHN9XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduI0N1c3RvbV9hbmRfTnVsbF9vYmplY3RzfE1ETjpPYmplY3QuYXNzaWdufVxuICogQHBhcmFtIHsuLi4qfSBbb2JqXSAtIEFyZ3VtZW50cyB0byBgT2JqZWN0LmFzc2lnbigpYC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIG5vIHByb3RvdHlwZSwgaGF2aW5nIGAuLi5vYmpgIHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0cy5jcmVhdGVNYXAgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduLmFwcGx5KFxuICAgIG51bGwsXG4gICAgW09iamVjdC5jcmVhdGUobnVsbCldLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICApO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVhZC1vbmx5IG1hcC1saWtlIG9iamVjdC5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgZGlmZmVycyBmcm9tIHtAbGluayBtb2R1bGU6dXRpbHMuY3JlYXRlTWFwIGNyZWF0ZU1hcH0gb25seSBpbiB0aGF0XG4gKiB0aGUgYXJndW1lbnQgbXVzdCBiZSBub24tZW1wdHksIGJlY2F1c2UgdGhlIHJlc3VsdCBpcyBmcm96ZW4uXG4gKlxuICogQHNlZSB7QGxpbmsgbW9kdWxlOnV0aWxzLmNyZWF0ZU1hcCBjcmVhdGVNYXB9XG4gKiBAcGFyYW0gey4uLip9IFtvYmpdIC0gQXJndW1lbnRzIHRvIGBPYmplY3QuYXNzaWduKClgLlxuICogQHJldHVybnMge09iamVjdH0gQSBmcm96ZW4gb2JqZWN0IHdpdGggbm8gcHJvdG90eXBlLCBoYXZpbmcgYC4uLm9iamAgcHJvcGVydGllc1xuICogQHRocm93cyB7VHlwZUVycm9yfSBpZiBhcmd1bWVudCBpcyBub3QgYSBub24tZW1wdHkgb2JqZWN0LlxuICovXG5leHBvcnRzLmRlZmluZUNvbnN0YW50cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgaWYgKGNhbm9uaWNhbFR5cGUob2JqKSAhPT0gJ29iamVjdCcgfHwgIU9iamVjdC5rZXlzKG9iaikubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudDsgZXhwZWN0ZWQgYSBub24tZW1wdHkgb2JqZWN0Jyk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoZXhwb3J0cy5jcmVhdGVNYXAob2JqKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeVxuICpcbiAqIFdyYXBwZXIgYXJvdW5kIGBwcm9jZXNzLmN3ZCgpYCBmb3IgaXNvbGF0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmN3ZCA9IGZ1bmN0aW9uIGN3ZCgpIHtcbiAgcmV0dXJuIHByb2Nlc3MuY3dkKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIE1vY2hhIGlzIHJ1bm5pbmcgaW4gYSBicm93c2VyLlxuICogQ2hlY2tzIGZvciBgcHJvY2Vzcy5icm93c2VyYC5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSBmdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gIHJldHVybiBCb29sZWFuKHByb2Nlc3MuYnJvd3Nlcik7XG59O1xuXG4vKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhbiBhcnJheTsgdXNlZnVsIGZvciBvcHRpb25hbGx5IGFjY2VwdGluZyBhcnJheSBwYXJhbWV0ZXJzXG4gKlxuICogSXQgZm9sbG93cyB0aGVzZSBydWxlcywgZGVwZW5kaW5nIG9uIGB2YWx1ZWAuICBJZiBgdmFsdWVgIGlzLi4uXG4gKiAxLiBgdW5kZWZpbmVkYDogcmV0dXJuIGFuIGVtcHR5IEFycmF5XG4gKiAyLiBgbnVsbGA6IHJldHVybiBhbiBhcnJheSB3aXRoIGEgc2luZ2xlIGBudWxsYCBlbGVtZW50XG4gKiAzLiBBbnkgb3RoZXIgb2JqZWN0OiByZXR1cm4gdGhlIHZhbHVlIG9mIGBBcnJheS5mcm9tKClgIF9pZl8gdGhlIG9iamVjdCBpcyBpdGVyYWJsZVxuICogNC4gb3RoZXJ3aXNlOiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhIHNpbmdsZSBlbGVtZW50LCBgdmFsdWVgXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gU29tZXRoaW5nIHRvIGNhc3QgdG8gYW4gQXJyYXlcbiAqIEByZXR1cm5zIHtBcnJheTwqPn1cbiAqL1xuZXhwb3J0cy5jYXN0QXJyYXkgPSBmdW5jdGlvbiBjYXN0QXJyYXkodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFtudWxsXTtcbiAgfVxuICBpZiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICh0eXBlb2YgdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJyB8fCB2YWx1ZS5sZW5ndGggIT09IHVuZGVmaW5lZClcbiAgKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xuICB9XG4gIHJldHVybiBbdmFsdWVdO1xufTtcblxuZXhwb3J0cy5jb25zdGFudHMgPSBleHBvcnRzLmRlZmluZUNvbnN0YW50cyh7XG4gIE1PQ0hBX0lEX1BST1BfTkFNRVxufSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB1bmlxdWUgaWRlbnRpZmllclxuICogQHJldHVybnMge3N0cmluZ30gVW5pcXVlIGlkZW50aWZpZXJcbiAqL1xuZXhwb3J0cy51bmlxdWVJRCA9ICgpID0+IG5hbm9pZCgpO1xuXG5leHBvcnRzLmFzc2lnbk5ld01vY2hhSUQgPSBvYmogPT4ge1xuICBjb25zdCBpZCA9IGV4cG9ydHMudW5pcXVlSUQoKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgTU9DSEFfSURfUFJPUF9OQU1FLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvYmo7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhIE1vY2hhIElEIGZyb20gYW4gb2JqZWN0LCBpZiBwcmVzZW50LlxuICogQHBhcmFtIHsqfSBbb2JqXSAtIE9iamVjdFxuICogQHJldHVybnMge3N0cmluZ3x2b2lkfVxuICovXG5leHBvcnRzLmdldE1vY2hhSUQgPSBvYmogPT5cbiAgb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnID8gb2JqW01PQ0hBX0lEX1BST1BfTkFNRV0gOiB1bmRlZmluZWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nID0+IHtcblx0aWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcblx0fVxuXG5cdC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHdpdGggc3BlY2lhbCBtZWFuaW5nIGVpdGhlciBpbnNpZGUgb3Igb3V0c2lkZSBjaGFyYWN0ZXIgc2V0cy5cblx0Ly8gVXNlIGEgc2ltcGxlIGJhY2tzbGFzaCBlc2NhcGUgd2hlbiBpdOKAmXMgYWx3YXlzIHZhbGlkLCBhbmQgYSBcXHVubm5uIGVzY2FwZSB3aGVuIHRoZSBzaW1wbGVyIGZvcm0gd291bGQgYmUgZGlzYWxsb3dlZCBieSBVbmljb2RlIHBhdHRlcm5z4oCZIHN0cmljdGVyIGdyYW1tYXIuXG5cdHJldHVybiBzdHJpbmdcblx0XHQucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCsqPy5dL2csICdcXFxcJCYnKVxuXHRcdC5yZXBsYWNlKC8tL2csICdcXFxceDJkJyk7XG59O1xuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCJsZXQgdXJsQWxwaGFiZXQgPVxuICAndXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdCdcbmxldCBjdXN0b21BbHBoYWJldCA9IChhbHBoYWJldCwgZGVmYXVsdFNpemUgPSAyMSkgPT4ge1xuICByZXR1cm4gKHNpemUgPSBkZWZhdWx0U2l6ZSkgPT4ge1xuICAgIGxldCBpZCA9ICcnXG4gICAgbGV0IGkgPSBzaXplXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWQgKz0gYWxwaGFiZXRbKE1hdGgucmFuZG9tKCkgKiBhbHBoYWJldC5sZW5ndGgpIHwgMF1cbiAgICB9XG4gICAgcmV0dXJuIGlkXG4gIH1cbn1cbmxldCBuYW5vaWQgPSAoc2l6ZSA9IDIxKSA9PiB7XG4gIGxldCBpZCA9ICcnXG4gIGxldCBpID0gc2l6ZVxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWQgKz0gdXJsQWxwaGFiZXRbKE1hdGgucmFuZG9tKCkgKiA2NCkgfCAwXVxuICB9XG4gIHJldHVybiBpZFxufVxuZXhwb3J0IHsgbmFub2lkLCBjdXN0b21BbHBoYWJldCB9XG4iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iXSwic291cmNlUm9vdCI6IiJ9